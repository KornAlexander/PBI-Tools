{
  "Actions": [
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Alert Summary Measures",
      "Enabled": "true",
      "Execute": "/* \\n//2022-06-29 B.Agullo \\n//\\n// BLOG POST on the actual use case and how to use it\\n// https://www.esbrina-ba.com/data-validation-with-power-bi/\\n//\\n//Selecting a table will select the table for the overall summary measures.\\n//The script will go through all the tables of the model and \\n//for each table if will scan the measures contained in the display folder that starts with \\\"Checks \\\" \\n// and will generate a new display folder in the same table\\n//called \\\"Titles \\\" followed by the original display folder name\\n//where all measures original measures will have an equivalent measure\\n//with the expression [original measure] & Original measure name\\n//also another displayfolder called \\\"summary measures\\\" \\n//will contain 2 measures. One is the sum of all selected measures \\n//the other one is the concatenation of all the titles measures\\n//Useful when setting alarms when one measure is greater than 0\\n//on the original selected table it will store the sum of all the summary measures of the model\\n//read the blog post for a more clear idea of how to use it.\\n*/\\n\\n/*customize if needed*/\\nstring dynamicMeasureCustomActionName = \\\"Dynamic Measure\\\"; \\n\\nstring alertDisplayFolderPrefix = \\\"Checks \\\";\\nstring allMeasuresPrefix = \\\"Alerts Value \\\";\\nstring allTitleMeasuresPrefix = \\\"Alerts Descriptions \\\";\\nstring allMeasureCountPrefix = \\\"Alert Count \\\"; \\n\\nstring summaryMeasuresDisplayFolder = \\\"Summary Measures\\\";\\nstring titleMeasuresPrefix = \\\"Title \\\";\\nstring titleMeasuresDisplayFolderPrefix = \\\"Titles of \\\";\\n\\n\\n\\nstring overallAlertValueMeasureName = \\\"Total Alerts Value\\\";\\nstring overallAlertDescMeasureName = \\\"Total Alerts Description\\\";\\nstring overallAlertCountMeasureName = \\\"Total Alert Count\\\"; \\n\\n\\n/*do not modify below this line*/\\n\\n\\n\\nstring annotationKey = \\\"@AgulloBernat\\\";\\nstring annotationValue = \\\"Alert Summary Sum Measure\\\";\\nstring annotationValueDesc = \\\"Alert Description Concat Measure\\\";\\nstring annotationValueCount = \\\"Alert Count Measure\\\";\\n\\n\\nif(Selected.Tables.Count() != 1)\\n{\\n    ScriptHelper.Error(\\\"Select a table for overall alert measures and try again.\\\");\\n    return;\\n}\\n\\n//create calculation group without any calc items\\nModel.CustomAction(dynamicMeasureCustomActionName); \\n\\n/* go through each table ... */\\nforeach (Table t in Model.Tables)\\n{\\n\\n    string displayFolderName = \\\"\\\";\\n    string titleMeasuresDisplayFolderName = \\\"\\\";\\n    string allMeasureExpression = \\\"\\\";\\n    string allMeasureName = \\\"\\\";\\n    string allTitleMeasureExpression = \\\"\\\\\"\\\\\"\\\";\\n    string allTitleMeasureName = \\\"\\\";\\n    string allMeasureCountExpression = \\\"\\\";\\n    string allMeasureCountName = \\\"\\\"; \\n\\n\\n    /*check if there's any measure to process*/\\n    List<Measure> alertMeasures = new List<Measure>();\\n    foreach (Measure m in t.Measures)\\n    {\\n        if (m.DisplayFolder.Length >= alertDisplayFolderPrefix.Length)\\n        {\\n            if( m.DisplayFolder.Substring(0, alertDisplayFolderPrefix.Length) == alertDisplayFolderPrefix)\\n            {\\n\\n                alertMeasures.Add(m);\\n            }\\n        }\\n    }\\n\\n    /* if any was found */\\n    if (alertMeasures.Count() > 0) { \\n\\n        /*for each measure found, process it */\\n        foreach (Measure m in alertMeasures) { \\n\\n            if (displayFolderName == \\\"\\\")\\n            {\\n                displayFolderName = m.DisplayFolder;\\n                titleMeasuresDisplayFolderName = titleMeasuresDisplayFolderPrefix + displayFolderName;\\n            };\\n\\n            string titleMeasureName = titleMeasuresPrefix + m.Name;\\n            string titleMeasureExpression = m.DaxObjectName + \\\" & \\\\\" \\\" + m.Name + \\\"\\\\\"\\\";\\n\\n            foreach (Measure delM in Model.AllMeasures.Where(x => x.Name == titleMeasureName).ToList())\\n            {\\n                delM.Delete();\\n            };\\n\\n            Measure titleM = m.Table.AddMeasure(\\n                name: titleMeasureName,\\n                expression: titleMeasureExpression,\\n                displayFolder: titleMeasuresDisplayFolderName\\n            );\\n            \\n            titleM.FormatDax();\\n\\n            allMeasureExpression = allMeasureExpression + Environment.NewLine + \\\" + \\\" + m.DaxObjectName;\\n\\n            allTitleMeasureExpression =\\n                allTitleMeasureExpression\\n                    + \\\" & IF(\\\" + m.DaxObjectFullName + \\\"> 0,\\\"\\n                    + titleM.DaxObjectFullName + \\\" & UNICHAR(10))\\\";\\n                    \\n            //m.CustomAction(\\\"Dynamic Measure\\\");\\n            \\n            allMeasureCountExpression = \\n                allMeasureCountExpression \\n                + Environment.NewLine + \\\" + IF(\\\" + m.DaxObjectFullName + \\\"> 0, 1)\\\";\\n                \\n        };\\n\\n        /*now create the summary measures for that table*/\\n        allMeasureName = allMeasuresPrefix + t.Name;\\n        allTitleMeasureName = allTitleMeasuresPrefix + t.Name;\\n        allMeasureCountName = allMeasureCountPrefix + t.Name;\\n\\n        foreach (Measure delM in Model.AllMeasures.Where(x => x.Name == allMeasureName).ToList())\\n        {\\n            delM.Delete();\\n        };\\n\\n        foreach (Measure delM in Model.AllMeasures.Where(x => x.Name == allTitleMeasureName).ToList())\\n        {\\n            delM.Delete();\\n        };\\n        \\n        foreach (Measure delM in Model.AllMeasures.Where(x => x.Name == allMeasureCountName).ToList())\\n        {\\n            delM.Delete();\\n        };\\n\\n        Measure measure =\\n            t.AddMeasure(\\n                name: allMeasureName,\\n                expression: allMeasureExpression,\\n                displayFolder: summaryMeasuresDisplayFolder);\\n\\n        measure.SetAnnotation(annotationKey, annotationValue);\\n        measure.FormatString = \\\"#,##0\\\";\\n        measure.FormatDax();\\n        measure.CustomAction(dynamicMeasureCustomActionName);\\n        \\n        Measure titleMeasure =\\n            t.AddMeasure(\\n                name: allTitleMeasureName,\\n                expression: allTitleMeasureExpression,\\n                displayFolder: summaryMeasuresDisplayFolder);\\n\\n        titleMeasure.SetAnnotation(annotationKey, annotationValueDesc);\\n        titleMeasure.FormatDax(); \\n        titleMeasure.CustomAction(dynamicMeasureCustomActionName); \\n        \\n        Measure countMeasure =\\n            t.AddMeasure(\\n                name: allMeasureCountName,\\n                expression: allMeasureCountExpression,\\n                displayFolder: summaryMeasuresDisplayFolder);\\n\\n        countMeasure.SetAnnotation(annotationKey, annotationValueCount);\\n        countMeasure.FormatDax(); \\n        countMeasure.CustomAction(dynamicMeasureCustomActionName); \\n        \\n    }\\n}\\n\\n\\n/*once we processed all tables, time to create overall summary measures*/\\n/*clean up*/\\nif (Model.AllMeasures.Any(x => x.Name == overallAlertValueMeasureName))\\n{\\n    Model.AllMeasures.Where(\\n        x => x.Name == overallAlertValueMeasureName\\n        ).First().Delete();\\n\\n}\\n\\nif (Model.AllMeasures.Any(\\n    x => x.Name == overallAlertDescMeasureName))\\n{\\n    Model.AllMeasures.Where(\\n        x => x.Name == overallAlertDescMeasureName\\n        ).First().Delete();\\n\\n}\\n\\nif (Model.AllMeasures.Any(\\n    x => x.Name == overallAlertCountMeasureName))\\n{\\n    Model.AllMeasures.Where(\\n        x => x.Name == overallAlertCountMeasureName\\n        ).First().Delete();\\n\\n}\\n\\n\\n/*regenerate if necessary*/\\nif (Model.AllMeasures.Any(\\n    x => x.DisplayFolder.IndexOf(summaryMeasuresDisplayFolder) == 0\\n           & x.Name.IndexOf(allMeasuresPrefix) == 0))\\n{\\n\\n    string overallAlertValueMeasureExpression = \\\"\\\";\\n    string overallAlertDescMeasureExpression = \\\"\\\\\"\\\\\"\\\";\\n    string overallAlertCountMeasureExpression = \\\"\\\";\\n\\n    foreach (Measure m in\\n        Model.AllMeasures.Where(\\n            x => x.DisplayFolder.IndexOf(summaryMeasuresDisplayFolder) == 0\\n                & x.Name.IndexOf(allMeasuresPrefix) == 0))\\n    {\\n\\n\\n        overallAlertValueMeasureExpression =\\n            overallAlertValueMeasureExpression\\n                + \\\" + \\\" + m.DaxObjectFullName;\\n\\n    }\\n\\n    foreach (Measure m in\\n         Model.AllMeasures.Where(\\n             x => x.DisplayFolder.IndexOf(summaryMeasuresDisplayFolder) == 0\\n                 & x.Name.IndexOf(allTitleMeasuresPrefix) == 0))\\n    {\\n        overallAlertDescMeasureExpression =\\n            overallAlertDescMeasureExpression\\n                + \\\" & IF(LEN(\\\" +m.DaxObjectFullName +\\\")>0, UNICHAR(10) & UNICHAR(10) & \\\\\"********** \\\" \\n                    + m.Table.Name + \\\"*********\\\\\" & UNICHAR(10) & \\\" +  m.DaxObjectFullName + \\\")\\\";\\n\\n    }\\n\\n\\n\\n    foreach (Measure m in\\n         Model.AllMeasures.Where(\\n             x => x.DisplayFolder.IndexOf(summaryMeasuresDisplayFolder) == 0\\n                 & x.Name.IndexOf(allMeasureCountPrefix) == 0))\\n    {\\n        overallAlertCountMeasureExpression =\\n            overallAlertCountMeasureExpression\\n                + \\\" + \\\" + m.DaxObjectFullName;\\n\\n    }\\n\\n\\n    Measure alertValueMeasure = Selected.Table.AddMeasure(overallAlertValueMeasureName, overallAlertValueMeasureExpression);\\n    alertValueMeasure.FormatDax();\\n    alertValueMeasure.FormatString =\\\"#,##0\\\";\\n\\n    Measure alertDescMeasure = Selected.Table.AddMeasure(overallAlertDescMeasureName, overallAlertDescMeasureExpression);\\n    alertDescMeasure.FormatDax();\\n\\n    Measure alertCountMeasure =  Selected.Table.AddMeasure(overallAlertCountMeasureName, overallAlertCountMeasureExpression);\\n    alertCountMeasure.FormatDax();\\n    alertCountMeasure.FormatString =\\\"#,##0\\\";\\n\\n\\n};\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Color Measures",
      "Enabled": "true",
      "Execute": "// '2022-08-27 / B.Agullo / one-click enabled, guessing of name and hex color columns\\n// '2021-05-09 / B.Agullo / added transparent color\\n// by Bernat Agulló\\n// www.esbrina-ba.com\\n\\n//adapted from Darren Gosbell's script at \\n// https://darren.gosbell.com/2020/08/the-best-way-to-generate-data-driven-measures-in-power-bi-using-tabular-editor/\\n\\n//This script creates the color measures for each of the colors included in the theme color table. \\n// See http://www.esbrina-ba.com/theme-compliant-conditional-formatting-measures/\\n// Also https://www.esbrina-ba.com/building-a-fading-bar-chart/ \\n\\n//adjust to fit your particular model\\n\\n\\nstring colorNameTag = \\\"Name\\\"; //string likely to indicate a color name column\\nstring colorCodeTag = \\\"Hex\\\"; //string likely to indicate a color code column\\n\\n// -------- do not modify beyond this line (if you don't know what you are doing)\\n\\nif(Selected.Tables.Count() != 1) { \\n    Error(\\\"Select only table containing color definitions and try again\\\"); \\n};\\n\\nstring colorTableName = Selected.Table.Name; \\n\\n//get the first column containing \\\"Name\\\" in its name\\nstring colorColumnNameCandidate = \\n    Selected.Table.Columns\\n        .Where(x => x.Name.Contains(colorNameTag))\\n        .First().Name;\\n\\n\\n// let the user confirm if the guess is correct\\nstring colorColumnName = \\n    SelectColumn(\\n        Selected.Table,\\n        Selected.Table.Columns[colorColumnNameCandidate],\\n        \\\"Select color Name Column\\\"\\n    ).Name; \\n\\n\\n//get the first column containing \\\"Hex\\\" in its name\\nstring colorColumnCodeCandidate =\\n    Selected.Table.Columns\\n        .Where(x => x.Name.Contains(colorCodeTag))\\n        .First().Name;\\n\\n// let the user confirm if the guess is correct\\nstring hexCodeColumnName = \\n    SelectColumn(\\n        Selected.Table,\\n        Selected.Table.Columns[colorColumnCodeCandidate],\\n        \\\"Select color code Column\\\"\\n    ).Name; \\n\\nbool createTransparentColor = true; \\n\\n// do not change code below this line\\n\\n\\nstring colorColumnNameWithTable = \\\"'\\\" + colorTableName + \\\"'[\\\" + colorColumnName + \\\"]\\\";\\nstring hexCodeColumnNameWithTable = \\\"'\\\" + colorTableName + \\\"'[\\\" + hexCodeColumnName + \\\"]\\\";\\n\\nstring query = \\\"EVALUATE VALUES(\\\" + colorColumnNameWithTable + \\\")\\\";\\n \\nusing (var reader = Model.Database.ExecuteReader(query))\\n{\\n    // Create a loop for every row in the resultset\\n    while(reader.Read())\\n    {\\n        string myColor = reader.GetValue(0).ToString();\\n        string measureName = myColor;\\n        string myExpression = \\\"VAR HexCode = CALCULATE( SELECTEDVALUE( \\\" + hexCodeColumnNameWithTable + \\\"), \\\" + colorColumnNameWithTable + \\\" = \\\\\"\\\"  + myColor + \\\"\\\\\") VAR Result = FORMAT(hexCode,\\\\\"@\\\\\") RETURN Result \\\";\\n        \\n        if(Model.AllMeasures.Any(x => x.Name == measureName)) {\\n            foreach (Measure m in Model.AllMeasures.Where(x => x.Name == measureName).ToList()) { m.Delete(); }; \\n        };\\n\\n        var newColorMeasure = Model.Tables[colorTableName].AddMeasure(measureName, myExpression);\\n       newColorMeasure.FormatDax(); \\n        \\n    }\\n}\\n \\nif(createTransparentColor){\\n    \\n    if(Model.AllMeasures.Any(x => x.Name == \\\"Transparent\\\")) {\\n            foreach (Measure m in Model.AllMeasures.Where(x => x.Name == \\\"Transparent\\\").ToList()) { m.Delete(); }; \\n    };\\n\\n    var transparentMeasure = Model.Tables[colorTableName].AddMeasure(\\\"Transparent\\\",\\\"\\\\\"#FFFFFF00\\\\\"\\\"); \\n};\\n\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Column Width Calc Group",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n// '2021-10-03 / B.Agullo / \\n// Calc group definition by B.Agullo as presented in https://www.esbrina-ba.com/the-ultimate-hack-to-set-column-widths-in-a-matrix/\\n// Code to generate the calc group mostly generated by @Avatori's script published in https://powerofbi.org/2021/09/14/backup-restore-all-calculation-groups-workaround-required-for-some-visuals/\\n// \\\"Auto\\\" calc item needs manual tuning that can be done once the calc group is created, instructions included in the calc item. \\n\\n// all parameters are required at run time so it can be stored as macro at model level\\n\\n\\n\\nstring calcGroupName = Interaction.InputBox(\\\"Provide a name for your Calc Group\\\", \\\"Calc Group Name\\\", \\\"Column Width\\\", 740, 400);\\nstring minWidth = Interaction.InputBox(\\\"Enter minimum column width\\\", \\\"Min Column Width\\\", \\\"5\\\", 740, 400);\\n\\nint minWidthInt; \\n\\nbool isMinWidthANumber = Int32.TryParse(minWidth, out minWidthInt); \\n\\nif (!isMinWidthANumber) {\\n    Error(minWidth + \\\" is not a positive integer. Invalid width\\\"); \\n    return; \\n} else if(minWidthInt < 0) { \\n    Error(minWidth + \\\" is smaller than 0. Invalid Min width.\\\"); \\n    return; \\n}; \\n\\nstring maxWidth = Interaction.InputBox(\\\"Enter minimum column width\\\", \\\"Min Column Width\\\", \\\"7\\\", 740, 400);\\n\\nint maxWidthInt; \\n\\nbool isMaxWidthANumber = Int32.TryParse(maxWidth, out maxWidthInt); \\n\\nif (!isMaxWidthANumber) {\\n    Error(maxWidth + \\\" is not a positive integer. Invalid width\\\"); \\n    return; \\n} else if(maxWidthInt < minWidthInt) { \\n    Error(maxWidth + \\\" is smaller than \\\" + minWidthInt +\\\". Invalid Max width.\\\"); \\n    return; \\n}; \\n\\n\\n//create calculation group Column Width\\nvar calculationGroupTable1 = Model.AddCalculationGroup ();\\n(Model.Tables[\\\"New Calculation Group\\\"] as CalculationGroupTable).CalculationGroup.Precedence = 1;\\ncalculationGroupTable1.Name = calcGroupName;\\ncalculationGroupTable1.Columns[\\\"Name\\\"].Name = calcGroupName; \\n\\nfor( int i = minWidthInt; i<=maxWidthInt; i++) {\\n\\n    //create calculation item 5\\n    var calculationItem1 = calculationGroupTable1.AddCalculationItem(Convert.ToString(i,10));\\n    calculationItem1.Expression = @\\\"SELECTEDMEASURE()\\\";\\n    calculationItem1.FormatStringExpression = @\\\"VAR currentValue =\\n        SELECTEDMEASURE()\\n    VAR currentLength =\\n        LEN(  CONVERT( currentValue, STRING ) ) \\n        \\n    VAR selectedLength = CONVERT( SELECTEDVALUE( 'Column Width'[Column Width], currentLength ), INTEGER )\\n\\n    VAR extraSpaces = IF( selectedLength > currentLength, selectedLength - currentLength, 0 ) \\n\\n    VAR prefix =\\n        REPT( UNICHAR(0160), extraSpaces )\\n    RETURN\\n        \\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\" & prefix & \\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\n            & SELECTEDMEASUREFORMATSTRING()\\\";\\n    calculationItem1.FormatDax();\\n\\n}; \\n\\n\\n\\n//create calculation item auto;\\nvar calculationItemAuto = calculationGroupTable1.AddCalculationItem(\\\"auto\\\");\\ncalculationItemAuto.Expression = @\\\"SELECTEDMEASURE()\\\";\\ncalculationItemAuto.FormatStringExpression = @\\\"//// instructions to enable auto-mode: \\n// 1. delete line SELECTEDMEASUREFORMATSTRING() that is not commented \\n// 2. uncomment the rest of the code \\n// 3. replace the expression for maxValue for an expression that will return the max value of your matrix\\n// You can duplicate the calc item to use in different matrices of your report\\n\\nSELECTEDMEASUREFORMATSTRING()\\n\\n//VAR currentValue =\\n//    SELECTEDMEASURE()\\n//VAR currentLength =\\n//    LEN(  CONVERT( currentValue, STRING ) ) \\n//\\n//VAR maxValue = CALCULATE(MAXX(SUMMARIZE('Sales','Sales'[Order number],'Sales'[Customer]),SELECTEDMEASURE()),ALLSELECTED( sales ))\\n//VAR maxLength = LEN( TRIM( CONVERT( maxValue, STRING ) )) //+ X if you want some padding\\n//\\n//VAR extraSpaces = IF( maxLength > currentLength, maxLength - currentLength, 0 ) \\n//\\n//VAR prefix =\\n//    REPT( UNICHAR(0160), extraSpaces )\\n//RETURN\\n//    \\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\" & prefix & \\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\n//        & SELECTEDMEASUREFORMATSTRING()\\\";\\ncalculationItemAuto.FormatDax();",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Create Aribrary Period Comparison Calc Group",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\nusing Microsoft.VisualBasic;\\nstring calcGroupName = Fx.GetNameFromUser(\\\"Input Calc Group Name\\\",DefaultResponse: \\\"Model\\\");\\nstring selectedCalcItemName = Fx.GetNameFromUser(\\\"Input Selected calc Item name\\\", DefaultResponse: \\\"Selected\\\");\\nstring referenceCalcItemName =  Fx.GetNameFromUser(\\\"Input Reference calc Item name\\\", DefaultResponse: \\\"Reference\\\");\\nstring comparisonCalcItemName =  Fx.GetNameFromUser(\\\"Input Comparison calc item name\\\", DefaultResponse: \\\"Comparison\\\");\\nstring comparisonPctCalcItemName =  Fx.GetNameFromUser(\\\"Input Comparison % name\\\", DefaultResponse: \\\"Comparison %\\\");\\nstring daysMeasureName =  Fx.GetNameFromUser(\\\"Input Days Selected Measure name\\\", DefaultResponse: \\\"Days Selected\\\");\\nstring referenceDaysRawMeasureName =  Fx.GetNameFromUser(\\\"Input Days Reference raw Measure name\\\", DefaultResponse: \\\"Days Reference Raw\\\");\\nstring referenceDaysMeasureName =  Fx.GetNameFromUser(\\\"Input Days Refference name\\\", DefaultResponse: \\\"Days Reference\\\");\\nstring daysDifferenceMeasureName =  Fx.GetNameFromUser(\\\"Input Days Difference name\\\", DefaultResponse: \\\"Days Difference\\\");\\nIEnumerable<Table> dateTables = Fx.GetDateTables(Model);\\nif (dateTables == null) return;\\nif (dateTables.Count() < 2)\\n{\\n    Error(\\\"Less than 2 date tables detected in your model. A minimum of 2 date tables (marked as date tables) are required to run this script\\\");\\n    return;\\n}\\nTable dateTable = SelectTable(tables: dateTables, preselect: dateTables.First(), label: \\\"Select main date table\\\");\\nif (dateTable == null)\\n{\\n    Error(\\\"No table selected.\\\");\\n    return;\\n}\\nFunc<Column, bool> weekColFunc = c => c.Name.Contains(\\\"Week\\\") || c.Name.Contains(\\\"Semana\\\");\\nIEnumerable<Column> dayOfWeekColumns = Fx.GetFilteredColumns(dateTable.Columns, weekColFunc);\\n\\nColumn dayOfWeekColumn = SelectColumn(dayOfWeekColumns, dayOfWeekColumns.First(), label: \\\"Select Day of Week column\\\");\\nif (dayOfWeekColumn == null) { Error(\\\"No column selected\\\"); return; }\\nTable referenceDateTable = SelectTable(tables: dateTables, preselect: dateTables.Last(), label: \\\"Select reference date table\\\");\\nif (referenceDateTable == null)\\n{\\n    Error(\\\"No table selected.\\\");\\n    return;\\n}\\nIEnumerable<Column> referenceDayOfWeekColumns = Fx.GetFilteredColumns(referenceDateTable.Columns, weekColFunc);\\nColumn referenceDayOfWeekColumn = SelectColumn(referenceDayOfWeekColumns, referenceDayOfWeekColumns.First(), label: \\\"Select Day of Week column of reference Date Table\\\");\\nif (referenceDayOfWeekColumn == null) { Error(\\\"No column selected\\\"); return; }\\nCalculationGroupTable calcGroup = Model.AddCalculationGroup(calcGroupName);\\nColumn calcGroupColumn = calcGroup.Columns[0];\\ncalcGroupColumn.Name = calcGroup.Name;\\nstring selectedCalcItemExpression =\\n    String.Format(\\n        @\\\"CALCULATE(\\n            SELECTEDMEASURE( ),\\n            REMOVEFILTERS( {0} )\\n        )\\\",\\n        referenceDateTable.DaxObjectFullName);\\nCalculationItem selectedCalcItem = calcGroup.AddCalculationItem(selectedCalcItemName, selectedCalcItemExpression);\\nselectedCalcItem.FormatDax();\\nselectedCalcItem.Ordinal = 0;\\nstring referenceCalcItemExpression =\\n    String.Format(\\n        @\\\"CALCULATE(\\n            CALCULATE( SELECTEDMEASURE( ), REMOVEFILTERS( {0} ) ),\\n            TREATAS(\\n                VALUES( {1} ),\\n                {2}\\n            )\\n        )\\\",\\n        dateTable.DaxObjectFullName,\\n        dayOfWeekColumn.DaxObjectFullName,\\n        referenceDayOfWeekColumn.DaxObjectFullName\\n     );\\nCalculationItem referenceCalcItem = calcGroup.AddCalculationItem(referenceCalcItemName, referenceCalcItemExpression);\\nreferenceCalcItem.FormatDax();\\nreferenceCalcItem.Ordinal = 1;\\nstring comparisonCalcItemExpression =\\n    String.Format(\\n        @\\\"VAR _selection =\\n            CALCULATE(\\n                SELECTEDMEASURE( ),\\n                REMOVEFILTERS( {0} )\\n            )\\n        VAR _refrence =\\n            CALCULATE(\\n                CALCULATE( SELECTEDMEASURE( ),REMOVEFILTERS( {1} )),\\n                TREATAS(\\n                    VALUES( {2} ),\\n                    {3}\\n                )\\n            )\\n        VAR _result =\\n            IF(\\n                ISBLANK( _selection ) || ISBLANK( _refrence ),\\n                BLANK( ),\\n                _selection - _refrence\\n            )\\n        RETURN\\n            _result\\\",\\n        referenceDateTable.DaxObjectFullName,\\n        dateTable.DaxObjectFullName,\\n        dayOfWeekColumn.DaxObjectFullName,\\n        referenceDayOfWeekColumn.DaxObjectFullName);\\nstring comparisonCalcItemFormatStringExpression =\\n    @\\\"VAR _fs = SELECTEDMEASUREFORMATSTRING()\\n    RETURN \\\"\\\"+\\\"\\\" & _fs & \\\"\\\";-\\\"\\\" & _fs & \\\"\\\";-\\\"\\\" \\\";\\nCalculationItem comparisonCalcItem = calcGroup.AddCalculationItem(comparisonCalcItemName, comparisonCalcItemExpression);\\ncomparisonCalcItem.FormatStringExpression = comparisonCalcItemFormatStringExpression;\\ncomparisonCalcItem.FormatDax();\\ncomparisonCalcItem.Ordinal = 2;\\nstring comparisonPctCalcItemExpression =\\n    String.Format(\\n        @\\\"VAR _selection =\\n            CALCULATE(\\n                SELECTEDMEASURE( ),\\n                REMOVEFILTERS( {0} )\\n            )\\n        VAR _refrence =\\n            CALCULATE(\\n                CALCULATE( SELECTEDMEASURE( ),REMOVEFILTERS( {1} ) ),\\n                TREATAS(\\n                    VALUES( {2} ),\\n                    {3}\\n                )\\n            )\\n        VAR _result =\\n            IF(\\n                ISBLANK( _selection ) || ISBLANK( _refrence ),\\n                BLANK( ),\\n                DIVIDE( _selection - _refrence, _refrence )\\n            )\\n        RETURN\\n            _result\\\",\\n        referenceDateTable.DaxObjectFullName,\\n        dateTable.DaxObjectFullName,\\n        dayOfWeekColumn.DaxObjectFullName,\\n        referenceDayOfWeekColumn.DaxObjectFullName);\\nstring comparisonPctCalcItemFormatStringExpression = @\\\"\\\"\\\"+0 %;-0 %;-\\\"\\\"\\\";\\nCalculationItem comparisonPctCalcItem = calcGroup.AddCalculationItem(comparisonPctCalcItemName, comparisonPctCalcItemExpression);\\ncomparisonPctCalcItem.FormatStringExpression = comparisonPctCalcItemFormatStringExpression;\\ncomparisonPctCalcItem.FormatDax();\\ncomparisonPctCalcItem.Ordinal = 3;\\nstring daysMeasureExpression =\\n    String.Format(\\n        @\\\"COUNTROWS({0})\\\",\\n        dateTable.DaxObjectFullName);\\nMeasure daysMeasure = dateTable.AddMeasure(name: daysMeasureName, expression: daysMeasureExpression);\\ndaysMeasure.FormatString = @\\\"\\\"\\\"0\\\"\\\"\\\"; \\ndaysMeasure.FormatDax();\\nstring referenceDaysRawMeasureExpression =\\n    String.Format(\\n        @\\\"COUNTROWS({0})\\\",\\n        referenceDateTable.DaxObjectFullName);\\nMeasure referenceDaysRawMeasure = referenceDateTable.AddMeasure(name: referenceDaysRawMeasureName, expression: referenceDaysRawMeasureExpression);\\nreferenceDaysRawMeasure.FormatString = @\\\"\\\"\\\"0\\\"\\\"\\\";\\nreferenceDaysRawMeasure.FormatDax();\\nstring referenceDaysMeasureExpression =\\n    String.Format(\\n        @\\\"CALCULATE({0},{1}=\\\"\\\"{2}\\\"\\\")\\\",\\n        referenceDaysRawMeasure.DaxObjectFullName,\\n        calcGroupColumn.DaxObjectFullName,\\n        referenceCalcItem.Name);\\nMeasure referenceDaysMeasure = referenceDateTable.AddMeasure(name: referenceDaysMeasureName, expression: referenceDaysMeasureExpression);\\nreferenceDaysMeasure.FormatDax();\\nstring daysDifferenceMeasureExpression =\\n    String.Format(\\n        @\\\"{0} - {1}\\\",\\n        daysMeasure.DaxObjectFullName,\\n        referenceDaysMeasure.DaxObjectFullName);\\nMeasure differenceDaysMeasure = referenceDateTable.AddMeasure(name: daysDifferenceMeasureName, expression: daysDifferenceMeasureExpression);\\ndifferenceDaysMeasure.FormatDax();\\ndifferenceDaysMeasure.FormatString = @\\\"\\\"\\\"0\\\"\\\"\\\";\\n\\npublic static class Fx\\n{\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        IEnumerable<Table> dateTables = null as IEnumerable<Table>;\\n        if (model.Tables.Any(t => t.DataCategory == \\\"Time\\\" && t.Columns.Any(c => c.IsKey == true)))\\n        {\\n            dateTables = model.Tables.Where(t => t.DataCategory == \\\"Time\\\" && t.Columns.Any(c => c.IsKey == true && c.DataType == DataType.DateTime));\\n        }\\n        else\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        if(matchTables == null)\\n        {\\n            return null;\\n        }\\n        else\\n        {\\n            return matchTables.First();\\n        }\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table,bool> lambda)\\n    {\\n        if (tables.Any(t => lambda(t)))\\n        {\\n            return tables.Where(t => lambda(t));\\n        }\\n        else\\n        {\\n            return null as IEnumerable<Table>; \\n        }\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column,bool> lambda, bool returnAllIfNoneFound = true) \\n    {\\n        if (columns.Any(c => lambda(c)))\\n        {\\n            return columns.Where(c => lambda(c));\\n        }\\n        else\\n        {\\n            if(returnAllIfNoneFound)\\n            {\\n                return columns;\\n            }\\n            else\\n            {\\n                return null as IEnumerable<Column>;\\n            }\\n        }\\n    }\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        if(!model.Tables.Any(t => t.Name == tableName))\\n        {\\n            return model.AddCalculatedTable(tableName, tableExpression);\\n        }\\n        else\\n        {\\n            return model.Tables.Where(t => t.Name == tableName).First();\\n        }\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title =\\\"\\\", string DefaultResponse = \\\"\\\")\\n    {    \\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList)\\n    {\\n        Func<IList<string>, string, string> SelectString = (IList<string> options, string title) =>\\n        {\\n            var form = new Form();\\n            form.Text = title;\\n            var buttonPanel = new Panel();\\n            buttonPanel.Dock = DockStyle.Bottom;\\n            buttonPanel.Height = 30;\\n            var okButton = new Button() { DialogResult = DialogResult.OK, Text = \\\"OK\\\" };\\n            var cancelButton = new Button() { DialogResult = DialogResult.Cancel, Text = \\\"Cancel\\\", Left = 80 };\\n            var listbox = new ListBox();\\n            listbox.Dock = DockStyle.Fill;\\n            listbox.Items.AddRange(options.ToArray());\\n            listbox.SelectedItem = options[0];\\n            form.Controls.Add(listbox);\\n            form.Controls.Add(buttonPanel);\\n            buttonPanel.Controls.Add(okButton);\\n            buttonPanel.Controls.Add(cancelButton);\\n            var result = form.ShowDialog();\\n            if (result == DialogResult.Cancel) return null;\\n            return listbox.SelectedItem.ToString();\\n        };\\n        //let the user select the name of the macro to copy\\n        String select = SelectString(OptionList, \\\"Choose a macro\\\");\\n        //check that indeed one macro was selected\\n        if (select == null)\\n        {\\n            Info(\\\"You cancelled!\\\");\\n        }\\n        return select;\\n    }\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Create Field Parameter",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic; \\n\\n//99% comes from Daniel Otykier --> https://github.com/TabularEditor/TabularEditor3/issues/541#issuecomment-1129228481\\n//1% B.Agullo --> pop-up to choose parameter name. \\n\\n// Before running the script, select the measures or columns that you\\n// would like to use as field parameters (hold down CTRL to select multiple\\n// objects). Also, you may change the name of the field parameter table\\n// below. NOTE: If used against Power BI Desktop, you must enable unsupported\\n// features under File > Preferences (TE2) or Tools > Preferences (TE3).\\nvar name = Interaction.InputBox(\\\"Provide the name for the field parameter\\\",\\\"Parameter name\\\",\\\"Parameter\\\");\\n\\nif(Selected.Columns.Count == 0 && Selected.Measures.Count == 0) throw new Exception(\\\"No columns or measures selected!\\\");\\n\\n// Construct the DAX for the calculated table based on the current selection:\\nvar objects = Selected.Columns.Any() ? Selected.Columns.Cast<ITabularTableObject>() : Selected.Measures;\\nvar dax = \\\"{\\n    \\\" + string.Join(\\\",\\n    \\\", objects.Select((c,i) => string.Format(\\\"(\\\\\"{0}\\\\\", NAMEOF('{1}'[{0}]), {2})\\\", c.Name, c.Table.Name, i))) + \\\"\\n}\\\";\\n\\n// Add the calculated table to the model:\\nvar table = Model.AddCalculatedTable(name, dax);\\n\\n// In TE2 columns are not created automatically from a DAX expression, so \\n// we will have to add them manually:\\nvar te2 = table.Columns.Count == 0;\\nvar nameColumn = te2 ? table.AddCalculatedTableColumn(name, \\\"[Value1]\\\") : table.Columns[\\\"Value1\\\"] as CalculatedTableColumn;\\nvar fieldColumn = te2 ? table.AddCalculatedTableColumn(name + \\\" Fields\\\", \\\"[Value2]\\\") : table.Columns[\\\"Value2\\\"] as CalculatedTableColumn;\\nvar orderColumn = te2 ? table.AddCalculatedTableColumn(name + \\\" Order\\\", \\\"[Value3]\\\") : table.Columns[\\\"Value3\\\"] as CalculatedTableColumn;\\n\\nif(!te2) {\\n    // Rename the columns that were added automatically in TE3:\\n    nameColumn.IsNameInferred = false;\\n    nameColumn.Name = name;\\n    fieldColumn.IsNameInferred = false;\\n    fieldColumn.Name = name + \\\" Fields\\\";\\n    orderColumn.IsNameInferred = false;\\n    orderColumn.Name = name + \\\" Order\\\";\\n}\\n// Set remaining properties for field parameters to work\\n// See: https://twitter.com/markbdi/status/1526558841172893696\\nnameColumn.SortByColumn = orderColumn;\\nnameColumn.GroupByColumns.Add(fieldColumn);\\nfieldColumn.SortByColumn = orderColumn;\\nfieldColumn.SetExtendedProperty(\\\"ParameterMetadata\\\", \\\"{\\\\\"version\\\\\":3,\\\\\"kind\\\\\":2}\\\", ExtendedPropertyType.Json);\\nfieldColumn.IsHidden = true;\\norderColumn.IsHidden = true;",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Create measures with a calculation group",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic; \\nusing System.Windows.Forms;\\n\\n/* '2022-06-13 / B.Agullo / */\\n/* '2022-09-17 / B.Agullo / possibility to create a Field Parameter with a column for the base measure & calc Item\\n/* CREATE MEASURES WITH BASE MEASURES AND A CALCULATION GROUP */ \\n\\n/* See: https://www.esbrina-ba.com/creating-well-formatted-measures-based-on-a-calculation-group/  */\\n/* See: https://www.esbrina-ba.com/a-dynamic-legend-for-a-dynamic-measure-time-intel-chart/\\n/* select measures and execute, you will need to run it twice */ \\n/* first time to create aux calc group, second time to actually create measuree*/ \\n/* remove aux calc group before going to production, do the right thing */ \\n\\nstring auxCgTag = \\\"@AgulloBernat\\\";\\nstring auxCgTagValue = \\\"CG to extract format strings\\\";\\n\\nstring auxCalcGroupName = \\\"DELETE AUX CALC GROUP\\\";\\nstring auxCalcItemName = \\\"Get Format String\\\";\\n\\nstring baseMeasureAnnotationName = \\\"Base Measure\\\"; \\nstring calcItemAnnotationName = \\\"Calc Item\\\"; \\nstring calcItemSortOrderName = \\\"Sort Order\\\";\\nstring calcItemSortOrderValue = String.Empty;  \\n\\nstring scriptAnnotationName = \\\"Script\\\";\\nstring scriptAnnotationValue = \\\"Create Measures with a Calculation Group\\\"; \\n\\nbool generateFieldParameter;\\n\\nDialogResult dialogResult = MessageBox.Show(\\\"Generate Field Parameter?\\\", \\\"Field Parameter\\\", MessageBoxButtons.YesNo);\\ngenerateFieldParameter = (dialogResult == DialogResult.Yes);\\n\\n\\n/*find any regular CGs (excluding the one we might have created)*/\\nvar regularCGs = Model.Tables.Where(\\n    x => x.ObjectType == ObjectType.CalculationGroupTable\\n    & x.GetAnnotation(auxCgTag) != auxCgTagValue);\\n\\nif (regularCGs.Count() == 0)\\n{\\n    Error(\\\"No Calculation Groups Found\\\");\\n    return;\\n};\\n\\n/*check if we already created the auxiliary calculation group*/\\nvar auxCgs = Model.Tables.Where(x => x.GetAnnotation(auxCgTag) == auxCgTagValue);\\n\\nCalculationGroupTable auxCg = null as CalculationGroupTable; \\n\\n/*if there are more than one for some reason we'll just use the first one*/\\nif(auxCgs.Count() >= 1)\\n{\\n    auxCg = auxCgs.First() as CalculationGroupTable; \\n} else \\n{\\n    /*create the aux calc group and ask for a refresh since it cannot be used in a query before that*/\\n    auxCg = Model.AddCalculationGroup(name: auxCalcGroupName);\\n    auxCg.AddCalculationItem(name: auxCalcItemName, expression: \\\"SELECTEDMEASUREFORMATSTRING()\\\");\\n    auxCg.SetAnnotation(auxCgTag, auxCgTagValue);\\n\\n    /*better hidden in case someone forgets to delete it*/\\n    auxCg.IsHidden = true; \\n    int maxPrecedence = 0; \\n\\n    /*check for the max precedence of other calc groups*/\\n    foreach (CalculationGroupTable cg in regularCGs)\\n    {\\n        if (cg.CalculationGroupPrecedence > maxPrecedence)\\n        {\\n            maxPrecedence = cg.CalculationGroupPrecedence;\\n        };\\n    };\\n\\n    /*assign the highest precedence and some margin*/\\n    auxCg.CalculationGroupPrecedence = maxPrecedence + 10; \\n\\n    Info(\\\"Save changes to the model, recalculate the model, and launch the script again.\\\");\\n    return;\\n\\n};\\n\\n\\n\\n\\n/*check if any measures are selected*/\\nif (Selected.Measures.Count == 0)\\n{\\n    Error(\\\"No measures selected\\\");\\n    return;\\n}\\n\\nCalculationGroupTable regularCg = null as CalculationGroupTable;\\n\\n/*allow user to select calculation group if more than one is found*/\\nif (regularCGs.Count() > 1)\\n{\\n    regularCg = SelectTable(regularCGs) as CalculationGroupTable;\\n}\\n/*otherwise just pick the first (and only)*/\\nelse\\n{\\n    regularCg = regularCGs.First() as CalculationGroupTable;\\n}\\n\\n/*check if no selection was made*/ \\nif(regularCg == null)\\n{\\n    Error(\\\"No Target Calculation Group selected\\\");\\n    return;\\n};\\n\\nstring name = String.Empty; \\nif(generateFieldParameter) {\\n    name = Interaction.InputBox(\\\"Provide a name for the field parameter\\\", \\\"Field Parameter\\\", regularCg.Name + \\\" Measures\\\", 740, 400);\\n    if(name == \\\"\\\") {Error(\\\"Execution Aborted\\\"); return;};\\n}; \\n\\n\\nMeasureCollection measures; \\n\\n/*iterates through each selected measure*/\\nforeach (Measure m in Selected.Measures)\\n{\\n    /*check that base measure has a proper format string*/ \\n    if(m.FormatString == \\\"\\\") {\\n        Error(\\\"Define FormatString for \\\" + m.Name + \\\" and try again\\\");\\n        return;\\n    };\\n\\n    /*prepares a displayfolder to store all new measures*/\\n    string displayFolderName = m.Name + \\\" Measures\\\";\\n\\n    /*iterates thorough all calculation items of the selected calc group*/ \\n    foreach (CalculationItem calcItem in regularCg.CalculationItems)\\n    {\\n        /*measure name*/ \\n        string measureName = m.Name + \\\" \\\" + calcItem.Name;           \\n        \\n        //only if the measure is not yet there (think of reruns)\\n        if(!Model.AllMeasures.Any(x => x.Name == measureName)){\\n\\n            /*prepares a query to calculate the resulting format when applying the calculation item on the measure*/ \\n            string query = string.Format(\\n                \\\"EVALUATE {{CALCULATE({0},{1},{2})}}\\\",\\n                m.DaxObjectFullName,\\n                string.Format(\\n                    \\\"{0}=\\\\\"{1}\\\\\"\\\",\\n                    regularCg.Columns[0].DaxObjectFullName,\\n                    calcItem.Name),\\n                string.Format(\\n                    \\\"{0}=\\\\\"{1}\\\\\"\\\",\\n                    auxCg.Columns[0].DaxObjectFullName,\\n                    auxCalcItemName)\\n                );\\n\\n            /*executes the query*/ \\n            using (var reader = Model.Database.ExecuteReader(query))\\n            {\\n                // resultset should contain just one row, with the format string\\n                while (reader.Read())\\n                {\\n                                 \\n\\n                    /*retrive the formatstring from the query*/ \\n                    string formatString = reader.GetValue(0).ToString();\\n\\n                    /*build the expression of the measure*/\\n                    string measureExpression = string.Format(\\n                        \\\"CALCULATE({0},{1}=\\\\\"{2}\\\\\")\\\",\\n                        m.DaxObjectName,\\n                        regularCg.Columns[0].DaxObjectFullName,\\n                        calcItem.Name);\\n\\n                    \\n                    \\n                    /*actually build the measure*/ \\n                    Measure newMeasure = \\n                        m.Table.AddMeasure(\\n                            name: measureName,\\n                            expression: measureExpression);\\n\\n\\n                    /*the all important format string!*/\\n                    newMeasure.FormatString = formatString;\\n\\n                    /*final polish*/\\n                    newMeasure.DisplayFolder = displayFolderName;\\n                    newMeasure.FormatDax();\\n                    \\n                    /*add annotations for the creation of the field parameter*/\\n                    newMeasure.SetAnnotation(baseMeasureAnnotationName,m.Name); \\n                    newMeasure.SetAnnotation(calcItemAnnotationName,calcItem.Name);\\n                    newMeasure.SetAnnotation(scriptAnnotationName,scriptAnnotationValue);\\n                    newMeasure.SetAnnotation(calcItemSortOrderName,calcItem.Ordinal.ToString(\\\"000\\\"));\\n\\n                }\\n            }\\n        }\\n    } \\n}\\n\\n\\nif(!generateFieldParameter) {\\n    //end of execution\\n    return;\\n};\\n\\n\\n// Before running the script, select the measures or columns that you\\n// would like to use as field parameters (hold down CTRL to select multiple\\n// objects). Also, you may change the name of the field parameter table\\n// below. NOTE: If used against Power BI Desktop, you must enable unsupported\\n// features under File > Preferences (TE2) or Tools > Preferences (TE3).\\n\\n\\nif(Selected.Columns.Count == 0 && Selected.Measures.Count == 0) throw new Exception(\\\"No columns or measures selected!\\\");\\n\\n// Construct the DAX for the calculated table based on the measures created previously by the script\\nvar objects = Model.AllMeasures\\n    .Where(x => x.GetAnnotation(scriptAnnotationName) == scriptAnnotationValue)\\n    .OrderBy(x => x.GetAnnotation(baseMeasureAnnotationName) + x.GetAnnotation(calcItemSortOrderName)); \\n\\nvar dax = \\\"{\\n    \\\" + string.Join(\\\",\\n    \\\", objects.Select((c,i) => string.Format(\\\"(\\\\\"{0}\\\\\", NAMEOF('{1}'[{0}]), {2},\\\\\"{3}\\\\\",\\\\\"{4}\\\\\")\\\", \\n    c.Name, c.Table.Name, i,\\n    Model.Tables[c.Table.Name].Measures[c.Name].GetAnnotation(\\\"Base Measure\\\"),\\n    Model.Tables[c.Table.Name].Measures[c.Name].GetAnnotation(\\\"Calc Item\\\")))) + \\\"\\n}\\\";\\n\\n// Add the calculated table to the model:\\nvar table = Model.AddCalculatedTable(name, dax);\\n\\n// In TE2 columns are not created automatically from a DAX expression, so \\n// we will have to add them manually:\\nvar te2 = table.Columns.Count == 0;\\nvar nameColumn = te2 ? table.AddCalculatedTableColumn(name, \\\"[Value1]\\\") : table.Columns[\\\"Value1\\\"] as CalculatedTableColumn;\\nvar fieldColumn = te2 ? table.AddCalculatedTableColumn(name + \\\" Fields\\\", \\\"[Value2]\\\") : table.Columns[\\\"Value2\\\"] as CalculatedTableColumn;\\nvar orderColumn = te2 ? table.AddCalculatedTableColumn(name + \\\" Order\\\", \\\"[Value3]\\\") : table.Columns[\\\"Value3\\\"] as CalculatedTableColumn;\\n\\nif(!te2) {\\n    // Rename the columns that were added automatically in TE3:\\n    nameColumn.IsNameInferred = false;\\n    nameColumn.Name = name;\\n    fieldColumn.IsNameInferred = false;\\n    fieldColumn.Name = name + \\\" Fields\\\";\\n    orderColumn.IsNameInferred = false;\\n    orderColumn.Name = name + \\\" Order\\\";\\n}\\n// Set remaining properties for field parameters to work\\n// See: https://twitter.com/markbdi/status/1526558841172893696\\nnameColumn.SortByColumn = orderColumn;\\nnameColumn.GroupByColumns.Add(fieldColumn);\\nfieldColumn.SortByColumn = orderColumn;\\nfieldColumn.SetExtendedProperty(\\\"ParameterMetadata\\\", \\\"{\\\\\"version\\\\\":3,\\\\\"kind\\\\\":2}\\\", ExtendedPropertyType.Json);\\nfieldColumn.IsHidden = true;\\norderColumn.IsHidden = true;",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Data Problems Button Measures",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n// '2021-05-26 / B.Agullo / \\n// '2021-10-13 / B.Agullo / dynamic parameters for one-click operation\\n// '2022-10-18 / B.Agullo / Bug fixes\\n// '2024-07-12 / B.Agullo / annotations for execution with \\\"Create Data Problems Button.csx\\\"\\n\\n// by Bernat Agulló\\n// www.esbrina-ba.com\\n// Instructions: \\n//select the measures that counts the number of \\\"data problems\\\" the model has and then run the script or as macro\\n//when adding macro select measure context for execution \\n//\\n// ----- do not modify script below this line -----\\n//\\nif (Selected.Measures.Count != 1)\\n{\\n    Error(\\\"Select one and only one measure\\\");\\n    return;\\n};\\n\\nstring navigationTableName = Interaction.InputBox(\\\"Provide a name for navigation measures table name\\\", \\\"Navigation Table Name\\\", \\\"Navigation\\\", 740, 400);\\nif(navigationTableName == \\\"\\\") return;\\n\\nif(Model.Tables.Any(Table => Table.Name == navigationTableName)) {\\n    Error(navigationTableName + \\\" already exists!\\\");\\n    return; \\n};\\n\\nstring annotationLabel = \\\"DataProblemsMeasures\\\";\\nstring annotationValueNavigation = \\\"ButtonNavigationMeasure\\\";\\nstring annotationValueText = \\\"ButtonTextMeasure\\\";\\nstring annotationValueBackground = \\\"ButtonBackgroundMeasure\\\";\\n\\nstring navigationTableName = Interaction.InputBox(\\\"Provide a name for navigation measures table name\\\", \\\"Navigation Table Name\\\", \\\"Navigation\\\", 740, 400);\\nif (navigationTableName == \\\"\\\") return;\\nstring buttonTextMeasureName = Interaction.InputBox(\\\"Name for your button text measure\\\", \\\"Button text measure name\\\", \\\"Button Text\\\", 740, 400);\\nif (buttonTextMeasureName == \\\"\\\") return;\\nstring buttonTextPattern = Interaction.InputBox(\\\"Provide a pattern for your button text\\\", \\\"Button text pattern (# = no. of problems)\\\", \\\"There are # data problems\\\", 740, 400);\\nif (buttonTextPattern == \\\"\\\") return;\\nstring buttonBackgroundMeasureName = Interaction.InputBox(\\\"Name your button background measure\\\", \\\"Button Background Measure\\\", \\\"Button Background\\\", 740, 400);\\nif (buttonBackgroundMeasureName == \\\"\\\") return;\\nstring buttonNavigationMeasureName = Interaction.InputBox(\\\"Name your button navigation measure\\\", \\\"Button Navigation Measure\\\", \\\"Button Navigation\\\", 740, 400);\\nif (buttonNavigationMeasureName == \\\"\\\") return;\\nstring thereAreDataProblemsMeasureName = Interaction.InputBox(\\\"Name your data problems flag measure\\\", \\\"Data problems Flag Measure\\\", \\\"There are Data Problems\\\", 740, 400);\\nif (thereAreDataProblemsMeasureName == \\\"\\\") return;\\nstring dataProblemsSheetName = Interaction.InputBox(\\\"Where are the data problems detail?\\\", \\\"Data problems Sheet\\\", \\\"Data Problems\\\", 740, 400);\\nif (dataProblemsSheetName == \\\"\\\") return;\\n// colors will be created if not present\\nstring buttonColorMeasureNameWhenVisible = Interaction.InputBox(\\\"What's the color measure name when the button is visible?\\\", \\\"Visible color measure name\\\", \\\"Warning Color\\\", 740, 400);\\nif(buttonColorMeasureNameWhenVisible == \\\"\\\") return;\\n\\nstring buttonColorMeasureValueWhenVisible = Interaction.InputBox(\\\"What's the color code of \\\" + buttonColorMeasureNameWhenVisible + \\\"?\\\", \\\"Visible color code\\\", \\\"#D64554\\\", 740, 400);\\nif(buttonColorMeasureValueWhenVisible == \\\"\\\") return;\\nbuttonColorMeasureValueWhenVisible = \\\"\\\\\"\\\" + buttonColorMeasureValueWhenVisible + \\\"\\\\\"\\\";\\n\\nstring buttonColorMeasureNameWhenInvisible = Interaction.InputBox(\\\"What's the color measure name when button is invisible?\\\", \\\"Invisible color measure name\\\", \\\"Report Background Color\\\", 740, 400);\\nif(buttonColorMeasureNameWhenInvisible == \\\"\\\") return;\\n\\nstring buttonColorMeasureValueWhenInvisible = Interaction.InputBox(\\\"What's the color code of \\\" + buttonColorMeasureNameWhenInvisible + \\\"?\\\", \\\"Invisible color measure name\\\", \\\"#FFFFFF\\\", 740, 400);\\nif(buttonColorMeasureValueWhenInvisible == \\\"\\\") return;\\nbuttonColorMeasureValueWhenInvisible = \\\"\\\\\"\\\" + buttonColorMeasureValueWhenInvisible + \\\"\\\\\"\\\";\\n\\n\\n// prepare array to iterate on new measure names \\nstring[] newMeasureNames = \\n    {\\n        buttonTextMeasureName,\\n        buttonBackgroundMeasureName,\\n        buttonNavigationMeasureName,\\n        thereAreDataProblemsMeasureName\\n        };\\n//check none of the new measure names already exist as such \\nforeach (string measureName in newMeasureNames)\\n{\\n    if (Model.AllMeasures.Any(Measure => Measure.Name == measureName))\\n    {\\n        Error(measureName + \\\" already exists!\\\");\\n        return;\\n    };\\n};\\nvar dataProblemsMeasure = Selected.Measure;\\nstring navigationTableExpression =\\n    \\\"FILTER({1},[Value] = 0)\\\";\\nvar navigationTable =\\n    Model.AddCalculatedTable(navigationTableName, navigationTableExpression);\\nnavigationTable.FormatDax();\\nnavigationTable.Description =\\n    \\\"Table to store the measures for the dynamic button that leads to the data problems sheet\\\";\\nnavigationTable.IsHidden = true;\\nif (!Model.AllMeasures.Any(Measure => Measure.Name == buttonColorMeasureNameWhenVisible))\\n{\\n    navigationTable.AddMeasure(buttonColorMeasureNameWhenVisible, buttonColorMeasureValueWhenVisible);\\n};\\nif (!Model.AllMeasures.Any(Measure => Measure.Name == buttonColorMeasureNameWhenInvisible))\\n{\\n    navigationTable.AddMeasure(buttonColorMeasureNameWhenInvisible, \\\"\\\\\"#FFFFFF00\\\\\"\\\");\\n};\\nstring thereAreDataProblemsMeasureExpression =\\n    \\\"[\\\" + dataProblemsMeasure.Name + \\\"]>0\\\";\\nvar thereAreDataProblemsMeasure =\\n    navigationTable.AddMeasure(\\n        thereAreDataProblemsMeasureName,\\n        thereAreDataProblemsMeasureExpression\\n    );\\nthereAreDataProblemsMeasure.FormatDax();\\nthereAreDataProblemsMeasure.Description = \\\"Boolean measure, if true, the button leading to data problems sheet should show (internal use only)\\\";\\nstring buttonBackgroundMeasureExpression =\\n    \\\"VAR colorCode = \\\" +\\n    \\\"    IF(\\\" +\\n    \\\"        [\\\" + thereAreDataProblemsMeasureName + \\\"],\\\" +\\n    \\\"        [\\\" + buttonColorMeasureNameWhenVisible + \\\"],\\\" +\\n    \\\"        [\\\" + buttonColorMeasureNameWhenInvisible + \\\"]\\\" +\\n    \\\"    )\\\" +\\n    \\\"RETURN \\\" +\\n    \\\"    FORMAT(colorCode,\\\\\"@\\\\\")\\\";\\nMeasure buttonBackgroundMeasure =\\n    navigationTable.AddMeasure(\\n        buttonBackgroundMeasureName,\\n        buttonBackgroundMeasureExpression\\n    );\\nbuttonBackgroundMeasure.FormatDax();\\nbuttonBackgroundMeasure.Description = \\\"Use this measure for conditional formatting of button background\\\";\\nbuttonBackgroundMeasure.SetAnnotation(annotationLabel, annotationValueBackground);\\nstring buttonNavigationMeasureExpression =\\n    \\\"IF(\\\" +\\n    \\\"    [\\\" + thereAreDataProblemsMeasureName + \\\"],\\\" +\\n    \\\"    \\\\\"\\\" + dataProblemsSheetName + \\\"\\\\\",\\\" +\\n    \\\"    \\\\\"\\\\\"\\\" +\\n    \\\")\\\";\\nMeasure buttonNavigationMeasure =\\n    navigationTable.AddMeasure(\\n        buttonNavigationMeasureName,\\n        buttonNavigationMeasureExpression\\n    );\\nbuttonNavigationMeasure.FormatDax();\\nbuttonNavigationMeasure.Description = \\\"Use this measure for conditional page navigation\\\";\\nbuttonNavigationMeasure.SetAnnotation(annotationLabel, annotationValueNavigation);\\nstring buttonTextMeasureExpression =\\n    \\\"IF(\\\" +\\n    \\\"    [\\\" + thereAreDataProblemsMeasureName + \\\"],\\\" +\\n    \\\"    SUBSTITUTE(\\\\\"\\\" + buttonTextPattern + \\\"\\\\\",\\\\\"#\\\\\",FORMAT([\\\" + dataProblemsMeasure.Name + \\\"],0)),\\\" +\\n    \\\"    \\\\\"\\\\\"\\\" +\\n    \\\")\\\";\\nvar buttonTextMeasure =\\n    navigationTable.AddMeasure(\\n        buttonTextMeasureName,\\n        buttonTextMeasureExpression\\n    );\\nbuttonTextMeasure.FormatDax();\\nbuttonTextMeasure.Description = \\\"Use this measure for dynamic button text\\\";\\nbuttonTextMeasure.SetAnnotation(annotationLabel, annotationValueText);\\n//dataProblemsMeasure.MoveTo(navigationTable);\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Data Problems Button",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n\\n// '2021-05-26 / B.Agullo / \\n// '2021-10-13 / B.Agullo / dynamic parameters for one-click operation\\n// '2022-10-18 / B.Agullo / Bug fixes\\n// by Bernat Agulló\\n// www.esbrina-ba.com\\n\\n// Instructions: \\n// select the measures that counts the number of \\\"data problems\\\" the model has and then run the script or as macro\\n// when adding macro select measure context for execution \\n\\n//\\n// ----- do not modify script below this line -----\\n//\\n\\n\\nif (Selected.Measures.Count != 1) {\\n    Error(\\\"Select one and only one measure\\\");\\n    return;\\n};\\n\\nstring navigationTableName = Interaction.InputBox(\\\"Provide a name for navigation measures table name\\\", \\\"Navigation Table Name\\\", \\\"Navigation\\\", 740, 400);\\nif(navigationTableName == \\\"\\\") return;\\n\\nif(Model.Tables.Any(Table => Table.Name == navigationTableName)) {\\n    Error(navigationTableName + \\\" already exists!\\\");\\n    return; \\n};\\n\\nstring buttonTextMeasureName = Interaction.InputBox(\\\"Name for your button text measure\\\", \\\"Button text measure name\\\", \\\"Button Text\\\", 740, 400);\\nif(buttonTextMeasureName == \\\"\\\") return;\\n\\nstring buttonTextPattern = Interaction.InputBox(\\\"Provide a pattern for your button text\\\", \\\"Button text pattern (# = no. of problems)\\\", \\\"There are # data problems\\\", 740, 400);\\nif(buttonTextPattern == \\\"\\\") return;\\n\\nstring buttonBackgroundMeasureName = Interaction.InputBox(\\\"Name your button background measure\\\", \\\"Button Background Measure\\\", \\\"Button Background\\\", 740, 400);\\nif(buttonBackgroundMeasureName == \\\"\\\") return;\\n\\nstring buttonNavigationMeasureName = Interaction.InputBox(\\\"Name your button navigation measure\\\", \\\"Button Navigation Measure\\\", \\\"Button Navigation\\\", 740, 400);\\nif(buttonNavigationMeasureName == \\\"\\\") return;\\n\\nstring thereAreDataProblemsMeasureName = Interaction.InputBox(\\\"Name your data problems flag measure\\\", \\\"Data problems Flag Measure\\\", \\\"There are Data Problems\\\", 740, 400);\\nif(thereAreDataProblemsMeasureName == \\\"\\\") return;\\n\\nstring dataProblemsSheetName = Interaction.InputBox(\\\"Where are the data problems detail?\\\", \\\"Data problems Sheet\\\", \\\"Data Problems\\\", 740, 400);\\nif(dataProblemsSheetName == \\\"\\\") return;\\n\\n\\n// colors will be created if not present\\nstring buttonColorMeasureNameWhenVisible = Interaction.InputBox(\\\"What's the color measure name when the button is visible?\\\", \\\"Visible color measure name\\\", \\\"Warning Color\\\", 740, 400);\\nif(buttonColorMeasureNameWhenVisible == \\\"\\\") return;\\n\\nstring buttonColorMeasureValueWhenVisible = Interaction.InputBox(\\\"What's the color code of \\\" + buttonColorMeasureNameWhenVisible + \\\"?\\\", \\\"Visible color code\\\", \\\"#D64554\\\", 740, 400);\\nif(buttonColorMeasureValueWhenVisible == \\\"\\\") return;\\nbuttonColorMeasureValueWhenVisible = \\\"\\\\\"\\\" + buttonColorMeasureValueWhenVisible + \\\"\\\\\"\\\";\\n\\nstring buttonColorMeasureNameWhenInvisible = Interaction.InputBox(\\\"What's the color measure name when button is invisible?\\\", \\\"Invisible color measure name\\\", \\\"Report Background Color\\\", 740, 400);\\nif(buttonColorMeasureNameWhenInvisible == \\\"\\\") return;\\n\\nstring buttonColorMeasureValueWhenInvisible = Interaction.InputBox(\\\"What's the color code of \\\" + buttonColorMeasureNameWhenInvisible + \\\"?\\\", \\\"Invisible color measure name\\\", \\\"#FFFFFF\\\", 740, 400);\\nif(buttonColorMeasureValueWhenInvisible == \\\"\\\") return;\\nbuttonColorMeasureValueWhenInvisible = \\\"\\\\\"\\\" + buttonColorMeasureValueWhenInvisible + \\\"\\\\\"\\\";\\n\\n\\n// prepare array to iterate on new measure names \\nstring[] newMeasureNames = \\n    {\\n        buttonTextMeasureName,\\n        buttonBackgroundMeasureName,\\n        buttonNavigationMeasureName,\\n        thereAreDataProblemsMeasureName\\n    };\\n\\n\\n// check none of the new measure names already exist as such \\nforeach(string measureName in newMeasureNames) {\\n    if(Model.AllMeasures.Any(Measure => Measure.Name == measureName)) {\\n        Error(measureName + \\\" already exists!\\\"); \\n        return;\\n    };\\n};\\n    \\nvar dataProblemsMeasure = Selected.Measure; \\n\\nstring navigationTableExpression = \\n    \\\"FILTER({1},[Value] = 0)\\\";\\n\\nvar navigationTable = \\n    Model.AddCalculatedTable(navigationTableName,navigationTableExpression);\\n    \\nnavigationTable.FormatDax(); \\nnavigationTable.Description = \\n    \\\"Table to store the measures for the dynamic button that leads to the data problems sheet\\\";\\n\\nnavigationTable.IsHidden = true;     \\n\\nif(!Model.AllMeasures.Any(Measure => Measure.Name == buttonColorMeasureNameWhenVisible)) {\\n    navigationTable.AddMeasure(buttonColorMeasureNameWhenVisible,buttonColorMeasureValueWhenVisible);\\n};\\n\\nif(!Model.AllMeasures.Any(Measure => Measure.Name == buttonColorMeasureNameWhenInvisible)) {\\n    navigationTable.AddMeasure(buttonColorMeasureNameWhenInvisible,\\\"\\\\\"#FFFFFF00\\\\\"\\\");\\n};\\n\\nstring thereAreDataProblemsMeasureExpression = \\n    \\\"[\\\" + dataProblemsMeasure.Name + \\\"]>0\\\";\\n\\nvar thereAreDataProblemsMeasure = \\n    navigationTable.AddMeasure(\\n        thereAreDataProblemsMeasureName,\\n        thereAreDataProblemsMeasureExpression\\n    );\\n\\nthereAreDataProblemsMeasure.FormatDax(); \\nthereAreDataProblemsMeasure.Description = \\\"Boolean measure, if true, the button leading to data problems sheet should show (internal use only)\\\" ;\\n \\nstring buttonBackgroundMeasureExpression = \\n    \\\"VAR colorCode = \\\" + \\n    \\\"    IF(\\\" + \\n    \\\"        [\\\" + thereAreDataProblemsMeasureName + \\\"],\\\" + \\n    \\\"        [\\\" + buttonColorMeasureNameWhenVisible + \\\"],\\\" + \\n    \\\"        [\\\" + buttonColorMeasureNameWhenInvisible + \\\"]\\\" + \\n    \\\"    )\\\" + \\n    \\\"RETURN \\\" + \\n    \\\"    FORMAT(colorCode,\\\\\"@\\\\\")\\\";\\n    \\nvar buttonBackgroundMeasure = \\n    navigationTable.AddMeasure(\\n        buttonBackgroundMeasureName,\\n        buttonBackgroundMeasureExpression\\n    );\\n    \\nbuttonBackgroundMeasure.FormatDax(); \\nbuttonBackgroundMeasure.Description = \\\"Use this measure for conditional formatting of button background\\\";  \\n\\nstring buttonNavigationMeasureExpression = \\n    \\\"IF(\\\" + \\n    \\\"    [\\\" + thereAreDataProblemsMeasureName + \\\"],\\\" + \\n    \\\"    \\\\\"\\\" + dataProblemsSheetName + \\\"\\\\\",\\\" + \\n    \\\"    \\\\\"\\\\\"\\\" + \\n    \\\")\\\";\\n\\nvar buttonNavigationMeasure = \\n    navigationTable.AddMeasure(\\n        buttonNavigationMeasureName,\\n        buttonNavigationMeasureExpression\\n    );\\n    \\nbuttonNavigationMeasure.FormatDax(); \\nbuttonNavigationMeasure.Description = \\\"Use this measure for conditional page navigation\\\";  \\n\\nstring buttonTextMeasureExpression = \\n    \\\"IF(\\\" + \\n    \\\"    [\\\" + thereAreDataProblemsMeasureName + \\\"],\\\" + \\n    \\\"    SUBSTITUTE(\\\\\"\\\" + buttonTextPattern + \\\"\\\\\",\\\\\"#\\\\\",FORMAT([\\\" + dataProblemsMeasure.Name + \\\"],0)),\\\" + \\n    \\\"    \\\\\"\\\\\"\\\" + \\n    \\\")\\\";    \\n    \\nvar buttonTextMeasure = \\n    navigationTable.AddMeasure(\\n        buttonTextMeasureName,\\n        buttonTextMeasureExpression\\n    );\\n    \\nbuttonTextMeasure.FormatDax(); \\nbuttonTextMeasure.Description = \\\"Use this measure for dynamic button text\\\";  \\n\\n//dataProblemsMeasure.MoveTo(navigationTable);\\n    \\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Duplicate Date Table",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\nusing Microsoft.VisualBasic;\\nstring annotationLabel = \\\"createSecondaryDateTable\\\";\\nstring annotationValue1 = \\\"Main\\\";\\nstring annotationValue2 = \\\"Secondary\\\"; \\nTable dateTable = Fx.GetTablesWithAnnotation(Model.Tables, annotationLabel, annotationValue1); \\nTable dateTable2 = Fx.GetTablesWithAnnotation(Model.Tables, annotationLabel, annotationValue2);\\nif (dateTable == null || dateTable2 == null)\\n{\\n    IEnumerable<Table> dateTables = Fx.GetDateTables(Model);\\n    if (dateTables == null) return;\\n    if (dateTables.Count() != 1)\\n    {\\n        dateTable = SelectTable(dateTables, dateTables.First(), \\\"Select Date table to duplicate\\\");\\n        if (dateTable == null) return;\\n    }\\n    else\\n    {\\n        dateTable = dateTables.First();\\n    }\\n    string dateTable2Name = Fx.GetNameFromUser(\\\"Secondary Date Table Name\\\", \\\"Name\\\", dateTable.Name + \\\" comparison\\\");\\n    dateTable2 = Model.AddCalculatedTable(name: dateTable2Name, expression: dateTable.DaxObjectFullName);\\n    dateTable2.DataCategory = dateTable.DataCategory;\\n    var te2 = dateTable2.Columns.Count == 0;\\n    for (int i = 0; i < dateTable2.Columns.Count(); i++)\\n    {\\n        Column c = dateTable.Columns[i];\\n        Column c2 = te2 ? dateTable2.AddCalculatedColumn(c.Name, String.Format(\\\"[Value{0}]\\\", i)) : dateTable2.Columns[i];\\n    }\\n    dateTable.SetAnnotation(annotationLabel, annotationValue1);\\n    dateTable2.SetAnnotation(annotationLabel, annotationValue2);\\n    Info(\\\"Save changes back to the model, recalculate and run again\\\");\\n}\\nelse\\n{\\n    for (int i = 0; i < dateTable2.Columns.Count(); i++)\\n    {\\n        Column c = dateTable.Columns[i];\\n        Column c2 = dateTable2.Columns[i];\\n        c2.IsKey = c.IsKey;\\n        c2.SortByColumn = c.SortByColumn;\\n    }\\n    IEnumerable<SingleColumnRelationship> dateTableRelatioships =\\n        Model.Relationships.Where(r => r.FromTable.Name == dateTable.Name\\n        || r.ToTable.Name == dateTable.Name);\\n    foreach (SingleColumnRelationship r in dateTableRelatioships)\\n    {\\n        SingleColumnRelationship newR = Model.AddRelationship();\\n        if (r.FromTable.Name == dateTable.Name)\\n        {\\n            newR.FromColumn = dateTable2.Columns[r.FromColumn.Name];\\n            newR.ToColumn = r.ToColumn;\\n        }else\\n        {\\n            newR.ToColumn = dateTable2.Columns[r.ToColumn.Name];\\n            newR.FromColumn = r.FromColumn;\\n        }\\n        newR.FromCardinality = r.FromCardinality;\\n        newR.ToCardinality = r.ToCardinality;\\n        newR.CrossFilteringBehavior = r.CrossFilteringBehavior;\\n        newR.IsActive = r.IsActive; \\n    }\\n    Info(\\\"Metadata updated\\\");\\n}\\n\\npublic static class Fx\\n{\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        IEnumerable<Table> dateTables = null as IEnumerable<Table>;\\n        if (model.Tables.Any(t => t.DataCategory == \\\"Time\\\" && t.Columns.Any(c => c.IsKey == true)))\\n        {\\n            dateTables = model.Tables.Where(t => t.DataCategory == \\\"Time\\\" && t.Columns.Any(c => c.IsKey == true && c.DataType == DataType.DateTime));\\n        }\\n        else\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        if(matchTables == null)\\n        {\\n            return null;\\n        }\\n        else\\n        {\\n            return matchTables.First();\\n        }\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table,bool> lambda)\\n    {\\n        if (tables.Any(t => lambda(t)))\\n        {\\n            return tables.Where(t => lambda(t));\\n        }\\n        else\\n        {\\n            return null as IEnumerable<Table>; \\n        }\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column,bool> lambda, bool returnAllIfNoneFound = true) \\n    {\\n        if (columns.Any(c => lambda(c)))\\n        {\\n            return columns.Where(c => lambda(c));\\n        }\\n        else\\n        {\\n            if(returnAllIfNoneFound)\\n            {\\n                return columns;\\n            }\\n            else\\n            {\\n                return null as IEnumerable<Column>;\\n            }\\n        }\\n    }\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        if(!model.Tables.Any(t => t.Name == tableName))\\n        {\\n            return model.AddCalculatedTable(tableName, tableExpression);\\n        }\\n        else\\n        {\\n            return model.Tables.Where(t => t.Name == tableName).First();\\n        }\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title =\\\"\\\", string DefaultResponse = \\\"\\\")\\n    {    \\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList)\\n    {\\n        Func<IList<string>, string, string> SelectString = (IList<string> options, string title) =>\\n        {\\n            var form = new Form();\\n            form.Text = title;\\n            var buttonPanel = new Panel();\\n            buttonPanel.Dock = DockStyle.Bottom;\\n            buttonPanel.Height = 30;\\n            var okButton = new Button() { DialogResult = DialogResult.OK, Text = \\\"OK\\\" };\\n            var cancelButton = new Button() { DialogResult = DialogResult.Cancel, Text = \\\"Cancel\\\", Left = 80 };\\n            var listbox = new ListBox();\\n            listbox.Dock = DockStyle.Fill;\\n            listbox.Items.AddRange(options.ToArray());\\n            listbox.SelectedItem = options[0];\\n            form.Controls.Add(listbox);\\n            form.Controls.Add(buttonPanel);\\n            buttonPanel.Controls.Add(okButton);\\n            buttonPanel.Controls.Add(cancelButton);\\n            var result = form.ShowDialog();\\n            if (result == DialogResult.Cancel) return null;\\n            return listbox.SelectedItem.ToString();\\n        };\\n        //let the user select the name of the macro to copy\\n        String select = SelectString(OptionList, \\\"Choose a macro\\\");\\n        //check that indeed one macro was selected\\n        if (select == null)\\n        {\\n            Info(\\\"You cancelled!\\\");\\n        }\\n        return select;\\n    }\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Dynamic Header Field Parameter",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\nusing System.Windows.Forms;\\n\\n\\n/* '2023-01-26 / B.Agullo / creates a field parameter of measures filtered by calc group and values of a column with a name defined by a measure evaluated in the filtered value and calc item  */\\n\\n/* DYNAMIC HEADER FIELD PARAMETER SCRIPT */ \\n\\n/* see https://www.esbrina-ba.com/dynamic-headers-in-power-bi-sort-of/ */\\n/* select measures and execute, you will need to run it twice */\\n/* first time to create aux calc group, second time to actually create measuree*/\\n/* remove aux calc group before going to production, do the right thing */\\n\\nstring auxCgTag = \\\"@AgulloBernat\\\";\\nstring auxCgTagValue = \\\"CG to extract format strings\\\";\\n\\nstring auxCalcGroupName = \\\"DELETE AUX CALC GROUP\\\";\\nstring auxCalcItemName = \\\"Get Format String\\\";\\n\\nstring baseMeasureAnnotationName = \\\"Base Measure\\\";\\nstring calcItemAnnotationName = \\\"Calc Item\\\";\\nstring calcItemSortOrderName = \\\"Sort Order\\\";\\nstring calcItemSortOrderValue = String.Empty;\\n\\nstring filterValueAnnotationName = String.Empty;\\nstring dynamicNameAnnotationName = \\\"Dynamic Name\\\";\\n\\n\\nstring scriptAnnotationName = \\\"Script\\\";\\nstring scriptAnnotationValue = \\\"Create Measures with a Calculation Group \\\" + DateTime.Now.ToString(\\\"yyyyMMddHHmmss\\\") ;\\n\\nbool generateFieldParameter;\\n\\nDialogResult dialogResult = MessageBox.Show(\\\"Generate Field Parameter?\\\", \\\"Field Parameter\\\", MessageBoxButtons.YesNo);\\ngenerateFieldParameter = (dialogResult == DialogResult.Yes);\\n\\n/*check if any measures are selected*/\\nif (Selected.Measures.Count == 0)\\n{\\n    Error(\\\"No measures selected\\\");\\n    return;\\n}\\n\\n/*find any regular CGs (excluding the one we might have created)*/\\nvar regularCGs = Model.Tables.Where(\\n    x => x.ObjectType == ObjectType.CalculationGroupTable\\n    & x.GetAnnotation(auxCgTag) != auxCgTagValue);\\n\\nif (regularCGs.Count() == 0)\\n{\\n    Error(\\\"No Calculation Groups Found\\\");\\n    return;\\n};\\n\\n\\n\\n\\n//the lambda expression will be avaluated for all calc groups to find a matching calc group\\n//CalculationGroupTable auxCg = Fx.SelectCalculationGroup(model:Model,lambdaExpression:lambda,selectFirst:true, showErrorIfNoTablesFound:false);\\n\\nbool calcGroupWasCreated = false;\\n\\n//the calc group will only be created if not found, and when so the boolean will point to it\\nCalculationGroupTable auxCg = Fx.AddCalculationGroupExt(model: Model, calcGroupWasCreated: out calcGroupWasCreated, \\n    defaultName: auxCalcGroupName, customCalcGroupName: false, annotationName: auxCgTag, annotationValue: auxCgTagValue);\\n\\nif (calcGroupWasCreated)\\n{\\n    CalculationItem cItem = Fx.AddCalculationItemExt(cg: auxCg, calcItemName: auxCalcItemName, valueExpression: \\\"SELECTEDMEASUREFORMATSTRING()\\\");\\n    auxCg.IsHidden = true; \\n    \\n    Info(\\\"Save changes to the model, recalculate the model, and launch the script again.\\\");\\n    return;\\n}\\n\\n//to avoid showing the aux calc group in the list\\nFunc<Table, bool> lambda = (x) => x.GetAnnotation(auxCgTag) != auxCgTagValue;\\n\\nCalculationGroupTable regularCg = Fx.SelectCalculationGroup(model: Model, lambdaExpression: lambda);\\nif (regularCg == null) return;\\n\\n\\nTable filterTable = Fx.SelectTableExt(model: Model, excludeCalcGroups: true, label:\\\"Select table of filter field\\\",showErrorIfNoSelection:true);\\nif(filterTable == null) return;\\nColumn filterColumn = SelectColumn(filterTable,label:\\\"Select filter Field\\\");\\nif (filterColumn == null) return;\\n\\nfilterValueAnnotationName = filterColumn.Name; \\n\\nString filterQuery = String.Format(\\\"EVALUATE DISTINCT({0})\\\", filterColumn.DaxObjectFullName);\\n\\nList<String> filterValues = new List<String>();\\n\\nusing (var filterReader = Model.Database.ExecuteReader(filterQuery))\\n{\\n\\n    while (filterReader.Read())\\n    {\\n\\n        filterValues.Add(filterReader.GetValue(0).ToString());\\n    }\\n}\\n\\nstring name = String.Empty;\\nif (generateFieldParameter)\\n{\\n    name = Interaction.InputBox(\\\"Provide a name for the field parameter\\\", \\\"Field Parameter\\\", regularCg.Name + \\\" Measures\\\", 740, 400);\\n    if (name == \\\"\\\") { Error(\\\"Execution Aborted\\\"); return; };\\n};\\n\\nMeasure dynamicNameMeasure = SelectMeasure(label: \\\"Select measure for dynamic name, cancel if none\\\");\\n\\n\\n/*iterates through each selected measure*/\\nforeach (Measure m in Selected.Measures)\\n{\\n    /*check that base measure has a proper format string*/\\n    if (m.FormatString == \\\"\\\")\\n    {\\n        Error(\\\"Define FormatString for \\\" + m.Name + \\\" and try again\\\");\\n        return;\\n    };\\n\\n    /*prepares a displayfolder to store all new measures*/\\n    string displayFolderName = m.Name + \\\" Measures\\\";\\n\\n    /*iterates thorough all calculation items of the selected calc group*/\\n    foreach (CalculationItem calcItem in regularCg.CalculationItems)\\n    {\\n\\n        string measureNamePrefix = string.Concat(Enumerable.Repeat(\\\"\\u200B\\\", calcItem.Ordinal));\\n\\n        foreach (string filterValue in filterValues)\\n        {\\n            \\n            \\n            \\n            /*measure name*/\\n            string measureName = measureName = m.Name + \\\" \\\" + calcItem.Name + \\\" \\\" + filterValue;\\n\\n            string dynamicMeasureName = String.Empty;  \\n\\n            if (dynamicNameMeasure == null)\\n            {\\n                dynamicMeasureName = measureName;\\n            }\\n            else\\n            {\\n\\n                string measureNameQuery = String.Empty;\\n\\n                if (filterColumn.DataType == DataType.String)\\n                {\\n\\n                    measureNameQuery =\\n                        String.Format(\\\"EVALUATE {{CALCULATE({0},{1}=\\\\\"{2}\\\\\",{3}=\\\\\"{4}\\\\\") & \\\\\"\\\\\"}}\\\", \\n                            dynamicNameMeasure.DaxObjectFullName, \\n                            filterColumn.DaxObjectFullName, \\n                            filterValue,\\n                            regularCg.Columns[0].DaxObjectFullName,\\n                            calcItem.Name);\\n                }\\n                else\\n                {\\n                    measureNameQuery =\\n                        String.Format(\\\"EVALUATE {{CALCULATE({0},{1}={2},{3}=\\\\\"{4}\\\\\") & \\\\\"\\\\\"}}\\\",\\n                            dynamicNameMeasure.DaxObjectFullName,\\n                            filterColumn.DaxObjectFullName,\\n                            filterValue,\\n                            regularCg.Columns[0].DaxObjectFullName,\\n                            calcItem.Name);\\n                }\\n\\n\\n               \\n                using (var reader = Model.Database.ExecuteReader(measureNameQuery))\\n                {\\n                    while (reader.Read())\\n                    {\\n                        dynamicMeasureName = reader.GetString(0).ToString();\\n\\n                    }\\n                }\\n\\n                dynamicMeasureName =  m.Name + \\\" \\\" +  measureNamePrefix + dynamicMeasureName;\\n\\n\\n            }\\n\\n            \\n\\n            //only if the measure is not yet there (think of reruns)\\n            if (!Model.AllMeasures.Any(x => x.Name == measureName))\\n            {\\n\\n                /*prepares a query to calculate the resulting format when applying the calculation item on the measure*/\\n                string query = string.Format(\\n                    \\\"EVALUATE {{CALCULATE({0},{1},{2})}}\\\",\\n                    m.DaxObjectFullName,\\n                    string.Format(\\n                        \\\"{0}=\\\\\"{1}\\\\\"\\\",\\n                        regularCg.Columns[0].DaxObjectFullName,\\n                        calcItem.Name),\\n                    string.Format(\\n                        \\\"{0}=\\\\\"{1}\\\\\"\\\",\\n                        auxCg.Columns[0].DaxObjectFullName,\\n                        auxCalcItemName)\\n                );\\n\\n                /*executes the query*/\\n                using (var reader = Model.Database.ExecuteReader(query))\\n                {\\n                    // resultset should contain just one row, with the format string\\n                    while (reader.Read())\\n                    {\\n\\n\\n                        /*retrive the formatstring from the query*/\\n                        string formatString = reader.GetValue(0).ToString();\\n\\n                       \\n\\n\\n\\n\\n                        /*build the expression of the measure*/\\n                        string measureExpression = String.Empty;\\n\\n                        if(filterColumn.DataType == DataType.String)\\n                        {\\n                            measureExpression = string.Format(\\n                                \\\"CALCULATE({0},{1}=\\\\\"{2}\\\\\",KEEPFILTERS({3}=\\\\\"{4}\\\\\"))\\\",\\n                                m.DaxObjectName,\\n                                regularCg.Columns[0].DaxObjectFullName,\\n                                calcItem.Name,\\n                                filterColumn.DaxObjectFullName,\\n                                filterValue\\n                            );\\n                        }\\n                        else\\n                        {\\n                            measureExpression = string.Format(\\n                                \\\"CALCULATE({0},{1}=\\\\\"{2}\\\\\",KEEPFILTERS({3}={4}))\\\",\\n                                m.DaxObjectName,\\n                                regularCg.Columns[0].DaxObjectFullName,\\n                                calcItem.Name,\\n                                filterColumn.DaxObjectFullName,\\n                                filterValue\\n                            );\\n                        }\\n\\n                            \\n                            \\n                            \\n\\n\\n\\n                        /*actually build the measure*/\\n                        Measure newMeasure =\\n                            m.Table.AddMeasure(\\n                                name: measureName,\\n                                expression: measureExpression);\\n\\n\\n                        /*the all important format string!*/\\n                        newMeasure.FormatString = formatString;\\n\\n                        /*final polish*/\\n                        newMeasure.DisplayFolder = displayFolderName;\\n                        newMeasure.FormatDax();\\n\\n                        /*add annotations for the creation of the field parameter*/\\n                        newMeasure.SetAnnotation(baseMeasureAnnotationName, m.Name);\\n                        newMeasure.SetAnnotation(calcItemAnnotationName, calcItem.Name);\\n                        newMeasure.SetAnnotation(scriptAnnotationName, scriptAnnotationValue);\\n                        newMeasure.SetAnnotation(calcItemSortOrderName, calcItem.Ordinal.ToString(\\\"000\\\"));\\n                        newMeasure.SetAnnotation(filterValueAnnotationName, filterValue);\\n                        newMeasure.SetAnnotation(dynamicNameAnnotationName, dynamicMeasureName);\\n\\n\\n                    }\\n                }\\n            }\\n        }\\n            \\n        \\n    }\\n}\\n\\n\\nif (!generateFieldParameter)\\n{\\n    //end of execution\\n    return;\\n};\\n\\n\\n// Before running the script, select the measures or columns that you\\n// would like to use as field parameters (hold down CTRL to select multiple\\n// objects). Also, you may change the name of the field parameter table\\n// below. NOTE: If used against Power BI Desktop, you must enable unsupported\\n// features under File > Preferences (TE2) or Tools > Preferences (TE3).\\n\\n\\nif (Selected.Columns.Count == 0 && Selected.Measures.Count == 0) throw new Exception(\\\"No columns or measures selected!\\\");\\n\\n// Construct the DAX for the calculated table based on the measures created previously by the script\\nvar objects = Model.AllMeasures\\n    .Where(x => x.GetAnnotation(scriptAnnotationName) == scriptAnnotationValue)\\n    .OrderBy(x => x.GetAnnotation(baseMeasureAnnotationName) + x.GetAnnotation(calcItemSortOrderName));\\n\\nvar dax = \\\"{\\n    \\\" + string.Join(\\\",\\n    \\\", objects.Select((c, i) => string.Format(\\\"(\\\\\"{6}\\\\\", NAMEOF('{1}'[{0}]), {2},\\\\\"{3}\\\\\",\\\\\"{4}\\\\\",\\\\\"{5}\\\\\")\\\",\\n    c.Name, c.Table.Name, i,\\n    Model.Tables[c.Table.Name].Measures[c.Name].GetAnnotation(baseMeasureAnnotationName),\\n    Model.Tables[c.Table.Name].Measures[c.Name].GetAnnotation(calcItemAnnotationName),\\n    Model.Tables[c.Table.Name].Measures[c.Name].GetAnnotation(filterValueAnnotationName),\\n    Model.Tables[c.Table.Name].Measures[c.Name].GetAnnotation(dynamicNameAnnotationName)\\n    ))) + \\\"\\n}\\\";\\n\\n// Add the calculated table to the model:\\nvar table = Model.AddCalculatedTable(name, dax);\\n\\n// In TE2 columns are not created automatically from a DAX expression, so \\n// we will have to add them manually:\\nvar te2 = table.Columns.Count == 0;\\nvar nameColumn = te2 ? table.AddCalculatedTableColumn(name, \\\"[Value1]\\\") : table.Columns[\\\"Value1\\\"] as CalculatedTableColumn;\\nvar fieldColumn = te2 ? table.AddCalculatedTableColumn(name + \\\" Fields\\\", \\\"[Value2]\\\") : table.Columns[\\\"Value2\\\"] as CalculatedTableColumn;\\nvar orderColumn = te2 ? table.AddCalculatedTableColumn(name + \\\" Order\\\", \\\"[Value3]\\\") : table.Columns[\\\"Value3\\\"] as CalculatedTableColumn;\\n\\nif (!te2)\\n{\\n    // Rename the columns that were added automatically in TE3:\\n    nameColumn.IsNameInferred = false;\\n    nameColumn.Name = name;\\n    fieldColumn.IsNameInferred = false;\\n    fieldColumn.Name = name + \\\" Fields\\\";\\n    orderColumn.IsNameInferred = false;\\n    orderColumn.Name = name + \\\" Order\\\";\\n}\\n// Set remaining properties for field parameters to work\\n// See: https://twitter.com/markbdi/status/1526558841172893696\\nnameColumn.SortByColumn = orderColumn;\\nnameColumn.GroupByColumns.Add(fieldColumn);\\nfieldColumn.SortByColumn = orderColumn;\\nfieldColumn.SetExtendedProperty(\\\"ParameterMetadata\\\", \\\"{\\\\\"version\\\\\":3,\\\\\"kind\\\\\":2}\\\", ExtendedPropertyType.Json);\\nfieldColumn.IsHidden = true;\\norderColumn.IsHidden = true;\\n\\n\\npublic static class Fx\\n{\\n    \\n\\n\\n\\n    //in TE2 (at least up to 2.17.2) any method that accesses or modifies the model needs a reference to the model \\n    //the following is an example method where you can build extra logic\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression) \\n    { \\n        return model.AddCalculatedTable(name:tableName,expression:tableExpression);\\n    }\\n\\n    public static Table SelectTableExt(Model model, string possibleName = null, string annotationName = null, string annotationValue = null, \\n        Func<Table,bool>  lambdaExpression = null, string label = \\\"Select Table\\\", bool skipDialogIfSingleMatch = true, bool showOnlyMatchingTables = true,\\n        IEnumerable<Table> candidateTables = null, bool showErrorIfNoTablesFound = false, string errorMessage = \\\"No tables found\\\", bool selectFirst = false,\\n        bool showErrorIfNoSelection = true, string noSelectionErrorMessage = \\\"No table was selected\\\", bool excludeCalcGroups = false,bool returnNullIfNoTablesFound = false)\\n    {\\n\\n        Table table = null as Table;\\n\\n        if (lambdaExpression == null)\\n        {\\n            if (possibleName != null) { \\n                lambdaExpression = (t) => t.Name == possibleName;\\n            } else if(annotationName!= null && annotationValue != null)\\n            {\\n                lambdaExpression = (t) => t.GetAnnotation(annotationName) == annotationValue;\\n            }\\n            else\\n            {\\n                lambdaExpression = (t) => true; //no filtering\\n            }\\n        }\\n\\n        //use candidateTables if passed as argument\\n        IEnumerable<Table> tables = null as IEnumerable<Table>;\\n\\n        if(candidateTables != null)\\n        {\\n            tables = candidateTables;\\n        }\\n        else\\n        {\\n            tables = model.Tables;\\n        }\\n\\n        if(lambdaExpression != null)\\n        {\\n            tables = tables.Where(lambdaExpression);\\n        }\\n\\n        if (excludeCalcGroups)\\n        {\\n            tables = tables.Where(t => t.ObjectType != ObjectType.CalculationGroupTable);\\n        }\\n\\n        //none found, let the user choose from all tables\\n        if (tables.Count() == 0)\\n        {\\n\\n            if (returnNullIfNoTablesFound)\\n            {\\n                if (showErrorIfNoTablesFound) Error(errorMessage);\\n                return table;\\n            } \\n            else\\n            {\\n                \\n                table =  SelectTable(tables: model.Tables, label: label);\\n            }\\n            \\n        }\\n        else if (tables.Count() == 1 && !skipDialogIfSingleMatch)\\n        {\\n            \\n            table = SelectTable(tables: model.Tables, preselect: tables.First(), label: label);\\n        }\\n        else if (tables.Count() == 1 && skipDialogIfSingleMatch)\\n        {\\n            table = tables.First();\\n        } \\n        else if (tables.Count() > 1) \\n            \\n        {\\n            if (selectFirst)\\n            {\\n                table = tables.First();\\n            }\\n            else if (showOnlyMatchingTables)\\n            {\\n                \\n                table = SelectTable(tables: tables, preselect: tables.First(), label: label);\\n            }\\n            else\\n            {\\n               \\n                table = SelectTable(tables: model.Tables, preselect: tables.First(), label: label);\\n            }\\n            \\n        }\\n        else\\n        {\\n            Error(@\\\"Unexpected logic in \\\"\\\"SelectTableExt\\\"\\\"\\\");\\n            return null;\\n        }\\n\\n        if(showErrorIfNoSelection && table == null)\\n        {\\n            Error(noSelectionErrorMessage);\\n        }\\n\\n        return table;\\n\\n    }\\n\\n\\n    public static CalculationGroupTable SelectCalculationGroup(Model model, string possibleName = null, string annotationName = null, string annotationValue = null,\\n        Func<Table, bool> lambdaExpression = null, string label = \\\"Select Table\\\", bool skipDialogIfSingleMatch = true, bool showOnlyMatchingTables = true,\\n        bool showErrorIfNoTablesFound = true, string errorMessage = \\\"No calculation groups found\\\",bool selectFirst = false, \\n        bool showErrorIfNoSelection = true, string noSelectionErrorMessage = \\\"No calculation group was selected\\\", bool returnNullIfNoTablesFound = false)\\n    {\\n\\n        CalculationGroupTable calculationGroupTable = null as CalculationGroupTable;\\n        \\n        Func<Table, bool> lambda = (x) => x.ObjectType == ObjectType.CalculationGroupTable;\\n        if (!model.Tables.Any(lambda)) return calculationGroupTable;\\n\\n        IEnumerable<Table> tables = model.Tables.Where(lambda);\\n\\n        Table table = Fx.SelectTableExt(\\n            model:model,\\n            possibleName:possibleName,\\n            annotationName:annotationName,\\n            annotationValue:annotationValue,\\n            lambdaExpression:lambdaExpression,\\n            label:label,\\n            skipDialogIfSingleMatch:skipDialogIfSingleMatch,\\n            showOnlyMatchingTables:showOnlyMatchingTables,\\n            showErrorIfNoTablesFound:showErrorIfNoTablesFound,\\n            errorMessage:errorMessage, \\n            selectFirst:selectFirst,\\n            showErrorIfNoSelection:showErrorIfNoSelection,\\n            noSelectionErrorMessage:noSelectionErrorMessage, \\n            returnNullIfNoTablesFound:returnNullIfNoTablesFound, \\n            candidateTables:tables);\\n\\n        if(table == null) return calculationGroupTable;\\n\\n        calculationGroupTable = table as CalculationGroupTable;\\n\\n        return calculationGroupTable;\\n\\n    }\\n\\n    public static CalculationGroupTable AddCalculationGroupExt(Model model, out bool calcGroupWasCreated, string defaultName = \\\"New Calculation Group\\\", \\n        string annotationName = null, string annotationValue = null, bool createOnlyIfNotFound = true, \\n        string prompt = \\\"Name\\\", string Title = \\\"Provide a name for the Calculation Group\\\", bool customCalcGroupName = true)\\n    {\\n        \\n        Func<Table,bool> lambda = null as Func<Table,bool>;\\n        CalculationGroupTable cg = null as CalculationGroupTable;\\n        calcGroupWasCreated = false;\\n        string calcGroupName = String.Empty;\\n\\n        if (createOnlyIfNotFound)\\n        {\\n\\n            if (annotationName == null && annotationValue == null)\\n            {\\n\\n                if (customCalcGroupName)\\n                {\\n                    calcGroupName = Interaction.InputBox(Prompt: \\\"Name\\\", Title: \\\"Provide a name for the Calculation Group\\\");\\n                }\\n                else\\n                {\\n                    calcGroupName = defaultName;\\n                }\\n\\n                cg = Fx.SelectCalculationGroup(model: model, possibleName: calcGroupName, showErrorIfNoTablesFound: false, selectFirst: true);\\n\\n            }\\n            else\\n            {\\n                cg = Fx.SelectCalculationGroup(model: model, \\n                    showErrorIfNoTablesFound: false, \\n                    annotationName: annotationName, \\n                    annotationValue: annotationValue, \\n                    returnNullIfNoTablesFound: true);\\n            }\\n\\n            if (cg != null) return cg;\\n        }\\n        \\n        if (calcGroupName == String.Empty)\\n        {\\n            if (customCalcGroupName)\\n            {\\n                calcGroupName = Interaction.InputBox(Prompt: \\\"Name\\\", Title: \\\"Provide a name for the Calculation Group\\\");\\n            }\\n            else\\n            {\\n                calcGroupName = defaultName;\\n            }\\n        }\\n\\n        cg = model.AddCalculationGroup(name: calcGroupName);\\n\\n        if (annotationName != null && annotationValue != null)\\n        {\\n            cg.SetAnnotation(annotationName,annotationValue);\\n        }\\n\\n        calcGroupWasCreated = true;\\n\\n        return cg;\\n\\n    }\\n\\n    public static CalculationItem AddCalculationItemExt(CalculationGroupTable cg, string calcItemName, string valueExpression = \\\"SELECTEDMEASURE()\\\",\\n        string formatStringExpression = \\\"\\\", bool createOnlyIfNotFound = true, bool rewriteIfFound = false)\\n    {\\n\\n        CalculationItem calcItem = null as CalculationItem;\\n\\n        Func<CalculationItem, bool> lambda = (ci) => ci.Name == calcItemName;\\n\\n        if(createOnlyIfNotFound)\\n        {\\n            if (cg.CalculationItems.Any(lambda))\\n            {\\n\\n                calcItem = cg.CalculationItems.Where(lambda).FirstOrDefault();\\n\\n                if (!rewriteIfFound)\\n                {\\n                    return calcItem;\\n                }\\n            }\\n        }\\n\\n\\n        if(calcItem == null)\\n        {\\n            calcItem = cg.AddCalculationItem(name: calcItemName, expression: valueExpression);\\n        }\\n        else \\n        {\\n            //rewrite the found calcItem\\n            calcItem.Expression = valueExpression;\\n        }\\n\\n        if(formatStringExpression != String.Empty)\\n        {\\n            calcItem.FormatStringExpression = formatStringExpression;\\n        }\\n        \\n        return calcItem;\\n            \\n    }\\n\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Dynamic Measure Calculation Group Script",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n// by Johnny Winter\\n// www.greyskullanalytics.com\\n// '2021-10-15 / B.Agullo / dynamic parameters by B.Agullo / \\n// '2022-05-14 / B.Agullo / you can now rerun the script to simply add new measures or update existing ones\\n// '2022-07-11 / B.Agullo / no check on the number of measures selected so it can be launched just to create the calc group table\\n\\n// Instructions:\\n//select the measures you want to add to your Dynamic Measure and then run this script (or store it as macro)\\n\\n//\\n// ----- do not modify script below this line -----\\n//\\n\\nstring dynamicMeasureCgTag = \\\"@GreyskullPBI\\\";\\nstring dynamicMeasureCgValue = \\\"Dynamic Measure Calculation Group\\\";\\n\\nstring dummyMeasureTag = dynamicMeasureCgTag;\\nstring dummyMeasureValue = \\\"Dummy Measure\\\";\\n\\nstring calcGroupName = \\\"\\\";\\nstring columnName = \\\"\\\";\\nstring measureName = \\\"\\\";\\nstring secondaryMeasureName = \\\"\\\";\\nstring conditionalFormatMeasureName = \\\"\\\"; \\n\\nMeasure dummyMeasure = null as Measure;\\n\\nvar dynamicCGs = Model.Tables.Where(x => x.GetAnnotation(dynamicMeasureCgTag) == dynamicMeasureCgValue);\\n\\nCalculationGroupTable cgTable = null as CalculationGroupTable; \\n// CalculationGroup cg = null as CalculationGroup;\\n\\nif(dynamicCGs.Count() == 1)\\n{\\n    //reuse the calc group\\n    cgTable = dynamicCGs.First() as CalculationGroupTable;\\n\\n}\\nelse if (dynamicCGs.Count() < 1)\\n{\\n    //create the calc group\\n    calcGroupName = Interaction.InputBox(\\\"Provide a name for your Calc Group\\\", \\\"Calc Group Name\\\", \\\"Dynamic Measure\\\", 740, 400);\\n    if (calcGroupName == \\\"\\\") return;\\n\\n    columnName = Interaction.InputBox(\\\"Calc Group column name\\\", \\\"Column Name\\\", calcGroupName, 740, 400);\\n    if (columnName == \\\"\\\") return;\\n\\n    //check to see if a table with this name already exists\\n    //if it doesnt exist, create a calculation group with this name\\n    if (!Model.Tables.Contains(calcGroupName))\\n    {\\n        cgTable = Model.AddCalculationGroup(calcGroupName);\\n        cgTable.Description = \\\"Contains dynamic measures and a column called \\\" + columnName + \\\". The contents of the dynamic measures can be controlled by selecting values from \\\" + columnName + \\\".\\\";\\n    };\\n    \\n    //set variable for the calc group\\n    Table calcGroup = Model.Tables[calcGroupName];\\n\\n    //if table already exists, make sure it is a Calculation Group type\\n    if (calcGroup.SourceType.ToString() != \\\"CalculationGroup\\\")\\n    {\\n        Error(\\\"Table exists in Model but is not a Calculation Group. Rename the existing table or choose an alternative name for your Calculation Group.\\\");\\n        return;\\n    };\\n\\n    //apply the annotation so the user is not asked again\\n    cgTable = calcGroup as CalculationGroupTable;\\n    cgTable.SetAnnotation(dynamicMeasureCgTag, dynamicMeasureCgValue);\\n\\n    //by default the calc group has a column called Name. If this column is still called Name change this in line with specfied variable\\n    if (cgTable.Columns.Contains(\\\"Name\\\"))\\n    {\\n        cgTable.Columns[\\\"Name\\\"].Name = columnName;\\n    };\\n    cgTable.Columns[columnName].Description = \\\"Select value(s) from this column to control the contents of the dynamic measures.\\\";\\n\\n}\\nelse\\n{\\n    //make them choose the calc group -- should not happen! \\n    cgTable = SelectTable(dynamicCGs, label: \\\"Select your Dynamic Measure Calculation Group For Arbitrary 2-row Header\\\") as CalculationGroupTable;\\n}\\n\\n//get the column name in case the calc group was already there\\ncolumnName = cgTable.Columns.Where(x => x.Name != \\\"Ordinal\\\").First().Name;\\n\\nvar dummyMeasures = Model.AllMeasures.Where(x => x.GetAnnotation(dummyMeasureTag) == dummyMeasureValue);\\n\\nif (dummyMeasures.Count() == 1)\\n{\\n    //get the measure\\n    measureName = dummyMeasures.First().Name;\\n\\n}\\nelse if (dummyMeasures.Count() < 1)\\n{\\n    //create the measure\\n    measureName = Interaction.InputBox(\\\"Dynamic Measure Name (cannot be named \\\\\"\\\" + columnName + \\\"\\\\\")\\\", \\\"Measure Name\\\", \\\"Dummy\\\", 740, 400);\\n    if (measureName == \\\"\\\") return;\\n\\n}\\nelse\\n{\\n    //choose measure (should not happen!)\\n    measureName = SelectMeasure(dummyMeasures).Name;\\n};\\n\\nsecondaryMeasureName = measureName + \\\" 2\\\";\\nconditionalFormatMeasureName = measureName + \\\" CF\\\";\\n\\n//check to see if dynamic measure has been created, if not create it now\\n//if a measure with that name alredy exists elsewhere in the model, throw an error\\nif (!cgTable.Measures.Contains(measureName))\\n{\\n    dummyMeasure = cgTable.AddMeasure(measureName, \\\"BLANK()\\\");\\n    dummyMeasure.Description = \\\"Control the content of this measure by selecting values from \\\" + columnName + \\\".\\\";\\n    dummyMeasure.SetAnnotation(dummyMeasureTag, dummyMeasureValue);\\n};\\n\\nif (!cgTable.Measures.Contains(secondaryMeasureName))\\n{\\n    dummyMeasure = cgTable.AddMeasure(secondaryMeasureName, \\\"BLANK()\\\");\\n    dummyMeasure.Description = \\\"Control the content of this measure by selecting values from \\\" + columnName + \\\". Secondary dynamic measure for complex use cases\\\";\\n};\\n\\nif (!cgTable.Measures.Contains(conditionalFormatMeasureName))\\n{\\n    dummyMeasure = cgTable.AddMeasure(conditionalFormatMeasureName, \\\"BLANK()\\\");\\n    dummyMeasure.Description = \\\"Control the content of this measure by selecting values from \\\" + columnName + \\\". Used this measure for conditional format purposes\\\";\\n};\\n\\n\\n\\nstring isSelectedMeasureString = \\\"[\\\" + measureName + \\\"],[\\\" + secondaryMeasureName + \\\"],[\\\" + conditionalFormatMeasureName + \\\"]\\\";\\n\\n//if no measures were selected that's the end of the story\\n//(only makes sense if being launched from another script and soon after will be launched against one or more measures)\\nif (Selected.Measures.Count == 0) \\n{\\n    return;\\n}\\nforeach (var m in Selected.Measures)\\n{\\n    \\n    //remove calculation item if already exists\\n    if (cgTable.CalculationItems.Contains(m.Name)) {\\n        cgTable.CalculationItems[m.Name].Delete();\\n    };\\n            \\n    //if (!cg.CalculationItems.Contains(m.Name))\\n    //{\\n\\n    var newCalcItem = \\n        cgTable.AddCalculationItem(\\n            m.Name, \\n            \\\"IF ( \\\" + \\\"ISSELECTEDMEASURE (\\\" + isSelectedMeasureString + \\\"), \\\" + \\\"[\\\" + m.Name + \\\"], \\\" + \\\"SELECTEDMEASURE() )\\\"\\n        );\\n\\n    // '2021-10-15 / B.Agullo / double quotes in format string need to be doubled to be preserved\\n    newCalcItem.FormatStringExpression = \\\"IF ( \\\" + \\\"ISSELECTEDMEASURE (\\\" + isSelectedMeasureString + \\\"),\\\\\"\\\" + m.FormatString.Replace(\\\"\\\\\"\\\", \\\"\\\\\"\\\\\"\\\") + \\\"\\\\\", SELECTEDMEASUREFORMATSTRING() )\\\";\\n    newCalcItem.FormatDax();\\n\\n\\n    //};\\n};",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Filtered Measures by column values",
      "Enabled": "true",
      "Execute": "// '2022-09-24 / B.Agullo / Removed ScriptHost to make it TE2 compatible\\n// '2022-05-21 / B.Agullo / \\n// FILTERED MEASURES BY COLUMN VALUES SCRIPT \\n// creates a measure for each of the values in a column filtering the selected base measure\\n// step by step instructions at https://www.esbrina-ba.com/creating-filtered-measures-or-how-to-show-the-total-along-with-the-detail-in-a-chart/\\n\\nvar measures = Selected.Measures;\\n\\nif (measures.Count == 0)\\n{\\n    Error(\\\"Select one or more measures\\\");\\n}\\n\\nTable table = SelectTable();\\nColumn column = SelectColumn(table);\\n\\nstring query = \\\"EVALUATE DISTINCT(\\\" + column.DaxObjectFullName + \\\")\\\";\\n\\nusing (var reader = Model.Database.ExecuteReader(query))\\n{\\n    // Create a loop for every row in the resultset\\n    while (reader.Read())\\n    {\\n        string columnValue = reader.GetValue(0).ToString();\\n        string formulaColumnValue = columnValue; \\n\\n\\n\\n        if (column.DataType.Equals(DataType.String))\\n        {\\n            formulaColumnValue = \\\"\\\\\"\\\" + columnValue + \\\"\\\\\"\\\";\\n        }\\n\\n\\n        foreach (Measure measure in measures)\\n        {\\n            string measureName = measure.Name + \\\" \\\" + columnValue;\\n            string measureExpression =\\n                string.Format(\\\"CALCULATE({0},{1}={2})\\\",\\n                    measure.DaxObjectName,\\n                    column.DaxObjectFullName,\\n                    formulaColumnValue\\n                );\\n            string measureDescription =\\n                string.Format(\\\"{0} filtered by {1} = {2}\\\",\\n                    measure.Name,\\n                    column.Name,\\n                    columnValue\\n               );\\n            string displayFolderName =\\n                string.Format(\\\"{0} by {1}\\\",\\n                    measure.Name,\\n                    column.Name\\n                );\\n            Measure newMeasure =\\n                measure.Table.AddMeasure(\\n                    name: measureName,\\n                    expression: measureExpression,\\n                    displayFolder: displayFolderName\\n                );\\n            newMeasure.Description = measureDescription;\\n            newMeasure.FormatDax();\\n            newMeasure.FormatString = measure.FormatString;\\n\\n\\n        }\\n    }\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Generate Calc Group to Sort a Matrix by a Calc Item Column",
      "Enabled": "true",
      "Execute": "//'2023-07-27 / B.Agullo / \\n// Generate Calc Group to Sort a Matrix by a Calc Item Column\\n// Automation of the Calculation group introduced in this blog post: https://www.esbrina-ba.com/sorting-a-matrix-by-a-calculation-item-column/\\n// this script was written live in the Seattle Modern Excel & Power BI User Group  on July 26th 2023.\\n// To execute select a calculation group table and click execute\\n// It es recommented to store as macro for Calculation Group Table\\nstring noSortCalcItemName = \\\"No Sort\\\";\\nif (Selected.Tables.Count != 1)\\n{\\n    Error(\\\"Please select a single calculation group and try again.\\\");\\n    return;\\n}\\nif (Selected.Table.ObjectTypeName != \\\"Calculation Group Table\\\")\\n{\\n    Error(\\\"This is not a calculation group\\\");\\n    return;\\n}\\nCalculationGroupTable calculationGroupTable =\\n    Selected.Table as CalculationGroupTable;\\ncalculationGroupTable.AddCalculationItem(noSortCalcItemName, \\\"1\\\");\\nstring calcTableName = calculationGroupTable.Name + \\\" Names\\\";\\nstring calcTableExpression = calculationGroupTable.DaxObjectFullName;\\nCalculatedTable calculatedTable =\\n    Model.AddCalculatedTable(calcTableName, calcTableExpression);\\nbool te2 = (calculatedTable.Columns.Count == 0);\\nColumn firstCalcTableColumn =\\n    te2 ? calculatedTable.AddCalculatedColumn(\\n        calculationGroupTable.Columns[0].Name, \\\"1\\\")\\n    : calculatedTable.Columns[0];\\nstring sortCalcGroupName = \\\"Sort\\\";\\nstring sortCalcItemExpression =\\n    String.Format(@\\\" \\n        VAR inTotal =\\n            NOT HASONEVALUE ( {0} )\\n        VAR sortBy =\\n            SELECTEDVALUE ( {1}, \\\"\\\"{2}\\\"\\\" )\\n        VAR result =\\n            IF (\\n                inTotal,\\n                CALCULATE (\\n                    SELECTEDMEASURE (),\\n                    {0} = sortBy\\n                ),\\n                SELECTEDMEASURE ()\\n            )\\n        RETURN\\n            result\\\",\\n        calculationGroupTable.Columns[0].DaxObjectFullName,\\n        calculatedTable.Columns[0].DaxObjectFullName,\\n        noSortCalcItemName);\\nCalculationGroupTable sortCalcGroup =\\n    Model.AddCalculationGroup(sortCalcGroupName);\\nCalculationItem sortCalcItem =\\n    sortCalcGroup.AddCalculationItem(\\n        sortCalcGroupName,\\n        sortCalcItemExpression);\\nsortCalcItem.FormatDax();\\nif (te2)\\n{\\n    calculatedTable.Columns[0].Delete();\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Inactive Relationships Activation Calc Group Script",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms; \\nusing Microsoft.VisualBasic;\\n\\n//2022-09-14 / B.Agullo / first release\\n//CREATE CALCULATION GROUP TO ENABLE INACTIVE RELEATIONSHIPS\\n//Select releationships of your model and run the script\\n\\n//see https://www.esbrina-ba.com/activating-inactive-relationships-the-smart-way/ \\n\\n//initialize calc group variable\\nCalculationGroupTable cg = null as CalculationGroupTable;\\n\\n//create calc group (only first time)\\nif(!CalculationGroupUtils.CreateCalculationGroup(\\n    model:Model,\\n    myCalculationGroup: out cg,\\n    defaultCalculationGroupName: \\\"Model\\\",annotationValue:\\\"Model modifications\\\")) return;\\n\\n//goes through selected relationships\\nforeach (SingleColumnRelationship r in Selected.SingleColumnRelationships)\\n{\\n    //and only for those inactive\\n    if (!r.IsActive)\\n    {   \\n        //prepare name and expression for the calculation item\\n        string calcItemName = r.FromColumn.DaxObjectFullName + \\\" - \\\" + r.ToColumn.DaxObjectFullName;\\n        string calcItemExpression =\\n            String.Format(\\n                \\\"CALCULATE(SELECTEDMEASURE(),USERELATIONSHIP({0},{1}))\\\",\\n                r.FromColumn.DaxObjectFullName,\\n                r.ToColumn.DaxObjectFullName\\n            );\\n        \\n        //add calculation item\\n        CalculationItem calcItem = null as CalculationItem; \\n        if(!CalculationGroupUtils.CreateCalculationItem(\\n            out calcItem,\\n            cg: cg,\\n            defaultCalculationItemName: calcItemName,\\n            promptUser: false, \\n            calcItemExpression:calcItemExpression,\\n            regenerateIfPresent: false)) return;\\n    }\\n}\\n\\npublic static class StringUtils\\n{\\n    public enum CheckType\\n    {\\n        Table,\\n        Measure,\\n        Column,\\n        CalculationItem,\\n        None\\n    }\\n    public static bool InitString\\n        (\\n            out string stringToInit,\\n            string label = \\\"Name\\\",\\n            string defaultValue = \\\"Default Name\\\",\\n            string errorMessage = \\\"No name provided\\\",\\n            string alreadyUsedNameErrorMessage = \\\"There is already another {0} called {1}\\\", //collision with names alerady in the model\\n            string invalidNameErrorMessage = \\\"Name cannot be any of the following: {0}\\\", //arbitrary list of forbidden names\\n            string[] invalidNames = null,\\n            Model model = null,\\n            Table table = null,\\n            CalculationGroupTable cg = null,\\n            CheckType checkType = CheckType.None,\\n            string prompt = \\\"Default Prompt\\\",\\n            string valueOnError = \\\"\\\",\\n            bool promptUser = true //if false, validate only default name is not forbidden, ask for input if it is\\n        )\\n    {\\n\\n\\n        bool validName;\\n        string userValue;\\n        stringToInit = valueOnError;\\n\\n        do\\n        {\\n            if (promptUser)\\n            {\\n                //get name from user\\n                //userValue = Interaction.InputBox(prompt, label, defaultValue, 740, 400);\\n                if (!StringUtils.Input(\\n                    userString: out userValue,\\n                    prompt: prompt,\\n                    label: label,\\n                    defaultValue: defaultValue)\\n                )\\n                {\\n                    stringToInit = valueOnError;\\n                    return false;\\n                };\\n            }\\n            else\\n            {\\n                //bypass interaction\\n                userValue = defaultValue;\\n            }\\n\\n            switch (checkType)\\n            {\\n                case CheckType.None:\\n                    //nothing to check all is good \\n                    validName = true;\\n                    break;\\n\\n                case CheckType.Table:\\n                    if (model == null)\\n                    {\\n                        throw new ArgumentNullException();\\n                    }\\n                    //if it's going to be a table, there cannot be any table with the same name\\n                    validName = !model.Tables.Any(x => x.Name == userValue);\\n\\n                    if (!validName)\\n                    {\\n                        MessageUtils.ErrorMessage(\\n                            String.Format(\\n                                alreadyUsedNameErrorMessage,\\n                                \\\"table\\\",\\n                                userValue\\n                            )\\n                        );\\n                    }\\n                    break;\\n\\n                case CheckType.Column:\\n                    if (model == null)\\n                    {\\n                        throw new ArgumentNullException();\\n                    }\\n\\n                    //if its a column, there cannot be any other column on that table with the same name\\n                    validName = !table.Columns.Any(x => x.Name == userValue);\\n\\n                    if (!validName)\\n                    {\\n                        MessageUtils.ErrorMessage(\\n                            String.Format(\\n                                alreadyUsedNameErrorMessage,\\n                                \\\"column\\\", userValue\\n                            )\\n                        );\\n                    };\\n\\n                    break;\\n\\n                case CheckType.Measure:\\n                    if (model == null)\\n                    {\\n                        throw new ArgumentNullException();\\n                    }\\n                    if (table == null)\\n                    {\\n                        throw new ArgumentNullException();\\n                    }\\n\\n\\n                    //if its a measure, there cannot be any measure with the same name, or any column on that table with the same name \\n                    validName = !table.Columns.Any(x => x.Name == userValue)\\n                                && !model.AllMeasures.Any(x => x.Name == userValue);\\n\\n                    if (!validName)\\n                    {\\n                        MessageUtils.ErrorMessage(\\n                            String.Format(\\n                                alreadyUsedNameErrorMessage,\\n                                \\\"measure in the model or column in \\\" + table.Name,\\n                                userValue\\n                            )\\n                        );\\n                    };\\n                    break;\\n\\n\\n                case CheckType.CalculationItem:\\n                    if (cg == null)\\n                    {\\n                        throw new ArgumentNullException();\\n                    }\\n                    //if its a calculation item, there cannot be any other calculation item with the same name\\n                    validName = !cg.CalculationItems.Any(x => x.Name == userValue);\\n\\n                    if (!validName)\\n                    {\\n                        MessageUtils.ErrorMessage(\\n                            String.Format(\\n                                alreadyUsedNameErrorMessage,\\n                                \\\"calculation item\\\",\\n                                userValue\\n                            )\\n                        );\\n                    };\\n                    break;\\n\\n\\n                default:\\n                    validName = true;\\n                    break;\\n\\n\\n            }\\n\\n            //if we got a valid name so far check it's not in the invalid name list\\n            if (validName)\\n            {\\n                //if no invalid names then.. \\n                if (invalidNames == null || invalidNames.Length == 0)\\n                {\\n                    //..all good\\n                    validName = true;\\n                }\\n                else\\n                {\\n                    //otherwise check if the name is any of the invalid ones\\n                    validName = !invalidNames.Contains(userValue);\\n                    if (!validName)\\n                    {\\n                        //tell user this name cannot be used.\\n                        MessageUtils.ErrorMessage(\\n                            String.Format(invalidNameErrorMessage, String.Join(\\\", \\\", invalidNames))\\n                        );\\n                    }\\n                }\\n            }\\n\\n            if (!validName)\\n            {\\n                //enable user interaction to fix it\\n                promptUser = true;\\n            }\\n\\n\\n        } while (!validName);\\n\\n        //emptystring will be counted as valid string, but is not a valid name ever and we take it as a key to abort\\n        if (string.IsNullOrWhiteSpace(userValue))\\n        {\\n            MessageUtils.ErrorMessage(errorMessage);\\n            stringToInit = valueOnError;\\n            return false;\\n        };\\n\\n        //if we reach this point then is all good\\n        stringToInit = userValue;\\n        return true;\\n    }\\n\\n    public static bool Input\\n        (\\n            out string userString,\\n            string prompt = \\\"Enter string\\\",\\n            string label = \\\"String\\\",\\n            string defaultValue = \\\"some text\\\",\\n            int xPosition = 740,\\n            int yPosition = 400,\\n            bool nullOrWhiteSpaceAccepted = false,\\n            string errorMessage = \\\"Null or Empty String provided\\\",\\n            string unexpectedErrorMessage = \\\"Unexpected Error in StringUtils.Input\\\",\\n            string valueOnError = \\\"\\\"\\n        )\\n    {\\n        try\\n        {\\n            string tempUserString = Microsoft.VisualBasic.Interaction.InputBox(prompt, label, defaultValue, XPos: xPosition, YPos: yPosition);\\n\\n            if (string.IsNullOrWhiteSpace(tempUserString) && !nullOrWhiteSpaceAccepted)\\n            {\\n                MessageUtils.ErrorMessage(errorMessage);\\n                userString = valueOnError;\\n                return false;\\n            }\\n            else\\n            {\\n                userString = tempUserString;\\n                return true;\\n            };\\n        }\\n        catch\\n        {\\n            MessageUtils.ErrorMessage(unexpectedErrorMessage);\\n            userString = valueOnError;\\n            return false;\\n        }\\n\\n    }\\n}\\n\\npublic static class MessageUtils\\n{\\n    public static void ErrorMessage\\n        (\\n            string errorMessage,\\n            bool showMessage = true,\\n            string caption = \\\"Error\\\"\\n        )\\n    {\\n        try\\n        {\\n            if (showMessage)\\n            {\\n                MessageBox.Show( errorMessage,  caption, MessageBoxButtons.OK, MessageBoxIcon.Error);\\n            };\\n\\n            return;\\n        }\\n        catch\\n        {\\n            //can't really call error message right? \\n            return;\\n        };\\n    }\\n\\n\\n\\n    public static bool IsAnswerOK\\n        (\\n            string question,\\n            string caption = \\\"Before we proceed\\\"\\n\\n        )\\n    {\\n        try\\n        {\\n            DialogResult dialogResult = MessageBox.Show(question,  caption, MessageBoxButtons.YesNo);\\n            if (dialogResult == DialogResult.Yes)\\n            {\\n                return true;\\n            }\\n            else if (dialogResult == DialogResult.No)\\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                return false; //??\\n            }\\n        }\\n        catch\\n        {\\n            return false;\\n        }\\n    }\\n\\n    public static bool SelectFromList\\n        (\\n            List<string> selectionList,\\n            out List<string> selectedItems,\\n            SelectionMode selectionMode = SelectionMode.One,\\n            string title = \\\"Select from this list\\\",\\n            string cancelMessage = \\\"You cancelled the process\\\",\\n            bool selectionRequired = true,\\n            string selectionRequiredMessage = \\\"Select item or cancel\\\",\\n            bool skipDialogIfSingleItem = false,\\n            bool preselectFirstItem = false,\\n            bool showEmptyListError = true,\\n            string emptyListErrorMessage = \\\"Empty selection list\\\"\\n\\n        )\\n    {\\n\\n        selectedItems = new List<string>(); //initialize return list \\n\\n        if (selectionList.Count == 0)\\n        {\\n            if (showEmptyListError)\\n                MessageUtils.ErrorMessage(emptyListErrorMessage);\\n            return false;\\n        };\\n\\n        //general stuff\\n        var form = new Form();\\n        form.Text = title;\\n\\n        //it shows on top of the list box??\\n        //var titleLabel = new Label();\\n        //titleLabel.Text = title;\\n        //titleLabel.Dock = DockStyle.Top;\\n\\n        //button pannel at the bottom\\n        var buttonPanel = new Panel();\\n        buttonPanel.Dock = DockStyle.Bottom;\\n        buttonPanel.Height = 30;\\n\\n        //individual buttons\\n        var okButton = new Button() { DialogResult = DialogResult.OK, Text = \\\"OK\\\" };\\n        var cancelButton = new Button() { DialogResult = DialogResult.Cancel, Text = \\\"Cancel\\\", Left = 80 };\\n\\n        //listbox\\n        var listBox = new ListBox();\\n        listBox.Dock = DockStyle.Fill;\\n        listBox.SelectionMode = selectionMode;\\n\\n        //fills listbox with options from selectionList\\n        listBox.Items.AddRange(selectionList.ToArray());\\n\\n        //preselects first item by default\\n        if (preselectFirstItem)\\n            listBox.SelectedItem = selectionList[0];\\n\\n        //putting pieces together\\n        //form.Controls.Add(titleLabel);\\n        form.Controls.Add(listBox);\\n        form.Controls.Add(buttonPanel);\\n        buttonPanel.Controls.Add(okButton);\\n        buttonPanel.Controls.Add(cancelButton);\\n        //make sure it shows up in the middle of the screen\\n        form.StartPosition = FormStartPosition.CenterScreen;\\n\\n        bool oneOrMoreSelected; //flag to check listbox selection\\n\\n        bool askAgain; //flag to ask again if no selection done but selection is required\\n        DialogResult result; //variable to store the result of the dialog box\\n\\n        if (!skipDialogIfSingleItem || selectionList.Count > 1)\\n        {\\n            do\\n            {\\n                //shows the form\\n                result = form.ShowDialog();\\n\\n                if (result != DialogResult.OK)\\n                {\\n                    //user cancelled (or aborted),  return false, selectedItems is empty list\\n                    MessageUtils.ErrorMessage(cancelMessage);\\n                    return false;\\n                }\\n\\n                //true if one or more items are selected in the listbox\\n                oneOrMoreSelected = ListBoxUtils.OneOrMoreSelected(listBox);\\n\\n                //if selection required and non present, raise flag\\n                askAgain = selectionRequired && !oneOrMoreSelected;\\n\\n                //if flag is raised show message to select something or cancel\\n                if (askAgain)\\n                    MessageUtils.ErrorMessage(selectionRequiredMessage);\\n\\n            } while (askAgain);\\n\\n            //if we reached this point user selected ok and selected something if so required\\n\\n            // Loop through all items the ListBox.\\n            for (int x = 0; x < listBox.Items.Count; x++)\\n            {\\n                // Determine if the item is selected and add to the list.\\n                if (listBox.GetSelected(x) == true)\\n                    selectedItems.Add(listBox.Items[x].ToString());\\n            }\\n\\n        }\\n        else\\n        {\\n            //if we reach this point is because\\n            //skipDialogIfSingleItem && selectionList.Count == 1\\n            selectedItems.Add(selectionList.First());\\n\\n        };\\n\\n\\n\\n        //return true that all went fine\\n        return true;\\n\\n\\n    }\\n\\n\\n}\\n\\npublic static class ListBoxUtils\\n{\\n    public static bool OneOrMoreSelected(ListBox listBox)\\n    {\\n        for (int x = 0; x < listBox.Items.Count; x++)\\n        {\\n            // Determine if the item is selected.\\n            if (listBox.GetSelected(x) == true)\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n\\npublic static class MeasureUtils\\n{\\n\\n    public enum CreateMode\\n    {\\n        EnforceNewName,\\n        DeleteAndCreate,\\n        UseExisting\\n    }\\n    public static Measure CreateMeasure\\n        (\\n            Table baseTable,\\n            string defaultMeasureName = \\\"New Measure\\\",\\n            string measureExpression = \\\"\\\",\\n            string formatString = \\\"\\\",\\n            string measureNameLabel = \\\"Measure Name\\\",\\n            string displayFolder = null,\\n            CreateMode createMode = CreateMode.EnforceNewName,\\n            bool allowCustomName = true\\n\\n        )\\n    {\\n        /*test*/\\n        if (baseTable == null)\\n        {\\n            throw new ArgumentNullException();\\n        }\\n\\n        Measure returnMeasure;\\n\\n        string userMeasureName;\\n\\n        StringUtils.CheckType check;\\n\\n        if (createMode.Equals(CreateMode.EnforceNewName))\\n        {\\n            check = StringUtils.CheckType.Measure;\\n        }\\n        else\\n        {\\n            check = StringUtils.CheckType.None;\\n        };\\n\\n\\n        if (allowCustomName)\\n        {\\n            //allow user to select name\\n            if (\\n                !StringUtils.InitString(\\n                    stringToInit: out userMeasureName,\\n                    label: measureNameLabel,\\n                    defaultValue: defaultMeasureName,\\n                    checkType: check)) { return null; }\\n        }\\n        else\\n        {\\n            userMeasureName = defaultMeasureName;\\n        }\\n\\n        returnMeasure =\\n            GetMeasure(\\n                measureName: userMeasureName,\\n                model: baseTable.Model);\\n\\n        if (returnMeasure != null)\\n        {\\n            if (createMode.Equals(CreateMode.DeleteAndCreate))\\n            {\\n                //delete the measure found, will be recreated in a sec below\\n                returnMeasure.Delete();\\n            }\\n            else if (createMode.Equals(CreateMode.UseExisting))\\n            {\\n                //do not recreate anything, just return the measure found (process does not continue)\\n                return returnMeasure;\\n            }\\n            else\\n            {\\n                new Exception(\\\"this should not happen\\\");\\n            };\\n        };\\n\\n        //we reach this point if it's a new measure, or we are deleting and recreating the measure\\n        returnMeasure = baseTable.AddMeasure(name: userMeasureName, expression: measureExpression, displayFolder: displayFolder);\\n        returnMeasure.FormatString = formatString;\\n\\n        return returnMeasure;\\n\\n    }\\n    public static Measure GetMeasure(string measureName, Model model)\\n    {\\n        var matchingMeasures = model.AllMeasures.Where(x => x.Name == measureName);\\n\\n        if (matchingMeasures.Count() == 0)\\n        {\\n            return null;\\n        }\\n        else\\n        {\\n            return matchingMeasures.First();\\n        }\\n    }\\n\\n}\\n\\n\\npublic static class TableUtils\\n\\n{\\n    public static int TableCount(Model model)\\n    {\\n        MessageBox.Show(model.Name);\\n        return model.Tables.Count;\\n    }\\n\\n    public static Table GetTable(string tableName, Model Model)\\n    {\\n        var tbls = Model.Tables.Where(x => x.Name == tableName);\\n\\n        if (tbls.Count() == 0)\\n        {\\n            return null;\\n        }\\n        else\\n        {\\n            return tbls.First();\\n        }\\n\\n    }\\n\\n    public static bool CreateMeasureTable\\n        (\\n            out Table createdTable,\\n            Model model,\\n            string defaultTableName = \\\"Some Measures\\\",\\n            string label = \\\"Measure Table Name\\\",\\n            string prompt = \\\"Provide a name for the measure Table\\\"\\n        )\\n    {\\n\\n        createdTable = null;\\n\\n        if (model == null)\\n        {\\n            throw new ArgumentNullException();\\n        };\\n\\n        string tableName;\\n        if (\\n            !StringUtils.InitString(\\n                stringToInit: out tableName,\\n                label: label, prompt: prompt,\\n                checkType: StringUtils.CheckType.Table,\\n                defaultValue: defaultTableName,\\n                model: model\\n            )\\n           ) return false;\\n\\n\\n\\n        string tableExpression = \\\"{0}\\\";\\n\\n        createdTable = model.AddCalculatedTable(name: tableName, expression: tableExpression);\\n\\n        return true;\\n\\n    }\\n\\n    public static Table CreateMeasureTable2\\n        (\\n            Model model,\\n            string defaultTableName = \\\"Some Measures\\\",\\n            string label = \\\"Measure Table Name\\\",\\n            string prompt = \\\"Provide a name for the measure Table\\\"\\n        )\\n    {\\n        if (model == null)\\n        {\\n            throw new ArgumentNullException();\\n        }\\n\\n\\n\\n        return model.AddCalculatedTable(name: defaultTableName, expression: \\\"{0}\\\");\\n\\n    }\\n\\n\\n}\\n\\npublic static class CalculationGroupUtils\\n{\\n\\n    public enum CreateMode\\n    {\\n        EnforceNewName,\\n        DeleteAndCreate,\\n        UseExistingWithConfirmation,\\n        UseExistingWithoutConfirmation\\n    }\\n\\n\\n    // \\n    public static bool CreateCalculationGroup\\n        (\\n            out CalculationGroupTable myCalculationGroup,\\n            Model model,\\n            string defaultCalculationGroupName = \\\"myCalcGroup\\\",\\n            string defaultCalculationGroupColumnName = \\\"myCalcItems\\\",\\n            bool matchColumnAndCalculationGroupName = true,\\n            string annotationName = \\\"ExtendedTOMWrapper\\\",\\n            string annotationValue = \\\"Default Calculation Group\\\",\\n            string prompt = \\\"Provide name for the calculation group\\\",\\n            string columnPrompt = \\\"Provide a name for the column of the calculation group\\\",\\n            string inputFieldLabel = \\\"Name\\\",\\n            string calcGroupDescription = \\\"\\\"\\n\\n\\n        )\\n    {\\n\\n\\n        string calcGroupName;\\n        string calcGroupColumnName;\\n\\n        var ts = model.Tables.Where(x => x.GetAnnotation(annotationName) == annotationValue);\\n\\n        myCalculationGroup = null as CalculationGroupTable;\\n\\n        if (ts.Count() == 1)\\n        {\\n            myCalculationGroup = ts.First() as CalculationGroupTable;\\n        }\\n        else if (ts.Count() < 1)\\n        {\\n\\n            if (\\n                !StringUtils.InitString(\\n                    stringToInit: out calcGroupName,\\n                    prompt: prompt,\\n                    label: inputFieldLabel,\\n                    defaultValue: defaultCalculationGroupName,\\n                    checkType: StringUtils.CheckType.Table,\\n                    model: model\\n                )\\n            ) { return false; }\\n\\n            myCalculationGroup = model.AddCalculationGroup(calcGroupName);\\n            myCalculationGroup.Description = calcGroupDescription;\\n            myCalculationGroup.SetAnnotation(annotationName, annotationValue);\\n\\n\\n            if (matchColumnAndCalculationGroupName)\\n            {\\n                defaultCalculationGroupColumnName = calcGroupName;\\n            }\\n            else\\n            {\\n                if (\\n                    !StringUtils.InitString(\\n                       stringToInit: out calcGroupColumnName,\\n                       prompt: columnPrompt\\n                    )\\n                ) { return false; };\\n            };\\n\\n            model.Tables[calcGroupName].Columns[\\\"Name\\\"].Name = defaultCalculationGroupColumnName;\\n\\n        }\\n        else\\n        {\\n            //this should never happen -- who needs two calc groups for time intelligence? \\n            //myCalculationGroup = SelectTable(ts, label: \\\"Select your 'Measure Group' Calculation Group\\\") as CalculationGroupTable;\\n            myCalculationGroup = ts.First() as CalculationGroupTable;\\n        };\\n\\n        if (myCalculationGroup == null)\\n        {\\n\\n            return false;\\n        } // doesn't work in TE3 as cancel button doesn't return null in TE3\\n\\n        return true;\\n\\n    }\\n\\n\\n    public enum GetByMode\\n    {\\n        ByName,\\n        ByAnnotation\\n    }\\n\\n    //2022-02-19 / B.Agullo / \\n    public static bool GetCalculationGroup\\n    //get reference to an existing calcualtion group (if found)\\n        (\\n            out CalculationGroupTable myCalculationGroup,\\n            Model model,\\n            string selectionPrompt = \\\"Select calculation group\\\",\\n            bool filterByAnnotation = false,\\n            string annotationName = null,\\n            string annotationValue = null,\\n            string calcGroupName = null,\\n            bool skipIfOnlyOneMatches = true\\n\\n        )\\n    {\\n        if (model == null)\\n        {\\n            throw new ArgumentNullException();\\n        }\\n\\n        myCalculationGroup = null;\\n\\n        if (model.CalculationGroups.Count() == 0) return false;\\n\\n        List<string> matchingCalcGroupNames = new List<string>();\\n\\n        List<string> selectedCalcGroupNames = new List<string>();\\n\\n        if (annotationName != null && annotationValue != null)\\n        {\\n            matchingCalcGroupNames =\\n                (List<string>)model.CalculationGroups\\n                    .Where(x => x.GetAnnotation(annotationName) == annotationValue)\\n                    .Select(x => x.Name).ToList();\\n        }\\n        else if (calcGroupName != null)\\n        {\\n            matchingCalcGroupNames =\\n                (List<string>)model.CalculationGroups\\n                .Where(x => x.Name == calcGroupName)\\n                .Select(x => x.Name).ToList();\\n        }\\n        else\\n        {\\n            matchingCalcGroupNames =\\n                model.CalculationGroups\\n                    .Select(x => x.Name).ToList();\\n        }\\n\\n\\n\\n\\n        if (!MessageUtils.SelectFromList(selectionList: matchingCalcGroupNames,\\n\\n            selectedItems: out selectedCalcGroupNames\\n            )) return false;\\n\\n\\n        myCalculationGroup = model.CalculationGroups.Where(x => x.Name == matchingCalcGroupNames.First()).First();\\n\\n\\n        return true;\\n    }\\n\\n    public static bool CreateCalculationItem\\n         (\\n            out CalculationItem myCalcItem,\\n            CalculationGroupTable cg,\\n            string defaultCalculationItemName = \\\"New Calc Item\\\",\\n            bool promptUser = false,\\n            string prompt = \\\"Provide name for the calculation item\\\",\\n            string inputFieldLabel = \\\"Name\\\",\\n            string calcItemDescription = \\\"\\\",\\n            string calcItemExpression = \\\"\\\",\\n            bool regenerateIfPresent = true\\n\\n        )\\n    {\\n        myCalcItem = null as CalculationItem;\\n        \\n        if(calcItemExpression == String.Empty)\\n        {\\n            MessageUtils.ErrorMessage(\\\"No calc Item Expression provided.\\\");\\n            return false;\\n        };\\n\\n        string calcItemName;\\n\\n        if (promptUser)\\n        {\\n            if (\\n                    !StringUtils.InitString\\n                        (\\n                            out calcItemName, \\n                            label: \\\"Calculation Item Name\\\", \\n                            defaultValue: defaultCalculationItemName,\\n                            cg:cg,\\n                            checkType: StringUtils.CheckType.CalculationItem,\\n                            prompt: prompt,\\n                            promptUser: promptUser\\n                            \\n                        )\\n            ) return false; //the naming step didn't go well\\n        }\\n        else\\n        {\\n            calcItemName = defaultCalculationItemName;\\n        }\\n\\n        if(cg.CalculationItems.Any(x=> x.Name == calcItemName))\\n        {\\n            if(regenerateIfPresent)\\n            {\\n                cg.CalculationItems.Where(x => x.Name == calcItemName).First().Delete();\\n            }\\n            else\\n            {\\n                return true; //all is good, nothing to do\\n            }\\n            \\n        }\\n        \\n        CalculationItem calcItem = cg.AddCalculationItem(name: calcItemName, expression: calcItemExpression);\\n        calcItem.Description = calcItemExpression;\\n        calcItem.FormatDax();\\n\\n        return true;\\n\\n\\n\\n    }\\n}\\n        ",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Measure in Calc Item",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n// CHANGE LOG: \\n// '2021-10-20 / B.Agullo / \\n// '2021-11-22 / B.Agullo / Totally rewrote the script as did not work the way it was \\n\\n\\n// Instructions:\\n// select the calculation items and and the measure(s) for which the calculation should be shown. \\n// the first time you will be asked to introduce a name for your calc group and dummy measure \\n// second time on it will reuse the same group and dummy measure to add new calc items \\n// the script will create a new calc item for eachs elected measure\\n// A pop-up will show if the measure has been previously selected and thus already has a calculation item with its name\\n\\n\\n//\\n// ----- do not modify script below this line -----\\n//\\n\\nstring affectedMeasures = \\\"\\\"; \\nstring selectedCalcItems = \\\"\\\"; \\nstring selectedCalcItemsCalcGroupName = \\\"\\\"; \\n\\nCalculationGroup selectedCalculationGroup = null as CalculationGroup; \\nColumn selectedCalcItemsCalcGroupColumn = null as Column; \\n\\nif (Selected.Measures.Count == 0) {\\n    \\n    Error(\\\"No measures selected\\\"); \\n    return; \\n\\n} else if (Selected.CalculationItems.Count == 0) { \\n    \\n    Error(\\\"No calculation items selected\\\"); \\n    return; \\n\\n} else {\\n    \\n    // create in-line table with selected calc item names \\n    foreach(var ci in Selected.CalculationItems) { \\n        \\n        if(selectedCalcItems == \\\"\\\") {\\n            selectedCalcItems += \\\"{\\\\\"\\\" + ci.Name + \\\"\\\\\"\\\"; \\n\\n        } else { \\n            \\n            selectedCalcItems += \\\",\\\\\"\\\" + ci.Name + \\\"\\\\\"\\\"; \\n\\n        }; \\n        \\n        if(selectedCalcItemsCalcGroupName == \\\"\\\") {\\n             \\n            //selectedCalculationGroup = ci.CalculationGroupTable;\\n            selectedCalcItemsCalcGroupName = ci.CalculationGroupTable.Name; \\n            \\n        };\\n        \\n        if(selectedCalcItemsCalcGroupColumn == null) {\\n            \\n            //get the only column that is not \\\"ordinal\\\"\\n            selectedCalcItemsCalcGroupColumn = (ci.CalculationGroupTable as Table).Columns.Where(x => x.Name != \\\"Ordinal\\\").First(); \\n            \\n        };\\n    };  \\n    \\n    selectedCalcItems += \\\"}\\\"; \\n    \\n};\\n\\nstring calcGroupTag = \\\"Dynamic Measure Calculation Group For Arbitrary 2-row Header\\\";\\nstring dummyMeasureTag = \\\"Dummy Measure for the Dynamic Measure Calculation Group For Arbitrary 2-row Header\\\";\\n\\n//dynamic Measure CG for 2 row header\\nvar DynamicMeasureCGs = Model.Tables.Where(x => x.GetAnnotation(\\\"@AgulloBernat\\\") == calcGroupTag);\\n\\nvar DynamicMeasureCG = null as CalculationGroupTable; \\n\\nif (DynamicMeasureCGs.Count() == 1 ) {\\n    \\n    DynamicMeasureCG = DynamicMeasureCGs.First() as CalculationGroupTable;\\n    \\n} else if (DynamicMeasureCGs.Count() < 1) {\\n    \\n    string calcGroupName = \\n        Interaction.InputBox(\\n            \\\"Provide a name for your Dynamic Measure Calculation Group For Arbitrary 2-row Header\\\", \\n            \\\"Calculation Group Name\\\", \\\"\\\", 740, 400\\n        );\\n\\n    if(calcGroupName == \\\"\\\") {\\n        \\n        Error(\\\"No name provided\\\");         \\n        return;\\n        \\n    };\\n    \\n    DynamicMeasureCG = Model.AddCalculationGroup(calcGroupName);\\n    DynamicMeasureCG.Description = \\n        \\\"Under this calc group only certain calculation items of \\\" \\n            + selectedCalcItemsCalcGroupName \\n            + \\\" calculation group will be visible and with a certain measure. See calculation items for details\\\";\\n    \\n    DynamicMeasureCG.SetAnnotation(\\\"@AgulloBernat\\\",calcGroupTag);\\n    Model.Tables[calcGroupName].Columns[\\\"Name\\\"].Name = calcGroupName; \\n\\n} else {\\n    \\n    //this should never happen --\\n    DynamicMeasureCG = SelectTable(DynamicMeasureCGs, label:\\\"Select your Dynamic Measure Calculation Group For Arbitrary 2-row Header\\\") as CalculationGroupTable;\\n    \\n};\\n\\nif (DynamicMeasureCG == null) { return; } // doesn't work in TE3 as cancel button doesn't return null in TE3\\n\\n//INIT DUMMY MEASURE (if necessary) \\nvar dummyMeasureCandidates = DynamicMeasureCG.Measures.Where(x => x.GetAnnotation(\\\"@AgulloBernat\\\") == dummyMeasureTag);\\nMeasure dummyMeasure = null as Measure; \\n\\nif (dummyMeasureCandidates.Count() == 1) {\\n    \\n    dummyMeasure = dummyMeasureCandidates.First() as Measure; \\n\\n} else if (dummyMeasureCandidates.Count() < 1) {\\n    \\n    string dummyMeasureName = Interaction.InputBox(\\\"Enter a name for the dummy measure\\\", \\\"Measure Name\\\", \\\"\\\", 740, 400);\\n\\n    if(dummyMeasureName == \\\"\\\") {\\n        \\n        Error(\\\"No name provided\\\");         \\n        return;\\n        \\n    };\\n    \\n    //add dummy measure if not present yet\\n    if(!DynamicMeasureCG.Measures.Where(m => m.Name == dummyMeasureName).Any())  {\\n        \\n        dummyMeasure = DynamicMeasureCG.AddMeasure(dummyMeasureName,\\\"0\\\");\\n        \\n    } else { \\n        \\n        //get the reference if already exists \\n        dummyMeasure = DynamicMeasureCG.Measures.Where(m => m.Name == dummyMeasureName).First(); \\n        \\n    };\\n\\n    //in any case add the annotation so it will be found next time \\n    dummyMeasure.SetAnnotation(\\\"@AgulloBernat\\\",dummyMeasureTag); \\n\\n} else {\\n    \\n    dummyMeasure = \\n        SelectMeasure(\\n            dummyMeasureCandidates,\\n            label:\\\"Select your Dummy Measure for your Dynamic Measure Calculation Group For Arbitrary 2-row Header\\\"\\n        ) as Measure; \\n\\n} ; \\n\\nforeach (var m in Selected.Measures) { \\n    \\n    if (!DynamicMeasureCG.CalculationItems.Where(x => x.Name == m.Name).Any()) { \\n        \\n        string newCalcItemName = m.Name; \\n        string newCalcItemExpression = \\n             \\\"IF(\\\" + \\n             \\\"    ISSELECTEDMEASURE( [\\\" + dummyMeasure.Name + \\\"] ),\\\" + \\n             \\\"    VAR currentCalcItem =\\\" + \\n             \\\"        SELECTEDVALUE( \\\"+  selectedCalcItemsCalcGroupColumn.DaxObjectFullName +\\\", \\\\\"NO SELECTION\\\\\" )\\\" + \\n             \\\"    RETURN\\\" + \\n             \\\"        IF( currentCalcItem IN \\\" + selectedCalcItems + \\\", [\\\" + m.Name + \\\"] ),\\\" + \\n             \\\"    SELECTEDMEASURE()\\\" + \\n             \\\")\\\";\\n        \\n        CalculationItem newCalcItem =  DynamicMeasureCG.AddCalculationItem(newCalcItemName, newCalcItemExpression); \\n        newCalcItem.FormatDax(); \\n        \\n    } else { \\n        \\n        Info(\\\"Calculation item \\\" + m.Name + \\\" already present. Please modify manually, or delete it and try again\\\"); \\n        \\n    };\\n    \\n}; \\n\\nCallDaxFormatter(); \\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Multi-Total Calc Group (add total script)",
      "Enabled": "true",
      "Execute": "string calcGroupTypeLabel = \\\"CalcGroupType\\\";\\nstring calcGroupTypeValue = \\\"MultiTotal\\\";\\nIEnumerable<Table> multiTotalCalcGroups = \\n    Model.Tables.Where(\\n        t => \\n        t.GetAnnotation(calcGroupTypeLabel) \\n            == calcGroupTypeValue);\\nTable calcGroupAsTable = null as Table; \\nif(multiTotalCalcGroups.Count() == 0)\\n{\\n    Error(\\\"No multi-total calc group found. \\\" +\\n        \\\"Run the macro to create a multi-total \\\" +\\n        \\\"calc group first and try again\\\");\\n    return;\\n} else if(multiTotalCalcGroups.Count() == 1)\\n{\\n    calcGroupAsTable = multiTotalCalcGroups.First();\\n}\\nelse\\n{\\n    calcGroupAsTable = SelectTable(multiTotalCalcGroups, label: \\\"Select Multi-total Calc Group to use\\\");\\n    if(calcGroupAsTable == null)\\n    {\\n        Error(\\\"You cancelled the execution.\\\");\\n        return;\\n    }\\n}\\nif(Selected.CalculationItems.Count() == 0)\\n{\\n    Error(\\\"Select one or more calculation items and try again.\\\");\\n    return;\\n}\\nstring calcGroupValuesFieldLabel = \\\"ValuesField\\\";\\nstring multiTotalBreakDownColumnCode = calcGroupAsTable.GetAnnotation(calcGroupValuesFieldLabel);\\nCalculationGroupTable calcGroup = calcGroupAsTable as CalculationGroupTable;\\nforeach(CalculationItem calcItem in Selected.CalculationItems)\\n{\\n    string calcItemName = calcItem.Name;\\n    string calcItemExpression =\\n        String.Format(\\n            @\\\"IF(\\n                NOT ISINSCOPE( {0} ),\\n                CALCULATE(\\n                    SELECTEDMEASURE( ),\\n                    {1} = \\\"\\\"{2}\\\"\\\"\\n                )\\n            )\\\",\\n            multiTotalBreakDownColumnCode,\\n            calcItem.CalculationGroupTable.Columns[0].DaxObjectFullName,\\n            calcItem.Name);\\n    CalculationItem customTotalCalcItem = \\n        calcGroup.AddCalculationItem(\\n            name:calcItemName, \\n            expression:calcItemExpression);\\n    string calcItemFormatStringExpression =\\n        String.Format(\\n            @\\\"IF(\\n                NOT ISINSCOPE( {0} ),\\n                CALCULATE(\\n                    SELECTEDMEASUREFORMATSTRING( ),\\n                    {1} = \\\"\\\"{2}\\\"\\\"\\n                )\\n            )\\\",\\n            multiTotalBreakDownColumnCode,\\n            calcItem.CalculationGroupTable.Columns[0].DaxObjectFullName,\\n            calcItem.Name);\\n    customTotalCalcItem.FormatStringExpression = \\n        calcItemFormatStringExpression;\\n    customTotalCalcItem.FormatDax();\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Multi-Total Calc Group (base script)",
      "Enabled": "true",
      "Execute": "// '2023-07-09 / B.Agullo / \\n//\\n// Multi-Total Calc Group: Base script\\n//\\n// The development of this script is shown here https://www.esbrina-ba.com/industrializing-calculation-groups/\\n// store as macro and select only column as target object\\n// to use the right click on a single column you want to use to slice your data from the columns section of your matrix.\\n// to add custom totals to the matrix using this calc group as top level column field, you need to run \\n// the script shared in the file \\\"Multi-Total Calc Group (add total script).csx\\\" in this same repository folder. \\n//\\n// Follow Bernat on LinkedIn and Twitter\\n// https://www.linkedin.com/in/bernatagullo/\\n// https://twitter.com/AgulloBernat\\n\\n#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\nif (Selected.Columns.Count() != 1)\\n{\\n    Error(\\\"Select only 1 column and try again\\\");\\n    return;\\n}\\nColumn column = Selected.Column;\\nstring suggestedCalcGroupName = column.Name + \\\" Multi-Totals\\\";\\nstring calcGroupName = Interaction.InputBox(\\n    Prompt:\\\"Please provide the name of the multi-total calc group.\\\",\\n    DefaultResponse:suggestedCalcGroupName);\\nif (calcGroupName == \\\"\\\")\\n{\\n    Error(\\\"No name provided\\\");\\n    return;\\n};\\nCalculationGroupTable calcGroup = \\n    Model.AddCalculationGroup(\\n        calcGroupName);\\nstring valuesCalcItemName = \\\"Values\\\";\\nstring valuesCalcItemExpression =\\n    String.Format(\\n        @\\\"IF(\\n            ISINSCOPE( {0} ),\\n            SELECTEDMEASURE()\\n        )\\\", column.DaxObjectFullName);\\nCalculationItem valuesCalcItem =\\n    calcGroup.AddCalculationItem(\\n        name: valuesCalcItemName,\\n        expression: valuesCalcItemExpression);\\nvaluesCalcItem.FormatDax();\\nvaluesCalcItem.Description = \\\"This calculation item is to show the breakdown by \\\" + column.Name;\\nvaluesCalcItem.Ordinal = 0;\\nstring totalCalcItemName = \\\"Total\\\";\\nstring totalCalcItemExpression =\\n    String.Format(\\n        @\\\"IF(\\n            NOT ISINSCOPE( {0} ),\\n            SELECTEDMEASURE()\\n        )\\\", column.DaxObjectFullName);\\nCalculationItem totalCalcItem =\\n    calcGroup.AddCalculationItem(\\n        name: totalCalcItemName,\\n        expression: totalCalcItemExpression);\\ntotalCalcItem.FormatDax();\\ntotalCalcItem.Description = \\\"This calculation item is to show the regular total as a calculation item along with different totals that will be added to this calculation group\\\";\\ntotalCalcItem.Ordinal = 1; \\nstring calcGroupTypeLabel = \\\"CalcGroupType\\\";\\nstring calcGroupTypeValue = \\\"MultiTotal\\\";\\ncalcGroup.SetAnnotation(\\n    calcGroupTypeLabel,\\n    calcGroupTypeValue);\\nstring calcGroupValuesFieldLabel = \\\"ValuesField\\\";\\nstring calcGroupValuesFieldValue = column.DaxObjectFullName;\\ncalcGroup.SetAnnotation(\\n    calcGroupValuesFieldLabel,\\n    calcGroupValuesFieldValue);\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\New Calculate Measure",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n// this sctipt creates a CALCULATE expression based on an existing measure\\n// 2021-10-11 B.Agullo @AgulloBernat\\n\\nif(Selected.Measures.Count != 1) {\\n    Error(\\\"Select one and only one measure\\\"); \\n    return; \\n} \\n\\nvar selectedMeasure = Selected.Measure;\\nvar parentTable = selectedMeasure.Table; \\n\\nstring newMeasureName = Interaction.InputBox(\\\"New Measure name\\\", \\\"Name\\\", selectedMeasure.Name + \\\" modified\\\", 740, 400);\\nstring newMeasureExpression = \\\"CALCULATE([\\\" + selectedMeasure.Name + \\\"])\\\"; \\n\\nparentTable.AddMeasure(newMeasureName,newMeasureExpression); \\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Number Format Calc Group",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\nusing Microsoft.VisualBasic;\\nstring cgAnnotationLabel = \\\"MadeWith\\\";\\nstring cgAnnotationValue = \\\"NumberFormatCalcGroup\\\";\\nif (Selected.Measures.Count == 0)\\n{\\n    Error(\\\"Select one or more measures and try again\\\");\\n    return;\\n};\\nstring measureList = string.Join(\\\",\\\", Selected.Measures.Select(x => x.DaxObjectFullName));\\nstring measureListName = string.Join(\\\",\\\", Selected.Measures.Select(x => x.Name));\\nCalculationGroupTable cg = null as CalculationGroupTable;\\nif (Model.Tables.Any(t => t.GetAnnotation(cgAnnotationLabel) == cgAnnotationValue)) \\n{ \\n    cg = (CalculationGroupTable) Model.Tables.Where(t => t.GetAnnotation(cgAnnotationLabel) == cgAnnotationValue).First();\\n} \\nelse\\n{\\n    string calcGroupName = Fx.GetNameFromUser(\\\"Choose name for the number format Calculation Group\\\", \\\"Atention\\\", \\\"Number Format\\\");\\n    if (calcGroupName == \\\"\\\") return; // in case user cancelled\\n    cg = Model.AddCalculationGroup(name: calcGroupName);\\n    cg.Columns[0].Name = cg.Name;\\n    cg.SetAnnotation(cgAnnotationLabel, cgAnnotationValue);\\n}\\nList<string> formatList = new List<string>();\\nformatList.Add(\\\"in milions\\\");\\nformatList.Add(\\\"in thousands\\\");\\nstring selectedFormat = Fx.ChooseString(formatList);\\nif (selectedFormat == null) return;\\nstring formatString = \\\"\\\";\\nswitch (selectedFormat)\\n{\\n    case \\\"in milions\\\":\\n        // code block\\n        formatString = @\\\"\\\"\\\"#,##0,,.0\\\"\\\"\\\";\\n        break;\\n    case \\\"in thousands\\\":\\n        // code block\\n        formatString = @\\\"\\\"\\\"#,##0,.0\\\"\\\"\\\";\\n        break;\\n    default:\\n        // code block\\n        break;\\n}\\nstring ciValueExpression = \\\"SELECTEDMEASURE()\\\";\\nstring ciFormatStringExpression =\\n    string.Format(\\n        @\\\"IF(\\n            ISSELECTEDMEASURE({0}),\\n            {1},\\n            SELECTEDMEASUREFORMATSTRING()\\n        )\\\",\\n        measureList,\\n        formatString\\n    );\\nstring ciName = string.Format(\\\"{1} ({0})\\\", measureListName, selectedFormat);\\nCalculationItem ci = cg.AddCalculationItem(name:ciName ,expression:ciValueExpression);\\nci.FormatStringExpression = ciFormatStringExpression;\\nci.FormatDax();\\n\\npublic static class Fx\\n{\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        if(!model.Tables.Any(t => t.Name == tableName))\\n        {\\n            return model.AddCalculatedTable(tableName, tableExpression);\\n        }\\n        else\\n        {\\n            return model.Tables.Where(t => t.Name == tableName).First();\\n        }\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {    \\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList)\\n    {\\n        Func<IList<string>, string, string> SelectString = (IList<string> options, string title) =>\\n        {\\n            var form = new Form();\\n            form.Text = title;\\n            var buttonPanel = new Panel();\\n            buttonPanel.Dock = DockStyle.Bottom;\\n            buttonPanel.Height = 30;\\n            var okButton = new Button() { DialogResult = DialogResult.OK, Text = \\\"OK\\\" };\\n            var cancelButton = new Button() { DialogResult = DialogResult.Cancel, Text = \\\"Cancel\\\", Left = 80 };\\n            var listbox = new ListBox();\\n            listbox.Dock = DockStyle.Fill;\\n            listbox.Items.AddRange(options.ToArray());\\n            listbox.SelectedItem = options[0];\\n            form.Controls.Add(listbox);\\n            form.Controls.Add(buttonPanel);\\n            buttonPanel.Controls.Add(okButton);\\n            buttonPanel.Controls.Add(cancelButton);\\n            var result = form.ShowDialog();\\n            if (result == DialogResult.Cancel) return null;\\n            return listbox.SelectedItem.ToString();\\n        };\\n        //let the user select the name of the macro to copy\\n        String select = SelectString(OptionList, \\\"Choose a macro\\\");\\n        //check that indeed one macro was selected\\n        if (select == null)\\n        {\\n            Info(\\\"You cancelled!\\\");\\n        }\\n        return select;\\n    }\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Referential Integrity Check Measures",
      "Enabled": "true",
      "Execute": "// 2023-02-15 / B.Agulló / Added useRelationship in the expression to check also inactive relationships\\n// 2023-12-22 / B.Agulló / Added suggestions by Ed Hansberry \\n// 2024-07-13 / B.Agulló / Add annotations for the report-layer script, possible to execute without selected table, subtitles measures\\n//\\n// Instructions:\\n// Select the desired table  to store all data quality measures\\n// or execute just on the model and a new table will be created for you\\n// See https://www.esbrina-ba.com/easy-management-of-referential-integrity/\\n//\\n// To create the report sheet check out:\\n// https://www.esbrina-ba.com/building-a-referential-integrity-report-page-with-a-c-script/\\n\\n//change the resulting variable names if you want\\nstring overallCounterName = \\\"Total Unmapped Items\\\";\\nstring overallDetailName = \\\"Data Problems\\\";\\nstring targetTableNameIfCreated = \\\"Referential Integrity\\\";\\n//do not modify the script below\\nstring overallCounterExpression = \\\"\\\";\\nstring overallDetailExpression = \\\"\\\\\"\\\\\"\\\";\\nstring annLabel = \\\"ReferencialIntegrityMeasures\\\";\\nstring annValueTotal = \\\"TotalUnmappedItems\\\";\\nstring annValueDetail = \\\"DataProblems\\\";\\nstring annValueDataQualityMeasures = \\\"DataQualityMeasure\\\";\\nstring annValueDataQualityTitles = \\\"DataQualityTitle\\\";\\nstring annValueDataQualitySubtitles = \\\"DataQualitySubitle\\\";\\nstring annValueFactColumn = \\\"FactColumn\\\";\\nTable tableToStoreMeasures = null as Table;\\nif (Selected.Tables.Count() == 0)\\n{\\n    tableToStoreMeasures = Model.AddCalculatedTable(targetTableNameIfCreated, \\\"{0}\\\");\\n}\\nelse\\n{\\n    tableToStoreMeasures = Selected.Tables.First();\\n}\\nint measureIndex = 0;\\nforeach (var r in Model.Relationships)\\n{\\n    bool isOneToMany =\\n        r.FromCardinality == RelationshipEndCardinality.One\\n        && r.ToCardinality == RelationshipEndCardinality.Many;\\n    bool isManyToOne =\\n        r.FromCardinality == RelationshipEndCardinality.Many\\n        && r.ToCardinality == RelationshipEndCardinality.One;\\n    Column manyColumn = null as Column;\\n    Column oneColumn = null as Column;\\n    bool isOneToManyOrManyToOne = true;\\n    if (isOneToMany)\\n    {\\n        manyColumn = r.ToColumn;\\n        oneColumn = r.FromColumn;\\n    }\\n    else if (isManyToOne)\\n    {\\n        manyColumn = r.FromColumn;\\n        oneColumn = r.ToColumn;\\n    }\\n    else\\n    {\\n        isOneToManyOrManyToOne = false;\\n    }\\n    if (isOneToManyOrManyToOne)\\n    {\\n        measureIndex++; //increment index\\n        //add measure counting how many different items in the fact table are not present in the dimension\\n        string orphanCountExpression =\\n            \\\"CALCULATE(\\\"\\n                + \\\"SUMX(VALUES(\\\" + manyColumn.DaxObjectFullName + \\\"),1),\\\"\\n                + \\\"ISBLANK(\\\" + oneColumn.DaxObjectFullName + \\\"),\\\"\\n                + \\\"USERELATIONSHIP(\\\" + manyColumn.DaxObjectFullName + \\\",\\\" + oneColumn.DaxObjectFullName + \\\"),\\\"\\n                + \\\"ALLEXCEPT(\\\" + manyColumn.Table.DaxObjectFullName + \\\",\\\" + manyColumn.DaxObjectFullName + \\\")\\\"\\n            + \\\")\\\";\\n        string orphanMeasureName =\\n            manyColumn.Name + \\\" not mapped in \\\" + manyColumn.Table.Name;\\n        Measure newCounter = tableToStoreMeasures.AddMeasure(name: orphanMeasureName, expression: orphanCountExpression, displayFolder: \\\"_Data quality Measures\\\");\\n        newCounter.FormatString = \\\"#,##0\\\";\\n        newCounter.FormatDax();\\n        newCounter.SetAnnotation(annLabel, annValueDataQualityMeasures + \\\"_\\\" + measureIndex.ToString());\\n        //add annotation to trace back the fact table when building the report\\n        manyColumn.SetAnnotation(annLabel, annValueFactColumn + \\\"_\\\" + measureIndex.ToString());\\n        //add measure saying how many are not mapped in the fact table\\n        string orphanTableTitleMeasureExpression = \\\"FORMAT(\\\" + newCounter.DaxObjectFullName +\\\"+0,\\\\\"\\\" + newCounter.FormatString + \\\"\\\\\") & \\\\\" \\\" + newCounter.Name + \\\"\\\\\"\\\";\\n        string orphanTableTitleMeasureName = newCounter.Name + \\\" Title\\\";\\n        Measure newTitle = tableToStoreMeasures.AddMeasure(name: orphanTableTitleMeasureName, expression: orphanTableTitleMeasureExpression, displayFolder: \\\"_Data quality Titles\\\");\\n        newTitle.FormatDax();\\n        newTitle.SetAnnotation(annLabel, annValueDataQualityTitles + \\\"_\\\" + measureIndex.ToString());\\n        //add measure for subtitle saying how many need to be added to the dimension table\\n        string orphanTableSubtitleMeasureExpression =\\n            String.Format(\\n                @\\\"FORMAT({0}+0,\\\"\\\"{1}\\\"\\\") & \\\"\\\" values missing in \\\"\\\" & \\\"\\\"{2}\\\"\\\"\\\", \\n                newCounter.DaxObjectFullName, \\n                newCounter.FormatString, \\n                oneColumn.Table.Name);\\n        string orphanTableSubitleMeasureName = newCounter.Name + \\\" Subtitle\\\";\\n        Measure newSubtitle = tableToStoreMeasures.AddMeasure(name: orphanTableSubitleMeasureName, expression: orphanTableSubtitleMeasureExpression, displayFolder: \\\"_Data quality Subtitles\\\");\\n        newSubtitle.FormatDax();\\n        newSubtitle.SetAnnotation(annLabel, annValueDataQualitySubtitles + \\\"_\\\" + measureIndex.ToString());\\n        overallCounterExpression = overallCounterExpression + \\\"+\\\" + newCounter.DaxObjectFullName;\\n        overallDetailExpression = overallDetailExpression\\n                + \\\" & IF(\\\" + newCounter.DaxObjectFullName + \\\"> 0,\\\"\\n                            + newTitle.DaxObjectFullName + \\\" & UNICHAR(10))\\\";\\n    };\\n};\\nMeasure counter = tableToStoreMeasures.AddMeasure(name: overallCounterName, expression: overallCounterExpression);\\ncounter.FormatString = \\\"#,##0\\\";\\ncounter.FormatDax();\\ncounter.SetAnnotation(annLabel, annValueTotal);\\nMeasure descr = tableToStoreMeasures.AddMeasure(name: overallDetailName, expression: overallDetailExpression);\\ndescr.FormatDax();\\ndescr.SetAnnotation(annLabel, annValueDetail);\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Time Int Labels",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n// CHANGE LOG:\\n// '2021-10-16 / B.Agullo / converted to macro using code from Stephen Maguire and Daniel Otykier, and people in twitter helping with C#!  \\n// '2021-07-10 / B.Agullo / \\n// by Bernat Agulló\\n// www.esbrina-ba.com\\n\\n// FULL EXPLANATION: \\n// https://www.esbrina-ba.com/time-intelligence-dynamic-legend-in-line-charts/\\n\\n//this script creates an extra calculation group to work together with Time Calculation group \\n//you need to create the Time calculation group script with the dynamic label measures before running this script \\n//the names of the measure and affected measure table must match \\n//if you changed the default valures on the time intel calc group, change them heere too .\\n\\n\\nvar ts = Model.Tables.Where(x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Calc Group\\\");\\n\\nvar timeIntelCalcGroup = null as CalculationGroupTable; \\n\\nif (ts.Count() == 1 ) {\\n    timeIntelCalcGroup = ts.First() as CalculationGroupTable;\\n} else if (ts.Count() < 1) {\\n    Error(\\\"Time Itelligence Calc group script by @AgulloBernat has not been successfuly executed yet. Execute it first and then run again the present script\\\"); \\n    return; \\n} else { \\n    //this should never happen -- who needs two calc groups for time intelligence? \\n    timeIntelCalcGroup = SelectTable(ts, label:\\\"Select your existing time intelligence calc group calculation group table:\\\") as CalculationGroupTable;\\n};\\n\\nif (timeIntelCalcGroup == null) { return; } // doesn't work in TE3 as cancel button doesn't return null in TE3\\n\\n\\n//init Affected Measure Table\\nts = Model.Tables.Where(x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Affected Measures Table\\\");\\n\\nvar affectedMeasuresTable = null as Table; \\n\\nif (ts.Count() == 1 ) {\\n    affectedMeasuresTable = ts.First(); \\n} else if (ts.Count() < 1) {\\n    Error(\\\"Time Itelligence Calc group script by @AgulloBernat has not been successfuly executed yet. Execute it first and then run again the present script\\\"); \\n    return; \\n} else { \\n    //this should never happen -- who needs two time intelligence affected measures calc tables? \\n    affectedMeasuresTable = SelectTable(ts, label:\\\"Select your existing time intelligence affected measures table:\\\") as CalculationGroupTable;\\n};\\n\\nif (affectedMeasuresTable == null) { return; } // doesn't work in TE3 as cancel button doesn't return null in TE3\\n\\nstring labelsCalculationGroupName = Interaction.InputBox(\\\"Provide a name for the dynamic labels Calc Group\\\", \\\"Calc Group Name\\\", \\\"Labels\\\", 740, 400);\\nif(labelsCalculationGroupName == \\\"\\\") return;\\n\\nstring labelsCalculationGroupColumnName = Interaction.InputBox(\\\"Provide a name for the column of the Calc Group\\\", \\\"Calc Group Name\\\", labelsCalculationGroupName, 740, 400);\\nif(labelsCalculationGroupColumnName == \\\"\\\") return;\\n\\nstring labelsCalculationItemName = \\\"Last Point Time Calculation\\\"; \\n\\nstring affectedMeasuresTableName = \\\"Time Intelligence Affected Measures\\\"; //affectedMeasuresTable.Name; \\nstring affectedMeasuresColumnName = \\\"Measure\\\"; // affectedMeasuresTable.Columns[0].Name; \\n\\n//add the name of the existing time intel calc group here\\nstring calcGroupName = \\\"Time Intelligence\\\";\\n\\n//add the name for date table of the model\\nstring dateTableName = \\\"Date\\\";\\nstring dateTableDateColumnName = \\\"Date\\\";\\n\\nstring labelAsValueMeasureName = \\\"Label as Value Measure\\\"; \\n\\nstring flagExpression = \\\"UNICHAR( 8204 )\\\"; \\n\\n\\n//generates new calc group \\nvar calculationGroupTable1 = (Model.AddCalculationGroup(labelsCalculationGroupName) as CalculationGroupTable);\\n\\ncalculationGroupTable1.Description = \\\"Calculation group to manipulate data labels\\\"; \\n\\n//sees the default precedence number assigned \\nint labelGroupPrecedence = (Model.Tables[labelsCalculationGroupName] as CalculationGroupTable).CalculationGroup.Precedence;\\nint timeIntelGroupPrecedence = (Model.Tables[calcGroupName] as CalculationGroupTable).CalculationGroup.Precedence;\\n\\n//if time intel has lower precedence... \\nif(labelGroupPrecedence > timeIntelGroupPrecedence) {\\n    //...swap precedence values \\n    (Model.Tables[labelsCalculationGroupName] as CalculationGroupTable).CalculationGroup.Precedence = timeIntelGroupPrecedence;\\n    (Model.Tables[calcGroupName] as CalculationGroupTable).CalculationGroup.Precedence = labelGroupPrecedence; \\n}; \\n\\n\\n(Model.Tables[\\\"Labels\\\"].Columns[\\\"Name\\\"] as DataColumn).Name = labelsCalculationGroupColumnName;\\nvar calculationItem1 = calculationGroupTable1.AddCalculationItem(labelsCalculationItemName);\\ncalculationItem1.Expression = \\\"SELECTEDMEASURE()\\\";\\ncalculationItem1.FormatStringExpression =\\n\\\"SWITCH(\\\" + \\n\\\"\\n    TRUE(),\\\" + \\n\\\"\\n    SELECTEDMEASURENAME()\\\" + \\n\\\"\\n        IN VALUES( '\\\" + affectedMeasuresTableName + \\\"'[\\\" + affectedMeasuresColumnName + \\\"] ),\\\" + \\n\\\"\\n        VAR maxDateInVisual =\\\" + \\n\\\"\\n            CALCULATE( MAX( '\\\" + dateTableName + \\\"'[\\\" +dateTableDateColumnName + \\\"] ), ALLSELECTED( '\\\" + dateTableName + \\\"' ) )\\\" + \\n\\\"\\n        VAR maxDateInDataPoint =\\\" + \\n\\\"\\n            MAX( '\\\" + dateTableName + \\\"'[\\\" + dateTableDateColumnName + \\\"] )\\\" + \\n\\\"\\n        VAR result =\\\" + \\n\\\"\\n            IF( maxDateInDataPoint = maxDateInVisual, [\\\" + labelAsValueMeasureName +\\\"] )\\\" + \\n\\\"\\n        RETURN\\\" + \\n\\\"\\n           \\\" + flagExpression + \\\" & \\\\\"\\\\\"\\\\\"\\\\\" & result & \\\\\"\\\\\"\\\\\";\\\\\"\\\\\"\\\\\" & result & \\\\\"\\\\\"\\\\\";\\\\\"\\\\\"\\\\\" & result & \\\\\"\\\\\"\\\\\";\\\\\"\\\\\"\\\\\" & result & \\\\\"\\\\\"\\\\\"\\\\\",\\\" + \\n\\\"\\n    SELECTEDMEASUREFORMATSTRING()\\\" + \\n\\\"\\n)\\\";\\n\\ncalculationItem1.Description = \\\"Show dynamic label as data label of the last point in a line series over a time axis\\\"; \\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\One-Click Macros\\Time Intelligence Calculation Group Creation",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n//\\n// CHANGELOG:\\n// '2021-05-01 / B.Agullo / \\n// '2021-05-17 / B.Agullo / added affected measure table\\n// '2021-06-19 / B.Agullo / data label measures\\n// '2021-07-10 / B.Agullo / added flag expression to avoid breaking already special format strings\\n// '2021-09-23 / B.Agullo / added code to prompt for parameters (code credit to Daniel Otykier) \\n// '2021-09-27 / B.Agullo / added code for general name \\n// '2022-10-11 / B.Agullo / added MMT and MWT calc item groups\\n// '2023-01-24 / B.Agullo / added Date Range Measure and completed dynamic label for existing items\\n// '2025-05-14 / B.Agullo / some refactoring + month based standard calculations\\n//\\n// by Bernat Agulló\\n// twitter: @AgulloBernat\\n// www.esbrina-ba.com/blog\\n//\\n// REFERENCE: \\n// Check out https://www.esbrina-ba.com/time-intelligence-the-smart-way/ where this script is introduced\\n// \\n// FEATURED: \\n// this script featured in GuyInACube https://youtu.be/_j0iTUo2HT0\\n//\\n// THANKS:\\n// shout out to Johnny Winter for the base script and SQLBI for daxpatterns.com\\n//select the measures that you want to be affected by the calculation group\\n//before running the script. \\n//measure names can also be included in the following array (no need to select them) \\nstring[] preSelectedMeasures = { }; //include measure names in double quotes, like: {\\\"Profit\\\",\\\"Total Cost\\\"};\\n//AT LEAST ONE MEASURE HAS TO BE AFFECTED!, \\n//either by selecting it or typing its name in the preSelectedMeasures Variable\\n//\\n// ----- do not modify script below this line -----\\n//\\nstring affectedMeasures = \\\"{\\\";\\nint i = 0;\\nfor (i = 0; i < preSelectedMeasures.GetLength(0); i++)\\n{\\n    if (affectedMeasures == \\\"{\\\")\\n    {\\n        affectedMeasures = affectedMeasures + \\\"\\\\\"\\\" + preSelectedMeasures[i] + \\\"\\\\\"\\\";\\n    }\\n    else\\n    {\\n        affectedMeasures = affectedMeasures + \\\",\\\\\"\\\" + preSelectedMeasures[i] + \\\"\\\\\"\\\";\\n    };\\n};\\nif (Selected.Measures.Count != 0)\\n{\\n    foreach (var m in Selected.Measures)\\n    {\\n        if (affectedMeasures == \\\"{\\\")\\n        {\\n            affectedMeasures = affectedMeasures + \\\"\\\\\"\\\" + m.Name + \\\"\\\\\"\\\";\\n        }\\n        else\\n        {\\n            affectedMeasures = affectedMeasures + \\\",\\\\\"\\\" + m.Name + \\\"\\\\\"\\\";\\n        };\\n    };\\n};\\n//check that by either method at least one measure is affected\\nif (affectedMeasures == \\\"{\\\")\\n{\\n    Error(\\\"No measures affected by calc group\\\");\\n    return;\\n};\\nstring calcGroupName = String.Empty;\\nstring columnName = String.Empty;\\nif (Model.CalculationGroups.Any(cg => cg.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Calc Group\\\"))\\n{\\n    calcGroupName = Model.CalculationGroups.Where(cg => cg.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Calc Group\\\").First().Name;\\n}\\nelse\\n{\\n    calcGroupName = Interaction.InputBox(\\\"Provide a name for your Calc Group\\\", \\\"Calc Group Name\\\", \\\"Time Intelligence\\\", 740, 400);\\n};\\nif (calcGroupName == String.Empty) return;\\nif (Model.CalculationGroups.Any(cg => cg.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Calc Group\\\"))\\n{\\n    columnName = Model.Tables.Where(cg => cg.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Calc Group\\\").First().Columns.First().Name;\\n}\\nelse\\n{\\n    columnName = Interaction.InputBox(\\\"Provide a name for your Calc Group Column\\\", \\\"Calc Group Column Name\\\", calcGroupName, 740, 400);\\n};\\nif (columnName == String.Empty) return;\\nstring affectedMeasuresTableName = String.Empty;\\nif (Model.Tables.Any(t => t.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Affected Measures Table\\\"))\\n{\\n    affectedMeasuresTableName = Model.Tables.Where(t => t.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Affected Measures Table\\\").First().Name;\\n}\\nelse\\n{\\n    affectedMeasuresTableName = Interaction.InputBox(\\\"Provide a name for affected measures table\\\", \\\"Affected Measures Table Name\\\", calcGroupName + \\\" Affected Measures\\\", 740, 400);\\n};\\nif (affectedMeasuresTableName ==String.Empty) return;\\nstring affectedMeasuresColumnName = String.Empty;\\nif (Model.Tables.Any(t => t.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Affected Measures Table\\\"))\\n{\\n    affectedMeasuresColumnName = Model.Tables.Where(t => t.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Affected Measures Table\\\").First().Columns.First().Name;\\n}\\nelse\\n{\\n    affectedMeasuresColumnName = Interaction.InputBox(\\\"Provide a name for affected measures column\\\", \\\"Affected Measures Table Column Name\\\", \\\"Measure\\\", 740, 400);\\n};\\nif (affectedMeasuresColumnName == String.Empty) return;\\n//string affectedMeasuresColumnName = \\\"Measure\\\"; \\nstring labelAsValueMeasureName = \\\"Label as Value Measure\\\";\\nstring labelAsFormatStringMeasureName = \\\"Label as format string\\\";\\n// '2021-09-24 / B.Agullo / model object selection prompts! \\nvar factTable = SelectTable(label: \\\"Select your fact table\\\");\\nif (factTable == null) return;\\nvar factTableDateColumn = SelectColumn(factTable.Columns, label: \\\"Select the main date column\\\");\\nif (factTableDateColumn == null) return;\\nTable dateTableCandidate = null;\\nif (Model.Tables.Any\\n    (x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Date Table\\\"\\n        || x.Name == \\\"Date\\\"\\n        || x.Name == \\\"Calendar\\\"))\\n{\\n    dateTableCandidate = Model.Tables.Where\\n        (x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Date Table\\\"\\n            || x.Name == \\\"Date\\\"\\n            || x.Name == \\\"Calendar\\\").First();\\n};\\nvar dateTable =\\n    SelectTable(\\n        label: \\\"Select your date table\\\",\\n        preselect: dateTableCandidate);\\nif (dateTable == null)\\n{\\n    Error(\\\"You just aborted the script\\\");\\n    return;\\n}\\nelse\\n{\\n    dateTable.SetAnnotation(\\\"@AgulloBernat\\\", \\\"Time Intel Date Table\\\");\\n};\\nColumn dateTableDateColumnCandidate = null;\\nif (dateTable.Columns.Any\\n            (x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Date Table Date Column\\\" || x.Name == \\\"Date\\\"))\\n{\\n    dateTableDateColumnCandidate = dateTable.Columns.Where\\n        (x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Date Table Date Column\\\" || x.Name == \\\"Date\\\").First();\\n};\\nvar dateTableDateColumn =\\n    SelectColumn(\\n        dateTable.Columns,\\n        label: \\\"Select the date column\\\",\\n        preselect: dateTableDateColumnCandidate);\\nif (dateTableDateColumn == null)\\n{\\n    Error(\\\"You just aborted the script\\\");\\n    return;\\n}\\nelse\\n{\\n    dateTableDateColumn.SetAnnotation(\\\"@AgulloBernat\\\", \\\"Time Intel Date Table Date Column\\\");\\n};\\nColumn dateTableYearColumnCandidate = null;\\nif (dateTable.Columns.Any(x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Date Table Year Column\\\" || x.Name == \\\"Year\\\"))\\n{\\n    dateTable.Columns.Where\\n        (x => x.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Date Table Year Column\\\" || x.Name == \\\"Year\\\").First();\\n};\\nvar dateTableYearColumn =\\n    SelectColumn(\\n        dateTable.Columns,\\n        label: \\\"Select the year column\\\",\\n        preselect: dateTableYearColumnCandidate);\\nif (dateTableYearColumn == null)\\n{\\n    Error(\\\"You just abourted the script\\\");\\n    return;\\n}\\nelse\\n{\\n    dateTableYearColumn.SetAnnotation(\\\"@AgulloBernat\\\", \\\"Time Intel Date Table Year Column\\\");\\n};\\n//these names are for internal use only, so no need to be super-fancy, better stick to datpatterns.com model\\nstring ShowValueForDatesMeasureName = \\\"ShowValueForDates\\\";\\nstring dateWithSalesColumnName = \\\"DateWith\\\" + factTable.Name;\\n// '2021-09-24 / B.Agullo / I put the names back to variables so I don't have to tough the script\\nstring factTableName = factTable.Name;\\nstring factTableDateColumnName = factTableDateColumn.Name;\\nstring dateTableName = dateTable.Name;\\nstring dateTableDateColumnName = dateTableDateColumn.Name;\\nstring dateTableYearColumnName = dateTableYearColumn.Name;\\n// '2021-09-24 / B.Agullo / this is for internal use only so better leave it as is \\nstring flagExpression = \\\"UNICHAR( 8204 )\\\";\\nstring calcItemProtection = \\\"<CODE>\\\"; //default value if user has selected no measures\\nstring calcItemFormatProtection = \\\"<CODE>\\\"; //default value if user has selected no measures\\n// check if there's already an affected measure table\\nif (Model.Tables.Any(t => t.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Time Intel Affected Measures Table\\\"))\\n{\\n    //modifying an existing calculated table is not risk-free\\n    Info(\\\"Make sure to include measure names to the table \\\" + affectedMeasuresTableName);\\n}\\nelse\\n{\\n    // create calculated table containing all names of affected measures\\n    // this is why you need to enable \\n    if (affectedMeasures != \\\"{\\\")\\n    {\\n        affectedMeasures = affectedMeasures + \\\"}\\\";\\n        string affectedMeasureTableExpression =\\n            \\\"SELECTCOLUMNS(\\\" + affectedMeasures + \\\",\\\\\"\\\" + affectedMeasuresColumnName + \\\"\\\\\",[Value])\\\";\\n        var affectedMeasureTable =\\n            Model.AddCalculatedTable(affectedMeasuresTableName, affectedMeasureTableExpression);\\n        affectedMeasureTable.FormatDax();\\n        affectedMeasureTable.Description =\\n            \\\"Measures affected by \\\" + calcGroupName + \\\" calculation group.\\\";\\n        affectedMeasureTable.SetAnnotation(\\\"@AgulloBernat\\\", \\\"Time Intel Affected Measures Table\\\");\\n        // this causes error\\n        // affectedMeasureTable.Columns[affectedMeasuresColumnName].SetAnnotation(\\\"@AgulloBernat\\\",\\\"Time Intel Affected Measures Table Column\\\");\\n        affectedMeasureTable.IsHidden = true;\\n    };\\n};\\n//if there where selected or preselected measures, prepare protection code for expresion and formatstring\\nstring affectedMeasuresValues = \\\"VALUES('\\\" + affectedMeasuresTableName + \\\"'[\\\" + affectedMeasuresColumnName + \\\"])\\\";\\ncalcItemProtection =\\n    \\\"SWITCH(\\\" +\\n    \\\"   TRUE(),\\\" +\\n    \\\"   SELECTEDMEASURENAME() IN \\\" + affectedMeasuresValues + \\\",\\\" +\\n    \\\"   <CODE> ,\\\" +\\n    \\\"   ISSELECTEDMEASURE([\\\" + labelAsValueMeasureName + \\\"]),\\\" +\\n    \\\"   <LABELCODE> ,\\\" +\\n    \\\"   SELECTEDMEASURE() \\\" +\\n    \\\")\\\";\\ncalcItemFormatProtection =\\n    \\\"SWITCH(\\\" +\\n    \\\"   TRUE() ,\\\" +\\n    \\\"   SELECTEDMEASURENAME() IN \\\" + affectedMeasuresValues + \\\",\\\" +\\n    \\\"   <CODE> ,\\\" +\\n    \\\"   ISSELECTEDMEASURE([\\\" + labelAsFormatStringMeasureName + \\\"]),\\\" +\\n    \\\"   <LABELCODEFORMATSTRING> ,\\\" +\\n    \\\"   SELECTEDMEASUREFORMATSTRING() \\\" +\\n    \\\")\\\";\\nstring dateColumnWithTable = \\\"'\\\" + dateTableName + \\\"'[\\\" + dateTableDateColumnName + \\\"]\\\";\\nstring yearColumnWithTable = \\\"'\\\" + dateTableName + \\\"'[\\\" + dateTableYearColumnName + \\\"]\\\";\\nstring factDateColumnWithTable = \\\"'\\\" + factTableName + \\\"'[\\\" + factTableDateColumnName + \\\"]\\\";\\nstring dateWithSalesWithTable = \\\"'\\\" + dateTableName + \\\"'[\\\" + dateWithSalesColumnName + \\\"]\\\";\\nstring calcGroupColumnWithTable = \\\"'\\\" + calcGroupName + \\\"'[\\\" + columnName + \\\"]\\\";\\n//check to see if a table with this name already exists\\n//if it doesnt exist, create a calculation group with this name\\nif (!Model.Tables.Contains(calcGroupName))\\n{\\n    var cg = Model.AddCalculationGroup(calcGroupName);\\n    cg.Description = \\\"Calculation group for time intelligence. Availability of data is taken from \\\" + factTableName + \\\".\\\";\\n    cg.SetAnnotation(\\\"@AgulloBernat\\\", \\\"Time Intel Calc Group\\\");\\n};\\n//set variable for the calc group\\nTable calcGroup = Model.Tables[calcGroupName];\\n//if table already exists, make sure it is a Calculation Group type\\nif (calcGroup.SourceType.ToString() != \\\"CalculationGroup\\\")\\n{\\n    Error(\\\"Table exists in Model but is not a Calculation Group. Rename the existing table or choose an alternative name for your Calculation Group.\\\");\\n    return;\\n};\\n//adds the two measures that will be used for label as value, label as format string \\nvar labelAsValueMeasure = calcGroup.AddMeasure(labelAsValueMeasureName, \\\"\\\");\\nlabelAsValueMeasure.Description = \\\"Use this measure to show the year evaluated in tables\\\";\\nvar labelAsFormatStringMeasure = calcGroup.AddMeasure(labelAsFormatStringMeasureName, \\\"0\\\");\\nlabelAsFormatStringMeasure.Description = \\\"Use this measure to show the year evaluated in charts\\\";\\n//by default the calc group has a column called Name. If this column is still called Name change this in line with specfied variable\\nif (calcGroup.Columns.Contains(\\\"Name\\\"))\\n{\\n    calcGroup.Columns[\\\"Name\\\"].Name = columnName;\\n};\\ncalcGroup.Columns[columnName].Description = \\\"Select value(s) from this column to apply time intelligence calculations.\\\";\\ncalcGroup.Columns[columnName].SetAnnotation(\\\"@AgulloBernat\\\", \\\"Time Intel Calc Group Column\\\");\\n//Only create them if not in place yet (reruns)\\nif (!Model.Tables[dateTableName].Columns.Any(C => C.GetAnnotation(\\\"@AgulloBernat\\\") == \\\"Date with Data Column\\\"))\\n{\\n    string DateWithSalesCalculatedColumnExpression =\\n        dateColumnWithTable + \\\" <= MAX ( \\\" + factDateColumnWithTable + \\\")\\\";\\n    Column dateWithDataColumn = dateTable.AddCalculatedColumn(dateWithSalesColumnName, DateWithSalesCalculatedColumnExpression);\\n    dateWithDataColumn.SetAnnotation(\\\"@AgulloBernat\\\", \\\"Date with Data Column\\\");\\n};\\nif (!Model.Tables[dateTableName].Measures.Any(M => M.Name == ShowValueForDatesMeasureName))\\n{\\n    string ShowValueForDatesMeasureExpression = String.Format(\\n        @\\\"VAR LastDateWithData = \\n            CALCULATE(\\n                MAX({0}),\\n                REMOVEFILTERS()\\n            )\\n        VAR FirstDateVisible = \\n            MIN({1})\\n        VAR Result = \\n            FirstDateVisible <= LastDateWithData\\n        RETURN \\n            Result\\\",\\n        factDateColumnWithTable,\\n        dateColumnWithTable\\n    );\\n    var ShowValueForDatesMeasure = dateTable.AddMeasure(ShowValueForDatesMeasureName, ShowValueForDatesMeasureExpression);\\n    ShowValueForDatesMeasure.FormatDax();\\n};\\n// Defining expressions and format strings for each calc item\\nstring CY = @\\\"/*CY*/ SELECTEDMEASURE()\\\";\\nstring CYlabel = String.Format(@\\\"SELECTEDVALUE({0})\\\", yearColumnWithTable);\\nstring PY = String.Format(\\n    @\\\"/*PY*/ \\n    IF (\\n        [{0}], \\n        CALCULATE ( \\n            {1}, \\n            CALCULATETABLE ( \\n                DATEADD ( {2}, -1, YEAR ), \\n                {3} = TRUE \\n            ) \\n        ) \\n    )\\\", \\n    ShowValueForDatesMeasureName, CY, dateColumnWithTable, dateWithSalesWithTable);\\nstring PYlabel = String.Format(\\n    @\\\"/*PY*/ \\n    IF (\\n        [{0}], \\n        CALCULATE ( \\n            {1}, \\n            CALCULATETABLE ( \\n                DATEADD ( {2}, -1, YEAR ), \\n                {3} = TRUE \\n            ) \\n        ) \\n    )\\\", \\n    ShowValueForDatesMeasureName, CYlabel, dateColumnWithTable, dateWithSalesWithTable);\\nstring YOY = String.Format(\\n    @\\\"/*YOY*/ \\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR Result = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod - ValuePreviousPeriod\\n    ) \\n    RETURN \\n       Result\\\", \\n    CY, PY);\\nstring YOYlabel = String.Format(\\n    @\\\"/*YOY*/ \\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR Result = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod\\n    ) \\n    RETURN \\n       Result\\\", \\n    CYlabel, PYlabel);\\nstring YOYpct = String.Format(\\n    @\\\"/*YOY%*/ \\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR CurrentMinusPreviousPeriod = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod - ValuePreviousPeriod\\n    ) \\n    VAR Result = \\n    DIVIDE ( \\n        CurrentMinusPreviousPeriod,\\n        ValuePreviousPeriod\\n    ) \\n    RETURN \\n      Result\\\", \\n    CY, PY);\\nstring YOYpctLabel = String.Format(\\n    @\\\"/*YOY%*/ \\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR Result = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod & \\\"\\\" (%)\\\"\\\"\\n    ) \\n    RETURN \\n      Result\\\", \\n    CYlabel, PYlabel);\\nstring YTD = String.Format(\\n    @\\\"/*YTD*/\\n    IF (\\n        [{0}],\\n        CALCULATE (\\n            {1},\\n            DATESYTD ({2})\\n       )\\n    )\\\", \\n    ShowValueForDatesMeasureName, CY, dateColumnWithTable);\\nstring YTDlabel = String.Format(@\\\"{0} & \\\"\\\" YTD\\\"\\\"\\\", CYlabel);\\nstring PYTD = String.Format(\\n    @\\\"/*PYTD*/\\n    IF ( \\n        [{0}], \\n       CALCULATE ( \\n           {1},\\n        CALCULATETABLE ( \\n            DATEADD ( {2}, -1, YEAR ), \\n           {3} = TRUE \\n           )\\n       )\\n    )\\\", \\n    ShowValueForDatesMeasureName, YTD, dateColumnWithTable, dateWithSalesWithTable);\\nstring PYTDlabel = String.Format(@\\\"{0} & \\\"\\\" YTD\\\"\\\"\\\", PYlabel);\\nstring YOYTD = String.Format(\\n    @\\\"/*YOYTD*/\\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR Result = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod - ValuePreviousPeriod\\n    ) \\n    RETURN \\n       Result\\\", \\n    YTD, PYTD);\\nstring YOYTDlabel = String.Format(\\n    @\\\"/*YOYTD*/\\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR Result = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod\\n    ) \\n    RETURN \\n       Result\\\", \\n    YTDlabel, PYTDlabel);\\nstring YOYTDpct = String.Format(\\n    @\\\"/*YOYTD%*/\\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR CurrentMinusPreviousPeriod = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod - ValuePreviousPeriod\\n    ) \\n    VAR Result = \\n    DIVIDE ( \\n        CurrentMinusPreviousPeriod,\\n        ValuePreviousPeriod\\n    ) \\n    RETURN \\n      Result\\\", \\n    YTD, PYTD);\\nstring YOYTDpctLabel = String.Format(\\n    @\\\"/*YOY%*/ \\n    VAR ValueCurrentPeriod = {0} \\n    VAR ValuePreviousPeriod = {1} \\n    VAR Result = \\n    IF ( \\n        NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n        ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod & \\\"\\\" (%)\\\"\\\"\\n    ) \\n    RETURN \\n      Result\\\", \\n    YTDlabel, PYTDlabel);\\n    string CM = @\\\"/*CM*/ SELECTEDMEASURE()\\\";\\n    string CMlabel = String.Format(@\\\"SELECTEDVALUE({0}, \\\"\\\"Current Month\\\"\\\")\\\", dateColumnWithTable);\\n    string PM = String.Format(\\n        @\\\"/*PM*/ \\n        IF (\\n            [{0}], \\n            CALCULATE ( \\n                {1}, \\n                CALCULATETABLE ( \\n                    DATEADD ( {2}, -1, MONTH ), \\n                    {3} = TRUE \\n                ) \\n            ) \\n        )\\\", \\n        ShowValueForDatesMeasureName, CM, dateColumnWithTable, dateWithSalesWithTable);\\n    string PMlabel = String.Format(\\n        @\\\"/*PM*/ \\n        IF (\\n            [{0}], \\n            CALCULATE ( \\n                {1}, \\n                CALCULATETABLE ( \\n                    DATEADD ( {2}, -1, MONTH ), \\n                    {3} = TRUE \\n                ) \\n            ) \\n        )\\\", \\n        ShowValueForDatesMeasureName, CMlabel, dateColumnWithTable, dateWithSalesWithTable);\\n    string MOM = String.Format(\\n        @\\\"/*MOM*/ \\n        VAR ValueCurrentPeriod = {0} \\n        VAR ValuePreviousPeriod = {1} \\n        VAR Result = \\n        IF ( \\n            NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n            ValueCurrentPeriod - ValuePreviousPeriod\\n        ) \\n        RETURN \\n           Result\\\", \\n        CM, PM);\\n    string MOMlabel = String.Format(\\n        @\\\"/*MOM*/ \\n        VAR ValueCurrentPeriod = {0} \\n        VAR ValuePreviousPeriod = {1} \\n        VAR Result = \\n        IF ( \\n            NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n            ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod\\n        ) \\n        RETURN \\n           Result\\\", \\n        CMlabel, PMlabel);\\n    string MOMpct = String.Format(\\n        @\\\"/*MOM%*/ \\n        VAR ValueCurrentPeriod = {0} \\n        VAR ValuePreviousPeriod = {1} \\n        VAR CurrentMinusPreviousPeriod = \\n        IF ( \\n            NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n            ValueCurrentPeriod - ValuePreviousPeriod\\n        ) \\n        VAR Result = \\n        DIVIDE ( \\n            CurrentMinusPreviousPeriod,\\n            ValuePreviousPeriod\\n        ) \\n        RETURN \\n          Result\\\", \\n        CM, PM);\\n    string MOMpctLabel = String.Format(\\n        @\\\"/*MOM%*/ \\n        VAR ValueCurrentPeriod = {0} \\n        VAR ValuePreviousPeriod = {1} \\n        VAR Result = \\n        IF ( \\n            NOT ISBLANK ( ValueCurrentPeriod ) && NOT ISBLANK ( ValuePreviousPeriod ), \\n            ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod & \\\"\\\" (%)\\\"\\\"\\n        ) \\n        RETURN \\n          Result\\\", \\n        CMlabel, PMlabel);\\n        string MTD = String.Format(\\n            @\\\"/*MTD*/\\n            IF (\\n                [{0}],\\n                CALCULATE (\\n                    SELECTEDMEASURE(),\\n                    DATESMTD({1})\\n                )\\n            )\\\",\\n            ShowValueForDatesMeasureName, dateColumnWithTable);\\n        string MTDlabel = String.Format(\\n            @\\\"/*MTD*/\\n            IF (\\n                [{0}],\\n                CALCULATE (\\n                    \\\"\\\"Month to date\\\"\\\",\\n                    DATESMTD({1})\\n                )\\n            )\\\",\\n            ShowValueForDatesMeasureName, dateColumnWithTable);\\n        string PMTD = String.Format(\\n            @\\\"/*PMTD*/\\n            IF (\\n                [{0}],\\n                CALCULATE (\\n                    SELECTEDMEASURE(),\\n                    DATESMTD(DATEADD({1}, -1, MONTH))\\n                )\\n            )\\\",\\n            ShowValueForDatesMeasureName, dateColumnWithTable);\\n        string PMTDlabel = String.Format(\\n            @\\\"/*PMTD*/\\n            IF (\\n                [{0}],\\n                CALCULATE (\\n                    \\\"\\\"Previous month to date\\\"\\\",\\n                    DATESMTD(DATEADD({1}, -1, MONTH))\\n                )\\n            )\\\",\\n            ShowValueForDatesMeasureName, dateColumnWithTable);\\n        string MOMTD = String.Format(\\n            @\\\"/*MOMTD*/\\n            VAR ValueCurrentPeriod = {0}\\n            VAR ValuePreviousPeriod = {1}\\n            VAR Result =\\n                IF (\\n                    NOT ISBLANK(ValueCurrentPeriod) && NOT ISBLANK(ValuePreviousPeriod),\\n                    ValueCurrentPeriod - ValuePreviousPeriod\\n                )\\n            RETURN\\n                Result\\\",\\n            MTD, PMTD);\\n        string MOMTDlabel = String.Format(\\n            @\\\"/*MOMTD*/\\n            VAR ValueCurrentPeriod = {0}\\n            VAR ValuePreviousPeriod = {1}\\n            VAR Result =\\n                IF (\\n                    NOT ISBLANK(ValueCurrentPeriod) && NOT ISBLANK(ValuePreviousPeriod),\\n                    ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod\\n                )\\n            RETURN\\n                Result\\\",\\n            MTDlabel, PMTDlabel);\\n        string MOMTDpct = String.Format(\\n            @\\\"/*MOMTD%*/\\n            VAR ValueCurrentPeriod = {0}\\n            VAR ValuePreviousPeriod = {1}\\n            VAR CurrentMinusPreviousPeriod =\\n                IF (\\n                    NOT ISBLANK(ValueCurrentPeriod) && NOT ISBLANK(ValuePreviousPeriod),\\n                    ValueCurrentPeriod - ValuePreviousPeriod\\n                )\\n            VAR Result =\\n                DIVIDE(\\n                    CurrentMinusPreviousPeriod,\\n                    ValuePreviousPeriod\\n                )\\n            RETURN\\n                Result\\\",\\n            MTD, PMTD);\\n        string MOMTDpctlabel = String.Format(\\n            @\\\"/*MOMTD%*/\\n            VAR ValueCurrentPeriod = {0}\\n            VAR ValuePreviousPeriod = {1}\\n            VAR Result =\\n                IF (\\n                    NOT ISBLANK(ValueCurrentPeriod) && NOT ISBLANK(ValuePreviousPeriod),\\n                    ValueCurrentPeriod & \\\"\\\" vs \\\"\\\" & ValuePreviousPeriod & \\\"\\\" (%)\\\"\\\"\\n                )\\n            RETURN\\n                Result\\\",\\n            MTDlabel, PMTDlabel);\\nstring MAT = String.Format(@\\\"\\n/*TAM*/\\nIF (\\n    [{0}],\\n    CALCULATE (\\n        SELECTEDMEASURE(),\\n        DATESINPERIOD (\\n{1},\\nMAX({1}),\\n-1,\\nYEAR\\n        )\\n    )\\n)\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MATlabel = String.Format(@\\\"\\n/*TAM*/\\nIF (\\n    [{0}],\\n    CALCULATE (\\n        \\\"\\\"Year ending \\\"\\\" & FORMAT(MAX('Date'[Date]), \\\"\\\"d-MMM-yyyy\\\"\\\", \\\"\\\"en-US\\\"\\\"),\\n        DATESINPERIOD (\\n{1},\\nMAX({1}),\\n-1,\\nYEAR\\n        )\\n    )\\n)\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MATminus1 = String.Format(@\\\"\\n/*TAM*/\\nIF (\\n    [{0}],\\n    CALCULATE (\\n        SELECTEDMEASURE(),\\n        DATESINPERIOD (\\n{1},\\nLASTDATE(DATEADD({1}, -1, YEAR)),\\n-1,\\nYEAR\\n        )\\n    )\\n)\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MATminus1label = String.Format(@\\\"\\n/*MAT-1*/\\nIF (\\n    [{0}],\\n    CALCULATE (\\n        \\\"\\\"Year ending \\\"\\\" & FORMAT(MAX('Date'[Date]), \\\"\\\"d-MMM-yyyy\\\"\\\", \\\"\\\"en-US\\\"\\\"),\\n        DATESINPERIOD (\\n{1},\\nLASTDATE(DATEADD({1}, -1, YEAR)),\\n-1,\\nYEAR\\n        )\\n    )\\n)\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MATvsMATminus1 = String.Format(@\\\"\\n/*MAT vs MAT-1*/\\nVAR MAT = {0}\\nVAR MAT_1 = {1}\\nRETURN \\n    IF(ISBLANK(MAT) || ISBLANK(MAT_1), BLANK(), MAT - MAT_1)\\n\\\", MAT, MATminus1);\\nstring MATvsMATminus1label = String.Format(@\\\"\\n/*MAT vs MAT-1*/\\nVAR MAT = {0}\\nVAR MAT_1 = {1}\\nRETURN \\n    IF(ISBLANK(MAT) || ISBLANK(MAT_1), BLANK(), MAT & \\\"\\\" vs \\\"\\\" & MAT_1)\\n\\\", MATlabel, MATminus1label);\\nstring MATvsMATminus1pct = String.Format(@\\\"\\n/*MAT vs MAT-1(%)*/\\nVAR MAT = {0}\\nVAR MAT_1 = {1}\\nRETURN\\n    IF(\\n        ISBLANK(MAT) || ISBLANK(MAT_1),\\n        BLANK(),\\n        DIVIDE(MAT - MAT_1, MAT_1)\\n    )\\n\\\", MAT, MATminus1);\\nstring MATvsMATminus1pctlabel = String.Format(@\\\"\\n/*MAT vs MAT-1 (%)*/\\nVAR MAT = {0}\\nVAR MAT_1 = {1}\\nRETURN \\n    IF(ISBLANK(MAT) || ISBLANK(MAT_1), BLANK(), MAT & \\\"\\\" vs \\\"\\\" & MAT_1 & \\\"\\\" (%)\\\"\\\")\\n\\\", MATlabel, MATminus1label);\\nstring MMT = String.Format(\\n    @\\\"/*MMT*/\\n        IF(\\n[{0}],\\nCALCULATE( SELECTEDMEASURE( ), DATESINPERIOD( {1}, MAX( {1} ), -1, MONTH ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MMTlabel = String.Format(\\n    @\\\"/*MMT*/\\n        IF(\\n[{0}],\\nCALCULATE( {2}, DATESINPERIOD( {1}, MAX( {1} ), -1, MONTH ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable, \\\"\\\\\"Month ending \\\\\" & FORMAT(MAX( 'Date'[Date] ),\\\\\"d-MMM-yyyy\\\\\",\\\\\"en-US\\\\\")\\\");\\nstring MMTminus1 = String.Format(\\n    @\\\"/*MMT*/\\n        IF(\\n[{0}],\\nCALCULATE( SELECTEDMEASURE( ), DATESINPERIOD( {1}, LASTDATE( DATEADD( {1}, -1, MONTH ) ), -1, MONTH ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MMTminus1label = String.Format(\\n    @\\\"/*MMT-1*/\\n        IF(\\n[{0}],\\nCALCULATE( {2}, DATESINPERIOD( {1}, LASTDATE( DATEADD( {1}, -1, MONTH ) ), -1, MONTH ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable, \\\"\\\\\"Month ending \\\\\" & FORMAT(MAX( 'Date'[Date] ),\\\\\"d-MMM-yyyy\\\\\",\\\\\"en-US\\\\\")\\\");\\nstring MMTvsMMTminus1 = String.Format(\\n    @\\\"/*MMT vs MMT-1*/\\n    VAR MMT = {0}\\n    VAR MMT_1 = {1}\\n    RETURN \\n        IF( ISBLANK( MMT ) || ISBLANK( MMT_1 ), BLANK(), MMT - MMT_1 )\\\",\\n    MMT, MMTminus1);\\nstring MMTvsMMTminus1label = String.Format(\\n    @\\\"/*MMT vs MMT-1*/\\n    VAR MMT = {0}\\n    VAR MMT_1 = {1}\\n    RETURN \\n        IF( ISBLANK( MMT ) || ISBLANK( MMT_1 ), BLANK(), MMT & \\\"\\\" vs \\\"\\\" & MMT_1 )\\\",\\n    MMTlabel, MMTminus1label);\\nstring MMTvsMMTminus1pct = String.Format(\\n    @\\\"/*MMT vs MMT-1(%)*/\\n    VAR MMT = {0}\\n    VAR MMT_1 = {1}\\n    RETURN \\n        IF(\\n            ISBLANK( MMT ) || ISBLANK( MMT_1 ),\\n            BLANK(),\\n            DIVIDE( MMT - MMT_1, MMT_1 )\\n        )\\\",\\n    MMT, MMTminus1);\\nstring MMTvsMMTminus1pctlabel = String.Format(\\n    @\\\"/*MMT vs MMT-1(%)*/\\n    VAR MMT = {0}\\n    VAR MMT_1 = {1}\\n    RETURN \\n        IF( ISBLANK( MMT ) || ISBLANK( MMT_1 ), BLANK(), MMT & \\\"\\\" vs \\\"\\\" & MMT_1 & \\\"\\\" (%)\\\"\\\")\\\",\\n    MMTlabel, MMTminus1label);\\nstring MWT = String.Format(\\n        @\\\"/*MWT*/\\n        IF(\\n[{0}],\\nCALCULATE( SELECTEDMEASURE( ), DATESINPERIOD( {1}, MAX( {1} ), -7, DAY ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MWTlabel = \\\"/*MWT*/\\\" +\\n    String.Format(\\n        @\\\"/*MWT*/\\n        IF(\\n[{0}],\\nCALCULATE( {2}, DATESINPERIOD( {1}, MAX( {1} ), -7, DAY ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable, \\\"\\\\\"Week ending \\\\\" & FORMAT(MAX( 'Date'[Date] ),\\\\\"d-MMM-yyyy\\\\\",\\\\\"en-US\\\\\")\\\"); ;\\nstring MWTminus1 = String.Format(\\n        @\\\"/*MWT*/\\n        IF(\\n[{0}],\\nCALCULATE( SELECTEDMEASURE( ), DATESINPERIOD( {1}, LASTDATE( DATEADD( {1}, -7, DAY ) ), -7, DAY ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable);\\nstring MWTminus1label = \\\"/*MWT-1*/\\\" +\\n    String.Format(\\n        @\\\"/*MWT*/\\n        IF(\\n[{0}],\\nCALCULATE( {2}, DATESINPERIOD( {1}, LASTDATE( DATEADD( {1}, -7, DAY ) ), -7, DAY ) )\\n        )\\\", ShowValueForDatesMeasureName, dateColumnWithTable, \\\"\\\\\"Week ending \\\\\" & FORMAT(MAX( 'Date'[Date] ),\\\\\"d-MMM-yyyy\\\\\",\\\\\"en-US\\\\\")\\\");\\nstring MWTvsMWTminus1 = String.Format(\\n    @\\\"/*MWT vs MWT-1*/\\n    VAR MWT = {0}\\n    VAR MWT_1 = {1}\\n    RETURN \\n        IF( ISBLANK( MWT ) || ISBLANK( MWT_1 ), BLANK(), MWT - MWT_1 )\\\",\\n    MWT, MWTminus1);\\nstring MWTvsMWTminus1label = String.Format(\\n    @\\\"/*MWT vs MWT-1*/\\n    VAR MWT = {0}\\n    VAR MWT_1 = {1}\\n    RETURN \\n        IF( ISBLANK( MWT ) || ISBLANK( MWT_1 ), BLANK(), MWT & \\\"\\\" vs \\\"\\\" & MWT_1 )\\\",\\n    MWTlabel, MWTminus1label);\\nstring MWTvsMWTminus1pct = String.Format(\\n    @\\\"/*MWT vs MWT-1(%)*/\\n    VAR MWT = {0}\\n    VAR MWT_1 = {1}\\n    RETURN\\n        IF(\\n            ISBLANK( MWT ) || ISBLANK( MWT_1 ),\\n            BLANK(),\\n            DIVIDE( MWT - MWT_1, MWT_1 )\\n        )\\\",\\n    MWT, MWTminus1);\\nstring MWTvsMWTminus1pctlabel = String.Format(\\n    @\\\"/*MWT vs MWT-1 (%)*/\\n    VAR MWT = {0}\\n    VAR MWT_1 = {1}\\n    RETURN \\n        IF( ISBLANK( MWT ) || ISBLANK( MWT_1 ), BLANK(), MWT & \\\"\\\" vs \\\"\\\" & MWT_1 & \\\"\\\" (%)\\\"\\\")\\\",\\n    MWTlabel, MWTminus1label);\\nstring defFormatString = \\\"SELECTEDMEASUREFORMATSTRING()\\\";\\n//if the flag expression is already present in the format string, do not change it, otherwise apply % format. \\nstring pctFormatString = String.Format(\\n    @\\\"IF(\\n        FIND( {0}, SELECTEDMEASUREFORMATSTRING(), 1, -1 ) <> -1,\\n        SELECTEDMEASUREFORMATSTRING(),\\n        \\\"\\\"#,##0.# %\\\"\\\"\\n    )\\\",\\n    flagExpression);\\n//the order in the array also determines the ordinal position of the item    \\nstring[,] calcItems =\\n    {\\n        {\\\"CY\\\",      CY,         defFormatString,    \\\"Current year\\\",             CYlabel},\\n        {\\\"PY\\\",      PY,         defFormatString,    \\\"Previous year\\\",            PYlabel},\\n        {\\\"YOY\\\",     YOY,        defFormatString,    \\\"Year-over-year\\\",           YOYlabel},\\n        {\\\"YOY%\\\",    YOYpct,     pctFormatString,    \\\"Year-over-year%\\\",          YOYpctLabel},\\n        {\\\"YTD\\\",     YTD,        defFormatString,    \\\"Year-to-date\\\",             YTDlabel},\\n        {\\\"PYTD\\\",    PYTD,       defFormatString,    \\\"Previous year-to-date\\\",    PYTDlabel},\\n        {\\\"YOYTD\\\",   YOYTD,      defFormatString,    \\\"Year-over-year-to-date\\\",   YOYTDlabel},\\n        {\\\"YOYTD%\\\",  YOYTDpct,   pctFormatString,    \\\"Year-over-year-to-date%\\\",  YOYTDpctLabel},\\n        {\\\"CM\\\",      CM,         defFormatString,    \\\"Current month\\\",             CMlabel},\\n        {\\\"PM\\\",      PM,         defFormatString,    \\\"Previous month\\\",            PMlabel},\\n        {\\\"MOM\\\",     MOM,        defFormatString,    \\\"Month-over-month\\\",          MOMlabel},\\n        {\\\"MOM%\\\",    MOMpct,     pctFormatString,    \\\"Month-over-month%\\\",         MOMpctLabel},\\n        {\\\"MTD\\\",     MTD,        defFormatString,    \\\"Month-to-date\\\",             MTDlabel},\\n        {\\\"PMTD\\\",    PMTD,       defFormatString,    \\\"Previous month-to-date\\\",    PMTDlabel},\\n        {\\\"MOMTD\\\",   MOMTD,      defFormatString,    \\\"Month-over-month-to-date\\\",  MOMTDlabel},\\n        {\\\"MOMTD%\\\",  MOMTDpct,   pctFormatString,    \\\"Month-over-month-to-date%\\\", MOMTDpctlabel},\\n        {\\\"MAT\\\",     MAT,        defFormatString,    \\\"Moving Anual Total\\\",       MATlabel},\\n        {\\\"MAT-1\\\",   MATminus1,  defFormatString,    \\\"Moving Anual Total -1 year\\\", MATminus1label},\\n        {\\\"MAT vs MAT-1\\\", MATvsMATminus1, defFormatString, \\\"Moving Anual Total vs Moving Anual Total -1 year\\\", MATvsMATminus1label},\\n        {\\\"MAT vs MAT-1(%)\\\", MATvsMATminus1pct, pctFormatString, \\\"Moving Anual Total vs Moving Anual Total -1 year (%)\\\", MATvsMATminus1pctlabel},\\n        {\\\"MMT\\\",     MMT,        defFormatString,    \\\"Moving Monthly Total\\\",       MMTlabel},\\n        {\\\"MMT-1\\\",   MMTminus1,  defFormatString,    \\\"Moving Monthly Total -1 month\\\", MMTminus1label},\\n        {\\\"MMT vs MMT-1\\\", MMTvsMMTminus1, defFormatString, \\\"Moving Monthly Total vs Moving Monthly Total -1 month\\\", MMTvsMMTminus1label},\\n        {\\\"MMT vs MMT-1(%)\\\", MMTvsMMTminus1pct, pctFormatString, \\\"Moving Monthly Total vs Moving Monthly Total -1 month (%)\\\", MMTvsMMTminus1pctlabel},\\n        {\\\"MWT\\\",     MWT,        defFormatString,    \\\"Moving Weekly Total\\\",       MWTlabel},\\n        {\\\"MWT-1\\\",   MWTminus1,  defFormatString,    \\\"Moving Weekly Total -1 week\\\", MWTminus1label},\\n        {\\\"MWT vs MWT-1\\\", MWTvsMWTminus1, defFormatString, \\\"Moving Weekly Total vs Moving Weekly Total -1 month\\\", MWTvsMWTminus1label},\\n        {\\\"MWT vs MWT-1(%)\\\", MWTvsMWTminus1pct, pctFormatString, \\\"Moving Weekly Total vs Moving Weekly Total -1 week (%)\\\", MWTvsMWTminus1pctlabel}\\n    };\\nint j = 0;\\n//create calculation items for each calculation with formatstring and description\\nforeach (var cg in Model.CalculationGroups)\\n{\\n    if (cg.Name == calcGroupName)\\n    {\\n        for (j = 0; j < calcItems.GetLength(0); j++)\\n        {\\n            string itemName = calcItems[j, 0];\\n            string itemExpression = calcItemProtection.Replace(\\\"<CODE>\\\", calcItems[j, 1]);\\n            itemExpression = itemExpression.Replace(\\\"<LABELCODE>\\\", calcItems[j, 4]);\\n            string itemFormatExpression = calcItemFormatProtection.Replace(\\\"<CODE>\\\", calcItems[j, 2]);\\n            itemFormatExpression = itemFormatExpression.Replace(\\\"<LABELCODEFORMATSTRING>\\\", \\\"\\\\\"\\\\\"\\\\\"\\\\\" & \\\" + calcItems[j, 4] + \\\" & \\\\\"\\\\\"\\\\\"\\\\\"\\\");\\n            //if(calcItems[j,2] != defFormatString) {\\n            //    itemFormatExpression = calcItemFormatProtection.Replace(\\\"<CODE>\\\",calcItems[j,2]);\\n            //};\\n            string itemDescription = calcItems[j, 3];\\n            if (!cg.CalculationItems.Contains(itemName))\\n            {\\n                var nCalcItem = cg.AddCalculationItem(itemName, itemExpression);\\n                nCalcItem.FormatStringExpression = itemFormatExpression;\\n                nCalcItem.FormatDax();\\n                nCalcItem.Ordinal = j;\\n                nCalcItem.Description = itemDescription;\\n            };\\n        };\\n    };\\n};\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\Report Layer Macros\\Add Bilingual Layer Visuals",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\n\\n\\nusing Microsoft.VisualBasic;\\nusing System.IO;\\nusing Newtonsoft.Json.Linq;\\n//2025-06-23/B.Agullo\\n//this script adds a bilingual layer to the report, allowing the user to select the language of the report.\\n//this will only prepare the report for an extraction of the definition as descrived in https://www.esbrina-ba.com/transforming-a-regular-report-into-a-bilingual-one-part-2-extracting-display-names-of-measures-and-field-prameters/\\nReportExtended report = Rx.InitReport();\\nif (report == null) return;\\nstring altTextFlag = Fx.GetNameFromUser(\\n    Prompt: \\\"Enter the flag for the original language (e.g., 'EN' for English):\\\",\\n    Title: \\\"Alternative Language Flag\\\",\\n    DefaultResponse: \\\"EN\\\"\\n);\\nif (string.IsNullOrEmpty(altTextFlag))\\n{\\n    Info(\\\"Operation cancelled.\\\");\\n    return;\\n}\\nint totalCount = 0;\\n// For each page, process visuals\\nforeach (var pageExt in report.Pages)\\n{\\n    var visuals = (pageExt.Visuals ?? new List<VisualExtended>())\\n        .OrderBy(v => v.Content.Position.Y)\\n        .ThenBy(v => v.Content.Position.X)\\n        .ToList();\\n    int bilingualCounter = 1;\\n    foreach (var visual in visuals)\\n    {\\n        // Skip if already in a bilingual group or if it's a group itself\\n        if (visual.IsInBilingualVisualGroup()) continue;\\n        if (visual.isVisualGroup) continue;\\n        // Duplicate the visual (deep copy)\\n        VisualExtended duplicate = Rx.DuplicateVisual(visual);\\n        // Add the duplicate to the page\\n        pageExt.Visuals.Add(duplicate);\\n        // Prepare bilingual group name, ensure uniqueness\\n        string pagePrefix = String.Format(\\\"P{0:00}\\\", visual.ParentPage.PageIndex + 1);\\n        string groupSuffix = String.Format(\\\"{0:000}\\\", bilingualCounter);\\n        string bilingualGroupDisplayName = pagePrefix + \\\"-\\\" + groupSuffix;\\n        // Check for existing group with the same display name and increment counter if needed\\n        while (pageExt.Visuals.Any(v =>\\n            v.isVisualGroup &&\\n            v.Content.VisualGroup != null &&\\n            v.Content.VisualGroup.DisplayName == bilingualGroupDisplayName))\\n        {\\n            bilingualCounter++;\\n            groupSuffix = String.Format(\\\"{0:000}\\\", bilingualCounter);\\n            bilingualGroupDisplayName = pagePrefix + \\\"-\\\" + groupSuffix;\\n        }\\n        string originalVisualGroupName = visual.Content.ParentGroupName;\\n        List<VisualExtended> visualsToGroup = new List<VisualExtended> { visual, duplicate };\\n        // Create bilingual visual group\\n        VisualExtended visualGroup = Rx.GroupVisuals(visualsToGroup, groupDisplayName: bilingualGroupDisplayName);\\n        //configure the original visual group if existed\\n        if (originalVisualGroupName != null)\\n        {\\n            visualGroup.Content.ParentGroupName = originalVisualGroupName;\\n        }\\n        //set the altText flag \\n        string currentAltText = visual.AltText ?? \\\"\\\";\\n        if (!currentAltText.StartsWith(altTextFlag))\\n        {\\n            visual.AltText = String.Format(@\\\"{0} {1}\\\", altTextFlag, currentAltText).Trim();\\n        }\\n        // Remove flag from duplicate's altText if present\\n        string duplicateAltText = duplicate.AltText ?? \\\"\\\";\\n        if (duplicateAltText.StartsWith(altTextFlag))\\n        {\\n            duplicate.AltText = duplicateAltText.Substring(altTextFlag.Length).TrimStart();\\n        }\\n        //hide the original visual\\n        visual.Content.IsHidden = true;\\n        Rx.SaveVisual(visual);\\n        Rx.SaveVisual(duplicate);\\n        Rx.SaveVisual(visualGroup);\\n        bilingualCounter++;\\n        totalCount++;\\n    }\\n}\\nOutput(String.Format(\\\"Bilingual visual groups created for {0} visuals.\\\",totalCount));\\n\\npublic static class Fx\\n{\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        return model.Tables.FirstOrDefault(t =>\\n                            string.Equals(t.Name, tableName, StringComparison.OrdinalIgnoreCase)) //case insensitive search\\n                            ?? model.AddCalculatedTable(tableName, tableExpression);\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {\\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList, string label = \\\"Choose item\\\", int customWidth = 400, int customHeight = 500)\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect: false, label: label, customWidth: customWidth, customHeight:customHeight) as string;\\n    }\\n    public static List<string> ChooseStringMultiple(IList<string> OptionList, string label = \\\"Choose item(s)\\\", int customWidth = 400, int customHeight = 500)\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect:true, label:label, customWidth: customWidth, customHeight: customHeight) as List<string>;\\n    }\\n    private static object ChooseStringInternal(IList<string> OptionList, bool MultiSelect, string label = \\\"Choose item(s)\\\", int customWidth = 400, int customHeight = 500)\\n    {\\n        Form form = new Form\\n        {\\n            Text =label,\\n            Width = customWidth,\\n            Height = customHeight,\\n            StartPosition = FormStartPosition.CenterScreen,\\n            Padding = new Padding(20)\\n        };\\n        ListBox listbox = new ListBox\\n        {\\n            Dock = DockStyle.Fill,\\n            SelectionMode = MultiSelect ? SelectionMode.MultiExtended : SelectionMode.One\\n        };\\n        listbox.Items.AddRange(OptionList.ToArray());\\n        if (!MultiSelect && OptionList.Count > 0)\\n            listbox.SelectedItem = OptionList[0];\\n        FlowLayoutPanel buttonPanel = new FlowLayoutPanel\\n        {\\n            Dock = DockStyle.Bottom,\\n            Height = 40,\\n            FlowDirection = FlowDirection.LeftToRight,\\n            Padding = new Padding(10)\\n        };\\n        Button selectAllButton = new Button { Text = \\\"Select All\\\", Visible = MultiSelect };\\n        Button selectNoneButton = new Button { Text = \\\"Select None\\\", Visible = MultiSelect };\\n        Button okButton = new Button { Text = \\\"OK\\\", DialogResult = DialogResult.OK };\\n        Button cancelButton = new Button { Text = \\\"Cancel\\\", DialogResult = DialogResult.Cancel };\\n        selectAllButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, true);\\n        };\\n        selectNoneButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, false);\\n        };\\n        buttonPanel.Controls.Add(selectAllButton);\\n        buttonPanel.Controls.Add(selectNoneButton);\\n        buttonPanel.Controls.Add(okButton);\\n        buttonPanel.Controls.Add(cancelButton);\\n        form.Controls.Add(listbox);\\n        form.Controls.Add(buttonPanel);\\n        DialogResult result = form.ShowDialog();\\n        if (result == DialogResult.Cancel)\\n        {\\n            Info(\\\"You Cancelled!\\\");\\n            return null;\\n        }\\n        if (MultiSelect)\\n        {\\n            List<string> selectedItems = new List<string>();\\n            foreach (object item in listbox.SelectedItems)\\n                selectedItems.Add(item.ToString());\\n            return selectedItems;\\n        }\\n        else\\n        {\\n            return listbox.SelectedItem != null ? listbox.SelectedItem.ToString() : null;\\n        }\\n    }\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        var dateTables = model.Tables\\n            .Where(t => t.DataCategory == \\\"Time\\\" &&\\n                   t.Columns.Any(c => c.IsKey && c.DataType == DataType.DateTime))\\n            .ToList();\\n        if (!dateTables.Any())\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n            return null;\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        return GetFilteredTables(tables, lambda).FirstOrDefault();\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table, bool> lambda)\\n    {\\n        var filteredTables = tables.Where(t => lambda(t));\\n        return filteredTables.Any() ? filteredTables : null;\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column, bool> lambda, bool returnAllIfNoneFound = true)\\n    {\\n        var filteredColumns = columns.Where(c => lambda(c));\\n        return filteredColumns.Any() || returnAllIfNoneFound ? filteredColumns : null;\\n    }\\n}\\n\\npublic static class Rx\\n\\n{\\n\\n\\n\\n\\n\\n    \\n\\n    \\n\\n    public static VisualExtended DuplicateVisual(VisualExtended visualExtended)\\n\\n    {\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes)\\n\\n        string newVisualName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        string sourceFolder = Path.GetDirectoryName(visualExtended.VisualFilePath);\\n\\n        string targetFolder = Path.Combine(Path.GetDirectoryName(sourceFolder), newVisualName);\\n\\n        if (Directory.Exists(targetFolder))\\n\\n        {\\n\\n            Error(string.Format(\\\"Folder already exists: {0}\\\", targetFolder));\\n\\n            return null;\\n\\n        }\\n\\n        Directory.CreateDirectory(targetFolder);\\n\\n\\n\\n        // Deep clone the VisualDto.Root object\\n\\n        string originalJson = JsonConvert.SerializeObject(visualExtended.Content, Newtonsoft.Json.Formatting.Indented);\\n\\n        VisualDto.Root clonedContent = \\n\\n            JsonConvert.DeserializeObject<VisualDto.Root>(\\n\\n                originalJson, \\n\\n                new JsonSerializerSettings {\\n\\n                    DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                    NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n                });\\n\\n\\n\\n        // Update the name property if it exists\\n\\n        if (clonedContent != null && clonedContent.Name != null)\\n\\n        {\\n\\n            clonedContent.Name = newVisualName;\\n\\n        }\\n\\n\\n\\n        // Set the new file path\\n\\n        string newVisualFilePath = Path.Combine(targetFolder, \\\"visual.json\\\");\\n\\n\\n\\n        // Create the new VisualExtended object\\n\\n        VisualExtended newVisual = new VisualExtended\\n\\n        {\\n\\n            Content = clonedContent,\\n\\n            VisualFilePath = newVisualFilePath\\n\\n        };\\n\\n\\n\\n        return newVisual;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended GroupVisuals(List<VisualExtended> visualsToGroup, string groupName = null, string groupDisplayName = null)\\n\\n    {\\n\\n        if (visualsToGroup == null || visualsToGroup.Count == 0)\\n\\n        {\\n\\n            Error(\\\"No visuals to group.\\\");\\n\\n            return null;\\n\\n        }\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes) if no group name is provided\\n\\n        if (string.IsNullOrEmpty(groupName))\\n\\n        {\\n\\n            groupName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        }\\n\\n        if (string.IsNullOrEmpty(groupDisplayName))\\n\\n        {\\n\\n            groupDisplayName = groupName;\\n\\n        }\\n\\n\\n\\n        // Find minimum X and Y\\n\\n        double minX = visualsToGroup.Min(v => v.Content.Position != null ? (double)v.Content.Position.X : 0);\\n\\n        double minY = visualsToGroup.Min(v => v.Content.Position != null ? (double)v.Content.Position.Y : 0);\\n\\n\\n\\n       //Info(\\\"minX:\\\" + minX.ToString() + \\\", minY: \\\" + minY.ToString());\\n\\n\\n\\n        // Calculate width and height\\n\\n        double groupWidth = 0;\\n\\n        double groupHeight = 0;\\n\\n        foreach (var v in visualsToGroup)\\n\\n        {\\n\\n            if (v.Content != null && v.Content.Position != null)\\n\\n            {\\n\\n                double visualWidth = v.Content.Position != null ? (double)v.Content.Position.Width : 0;\\n\\n                double visualHeight = v.Content.Position != null ? (double)v.Content.Position.Height : 0;\\n\\n                double xOffset = (double)v.Content.Position.X - (double)minX;\\n\\n                double yOffset = (double)v.Content.Position.Y - (double)minY;\\n\\n                double totalWidth = xOffset + visualWidth;\\n\\n                double totalHeight = yOffset + visualHeight;\\n\\n                if (totalWidth > groupWidth) groupWidth = totalWidth;\\n\\n                if (totalHeight > groupHeight) groupHeight = totalHeight;\\n\\n            }\\n\\n        }\\n\\n\\n\\n        // Create the group visual content\\n\\n        var groupContent = new VisualDto.Root\\n\\n        {\\n\\n            Schema = visualsToGroup.FirstOrDefault().Content.Schema,\\n\\n            Name = groupName,\\n\\n            Position = new VisualDto.Position\\n\\n            {\\n\\n                X = minX,\\n\\n                Y = minY,\\n\\n                Width = groupWidth,\\n\\n                Height = groupHeight\\n\\n            },\\n\\n            VisualGroup = new VisualDto.VisualGroup\\n\\n            {\\n\\n                DisplayName = groupDisplayName,\\n\\n                GroupMode = \\\"ScaleMode\\\"\\n\\n            }\\n\\n        };\\n\\n\\n\\n        // Set VisualFilePath for the group visual\\n\\n        // Use the VisualFilePath of the first visual as a template\\n\\n        string groupVisualFilePath = null;\\n\\n        var firstVisual = visualsToGroup.FirstOrDefault(v => !string.IsNullOrEmpty(v.VisualFilePath));\\n\\n        if (firstVisual != null && !string.IsNullOrEmpty(firstVisual.VisualFilePath))\\n\\n        {\\n\\n            string originalPath = firstVisual.VisualFilePath;\\n\\n            string parentDir = Path.GetDirectoryName(Path.GetDirectoryName(originalPath)); // up to 'visuals'\\n\\n            if (!string.IsNullOrEmpty(parentDir))\\n\\n            {\\n\\n                string groupFolder = Path.Combine(parentDir, groupName);\\n\\n                groupVisualFilePath = Path.Combine(groupFolder, \\\"visual.json\\\");\\n\\n            }\\n\\n        }\\n\\n\\n\\n        // Create the new VisualExtended for the group\\n\\n        var groupVisual = new VisualExtended\\n\\n        {\\n\\n            Content = groupContent,\\n\\n            VisualFilePath = groupVisualFilePath // Set as described\\n\\n        };\\n\\n\\n\\n        // Update grouped visuals: set parentGroupName and adjust X/Y\\n\\n        foreach (var v in visualsToGroup)\\n\\n        {\\n\\n            \\n\\n            if (v.Content == null) continue;\\n\\n            v.Content.ParentGroupName = groupName;\\n\\n\\n\\n            if (v.Content.Position != null)\\n\\n            {\\n\\n                v.Content.Position.X = v.Content.Position.X - minX + 0;\\n\\n                v.Content.Position.Y = v.Content.Position.Y - minY + 0;\\n\\n            }\\n\\n        }\\n\\n\\n\\n        return groupVisual;\\n\\n    }\\n\\n\\n\\n    \\n\\n\\n\\n    private static readonly string RecentPathsFile = Path.Combine(\\n\\n    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\\n\\n    \\\"Tabular Editor Macro Settings\\\", \\\"recentPbirPaths.json\\\");\\n\\n\\n\\n    public static string GetPbirFilePathWithHistory(string label = \\\"Select definition.pbir file\\\")\\n\\n    {\\n\\n        // Load recent paths\\n\\n        List<string> recentPaths = LoadRecentPbirPaths();\\n\\n\\n\\n        // Filter out non-existing files\\n\\n        recentPaths = recentPaths.Where(File.Exists).ToList();\\n\\n\\n\\n        // Present options to the user\\n\\n        var options = new List<string>(recentPaths);\\n\\n        options.Add(\\\"Browse for new file...\\\");\\n\\n\\n\\n        string selected = Fx.ChooseString(options,label:label, customWidth:600, customHeight:300);\\n\\n\\n\\n        if (selected == null) return null;\\n\\n\\n\\n        string chosenPath = null;\\n\\n        if (selected == \\\"Browse for new file...\\\" )\\n\\n        {\\n\\n            chosenPath = GetPbirFilePath(label);\\n\\n        }\\n\\n        else\\n\\n        {\\n\\n            chosenPath = selected;\\n\\n        }\\n\\n\\n\\n        if (!string.IsNullOrEmpty(chosenPath))\\n\\n        {\\n\\n            // Update recent paths\\n\\n            UpdateRecentPbirPaths(chosenPath, recentPaths);\\n\\n        }\\n\\n\\n\\n        return chosenPath;\\n\\n    }\\n\\n\\n\\n    private static List<string> LoadRecentPbirPaths()\\n\\n    {\\n\\n        try\\n\\n        {\\n\\n            if (File.Exists(RecentPathsFile))\\n\\n            {\\n\\n                string json = File.ReadAllText(RecentPathsFile);\\n\\n                return JsonConvert.DeserializeObject<List<string>>(json) ?? new List<string>();\\n\\n            }\\n\\n        }\\n\\n        catch { }\\n\\n        return new List<string>();\\n\\n    }\\n\\n\\n\\n    private static void UpdateRecentPbirPaths(string newPath, List<string> recentPaths)\\n\\n    {\\n\\n        // Remove if already exists, insert at top\\n\\n        recentPaths.RemoveAll(p => string.Equals(p, newPath, StringComparison.OrdinalIgnoreCase));\\n\\n        recentPaths.Insert(0, newPath);\\n\\n\\n\\n        // Keep only the latest 10\\n\\n        while (recentPaths.Count > 10)\\n\\n            recentPaths.RemoveAt(recentPaths.Count - 1);\\n\\n\\n\\n        // Ensure directory exists\\n\\n        Directory.CreateDirectory(Path.GetDirectoryName(RecentPathsFile));\\n\\n        File.WriteAllText(RecentPathsFile, JsonConvert.SerializeObject(recentPaths, Newtonsoft.Json.Formatting.Indented));\\n\\n    }\\n\\n\\n\\n\\n\\n    public static ReportExtended InitReport(string label = \\\"Please select definition.pbir file of the target report\\\")\\n\\n    {\\n\\n        // Get the base path from the user  \\n\\n        string basePath = Rx.GetPbirFilePathWithHistory(label:label);\\n\\n        if (basePath == null) return null; \\n\\n        \\n\\n        // Define the target path  \\n\\n        string baseDirectory = Path.GetDirectoryName(basePath);\\n\\n        string targetPath = Path.Combine(baseDirectory, \\\"definition\\\", \\\"pages\\\");\\n\\n\\n\\n        // Check if the target path exists  \\n\\n        if (!Directory.Exists(targetPath))\\n\\n        {\\n\\n            Error(String.Format(\\\"The path '{0}' does not exist.\\\", targetPath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Get all subfolders in the target path  \\n\\n        List<string> subfolders = Directory.GetDirectories(targetPath).ToList();\\n\\n\\n\\n        string pagesFilePath = Path.Combine(targetPath, \\\"pages.json\\\");\\n\\n        string pagesJsonContent = File.ReadAllText(pagesFilePath);\\n\\n        \\n\\n        if (string.IsNullOrEmpty(pagesJsonContent))\\n\\n        {\\n\\n            Error(String.Format(\\\"The file '{0}' is empty or does not exist.\\\", pagesFilePath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        PagesDto pagesDto = JsonConvert.DeserializeObject<PagesDto>(pagesJsonContent);\\n\\n\\n\\n        ReportExtended report = new ReportExtended();\\n\\n        report.PagesFilePath = pagesFilePath;\\n\\n        report.PagesConfig = pagesDto;\\n\\n\\n\\n        // Process each folder  \\n\\n        foreach (string folder in subfolders)\\n\\n        {\\n\\n            string pageJsonPath = Path.Combine(folder, \\\"page.json\\\");\\n\\n            if (File.Exists(pageJsonPath))\\n\\n            {\\n\\n                try\\n\\n                {\\n\\n                    string jsonContent = File.ReadAllText(pageJsonPath);\\n\\n                    PageDto page = JsonConvert.DeserializeObject<PageDto>(jsonContent);\\n\\n\\n\\n                    PageExtended pageExtended = new PageExtended();\\n\\n                    pageExtended.Page = page;\\n\\n                    pageExtended.PageFilePath = pageJsonPath;\\n\\n\\n\\n                    pageExtended.ParentReport = report;\\n\\n\\n\\n                    string visualsPath = Path.Combine(folder, \\\"visuals\\\");\\n\\n\\n\\n                    if (!Directory.Exists(visualsPath))\\n\\n                    {\\n\\n                        report.Pages.Add(pageExtended); // still add the page\\n\\n                        continue; // skip visual loading\\n\\n                    }\\n\\n\\n\\n                    List<string> visualSubfolders = Directory.GetDirectories(visualsPath).ToList();\\n\\n\\n\\n                    foreach (string visualFolder in visualSubfolders)\\n\\n                    {\\n\\n                        string visualJsonPath = Path.Combine(visualFolder, \\\"visual.json\\\");\\n\\n                        if (File.Exists(visualJsonPath))\\n\\n                        {\\n\\n                            try\\n\\n                            {\\n\\n                                string visualJsonContent = File.ReadAllText(visualJsonPath);\\n\\n                                VisualDto.Root visual = JsonConvert.DeserializeObject<VisualDto.Root>(visualJsonContent);\\n\\n\\n\\n                                VisualExtended visualExtended = new VisualExtended();\\n\\n                                visualExtended.Content = visual;\\n\\n                                visualExtended.VisualFilePath = visualJsonPath;\\n\\n                                visualExtended.ParentPage = pageExtended; // Set parent page reference\\n\\n                                pageExtended.Visuals.Add(visualExtended);\\n\\n                            }\\n\\n                            catch (Exception ex2)\\n\\n                            {\\n\\n                                Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", visualJsonPath, ex2.Message));\\n\\n                                return null;\\n\\n                            }\\n\\n\\n\\n                        }\\n\\n                    }\\n\\n\\n\\n                    report.Pages.Add(pageExtended);\\n\\n\\n\\n                }\\n\\n                catch (Exception ex)\\n\\n                {\\n\\n                    Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", pageJsonPath, ex.Message));\\n\\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        return report;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended SelectVisual(ReportExtended report)\\n\\n    {\\n\\n        return SelectVisualInternal(report, Multiselect: false) as VisualExtended;\\n\\n    }\\n\\n\\n\\n    public static List<VisualExtended> SelectVisuals(ReportExtended report)\\n\\n    {\\n\\n        return SelectVisualInternal(report, Multiselect: true) as List<VisualExtended>;\\n\\n    }\\n\\n\\n\\n    private static object SelectVisualInternal(ReportExtended report, bool Multiselect)\\n\\n    {\\n\\n        // Step 1: Build selection list\\n\\n        var visualSelectionList = report.Pages\\n\\n            .SelectMany(p => p.Visuals.Select(v => new\\n\\n            {\\n\\n                //use visual type for regular visuals, displayname for groups\\n\\n                Display = string.Format(\\n\\n                    \\\"{0} - {1} ({2}, {3})\\\", \\n\\n                    p.Page.DisplayName, \\n\\n                    v?.Content?.Visual?.VisualType\\n\\n                        ?? v?.Content?.VisualGroup?.DisplayName,\\n\\n                    (int)v.Content.Position.X, \\n\\n                    (int)v.Content.Position.Y),\\n\\n\\n\\n\\n\\n                Page = p,\\n\\n                Visual = v\\n\\n            }))\\n\\n            .ToList();\\n\\n\\n\\n        if(visualSelectionList.Count == 0)\\n\\n        {\\n\\n            Error(\\\"No visuals found in the report.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Step 2: Let user choose a visual\\n\\n        var options = visualSelectionList.Select(v => v.Display).ToList();\\n\\n\\n\\n\\n\\n        if (Multiselect)\\n\\n        {\\n\\n            // For multiselect, use ChooseStringMultiple\\n\\n            var multiSelelected = Fx.ChooseStringMultiple(options);\\n\\n            if (multiSelelected == null || multiSelelected.Count == 0)\\n\\n            {\\n\\n                Info(\\\"You cancelled.\\\");\\n\\n                return null;\\n\\n            }\\n\\n            // Find all selected visuals\\n\\n            var selectedVisuals = visualSelectionList.Where(v => multiSelelected.Contains(v.Display)).Select(v => v.Visual).ToList();\\n\\n\\n\\n            return selectedVisuals;\\n\\n        }\\n\\n        else\\n\\n        {\\n\\n            string selected = Fx.ChooseString(options);\\n\\n\\n\\n            if (string.IsNullOrEmpty(selected))\\n\\n            {\\n\\n                Info(\\\"You cancelled.\\\");\\n\\n                return null;\\n\\n            }\\n\\n\\n\\n            // Step 3: Find the selected visual\\n\\n            var selectedVisual = visualSelectionList.FirstOrDefault(v => v.Display == selected);\\n\\n\\n\\n            if (selectedVisual == null)\\n\\n            {\\n\\n                Error(\\\"Selected visual not found.\\\");\\n\\n                return null;\\n\\n            }\\n\\n\\n\\n            return selectedVisual.Visual;\\n\\n        }\\n\\n    }\\n\\n\\n\\n    public static PageExtended ReplicateFirstPageAsBlank(ReportExtended report, bool showMessages = false)\\n\\n    {\\n\\n        if (report.Pages == null || !report.Pages.Any())\\n\\n        {\\n\\n            Error(\\\"No pages found in the report.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        PageExtended firstPage = report.Pages[0];\\n\\n\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes)\\n\\n        string newPageName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        string newPageDisplayName = firstPage.Page.DisplayName + \\\" - Copy\\\";\\n\\n\\n\\n        string sourceFolder = Path.GetDirectoryName(firstPage.PageFilePath);\\n\\n        string targetFolder = Path.Combine(Path.GetDirectoryName(sourceFolder), newPageName);\\n\\n        string visualsFolder = Path.Combine(targetFolder, \\\"visuals\\\");\\n\\n\\n\\n        if (Directory.Exists(targetFolder))\\n\\n        {\\n\\n            Error($\\\"Folder already exists: {targetFolder}\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        Directory.CreateDirectory(targetFolder);\\n\\n        Directory.CreateDirectory(visualsFolder);\\n\\n\\n\\n        var newPageDto = new PageDto\\n\\n        {\\n\\n            Name = newPageName,\\n\\n            DisplayName = newPageDisplayName,\\n\\n            DisplayOption = firstPage.Page.DisplayOption,\\n\\n            Height = firstPage.Page.Height,\\n\\n            Width = firstPage.Page.Width,\\n\\n            Schema = firstPage.Page.Schema\\n\\n        };\\n\\n\\n\\n        var newPage = new PageExtended\\n\\n        {\\n\\n            Page = newPageDto,\\n\\n            PageFilePath = Path.Combine(targetFolder, \\\"page.json\\\"),\\n\\n            Visuals = new List<VisualExtended>() // empty visuals\\n\\n        };\\n\\n\\n\\n        File.WriteAllText(newPage.PageFilePath, JsonConvert.SerializeObject(newPageDto, Newtonsoft.Json.Formatting.Indented));\\n\\n\\n\\n        report.Pages.Add(newPage);\\n\\n\\n\\n        if(showMessages) Info($\\\"Created new blank page: {newPageName}\\\");\\n\\n\\n\\n        return newPage; \\n\\n    }\\n\\n\\n\\n\\n\\n    public static void SaveVisual(VisualExtended visual)\\n\\n    {\\n\\n\\n\\n        // Save new JSON, ignoring nulls\\n\\n        string newJson = JsonConvert.SerializeObject(\\n\\n            visual.Content,\\n\\n            Newtonsoft.Json.Formatting.Indented,\\n\\n            new JsonSerializerSettings\\n\\n            {\\n\\n                //DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n            }\\n\\n        );\\n\\n        // Ensure the directory exists before saving\\n\\n        string visualFolder = Path.GetDirectoryName(visual.VisualFilePath);\\n\\n        if (!Directory.Exists(visualFolder))\\n\\n        {\\n\\n            Directory.CreateDirectory(visualFolder);\\n\\n        }\\n\\n        File.WriteAllText(visual.VisualFilePath, newJson);\\n\\n    }\\n\\n\\n\\n\\n\\n    public static string ReplacePlaceholders(string pageContents, Dictionary<string, string> placeholders)\\n\\n    {\\n\\n        if (placeholders != null)\\n\\n        {\\n\\n            foreach (string placeholder in placeholders.Keys)\\n\\n            {\\n\\n                string valueToReplace = placeholders[placeholder];\\n\\n\\n\\n                pageContents = pageContents.Replace(placeholder, valueToReplace);\\n\\n\\n\\n            }\\n\\n        }\\n\\n\\n\\n\\n\\n        return pageContents;\\n\\n    }\\n\\n\\n\\n\\n\\n    public static String GetPbirFilePath(string label = \\\"Please select definition.pbir file of the target report\\\")\\n\\n    {\\n\\n\\n\\n        // Create an instance of the OpenFileDialog\\n\\n        OpenFileDialog openFileDialog = new OpenFileDialog\\n\\n        {\\n\\n            Title = label,\\n\\n            // Set filter options and filter index.\\n\\n            Filter = \\\"PBIR Files (*.pbir)|*.pbir\\\",\\n\\n            FilterIndex = 1\\n\\n        };\\n\\n        // Call the ShowDialog method to show the dialog box.\\n\\n        DialogResult result = openFileDialog.ShowDialog();\\n\\n        // Process input if the user clicked OK.\\n\\n        if (result != DialogResult.OK)\\n\\n        {\\n\\n            Error(\\\"You cancelled\\\");\\n\\n            return null;\\n\\n        }\\n\\n        return openFileDialog.FileName;\\n\\n\\n\\n    }\\n\\n\\n\\n\\n\\n}\\n\\n\\n\\n   \\n\\n    public class PagesDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"pageOrder\\\")]\\n        public List<string> PageOrder { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"activePageName\\\")]\\n        public string ActivePageName { get; set; }\\n        \\n    }\\n\\n\\n    public class PageDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"name\\\")]\\n        public string Name { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayName\\\")]\\n        public string DisplayName { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayOption\\\")]\\n        public string DisplayOption { get; set; } // Could create enum if you want stricter typing\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"height\\\")]\\n        public double? Height { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"width\\\")]\\n        public double? Width { get; set; }\\n    }\\n\\n\\n\\n    public partial class VisualDto\\n    {\\n        public class Root\\n        {\\n            [JsonProperty(\\\"$schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"name\\\")] public string Name { get; set; }\\n            [JsonProperty(\\\"position\\\")] public Position Position { get; set; }\\n            [JsonProperty(\\\"visual\\\")] public Visual Visual { get; set; }\\n            \\n\\n            [JsonProperty(\\\"visualGroup\\\")] public VisualGroup VisualGroup { get; set; }\\n            [JsonProperty(\\\"parentGroupName\\\")] public string ParentGroupName { get; set; }\\n            [JsonProperty(\\\"filterConfig\\\")] public object FilterConfig { get; set; }\\n            [JsonProperty(\\\"isHidden\\\")] public bool IsHidden { get; set; }\\n\\n            [JsonExtensionData]\\n            \\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        public class VisualContainerObjects\\n        {\\n            [JsonProperty(\\\"general\\\")]\\n            public List<VisualContainerObject> General { get; set; }\\n\\n            // Add other known properties as needed, e.g.:\\n            [JsonProperty(\\\"title\\\")]\\n            public List<VisualContainerObject> Title { get; set; }\\n\\n            [JsonProperty(\\\"subTitle\\\")]\\n            public List<VisualContainerObject> SubTitle { get; set; }\\n\\n            // This will capture any additional properties not explicitly defined above\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualContainerObject\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            public Dictionary<string, VisualContainerProperty> Properties { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualContainerProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualExpr Expr { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualExpr\\n        {\\n            [JsonProperty(\\\"Literal\\\")]\\n            public VisualLiteral Literal { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualLiteral\\n        {\\n            [JsonProperty(\\\"Value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualGroup\\n        {\\n            [JsonProperty(\\\"displayName\\\")] public string DisplayName { get; set; }\\n            [JsonProperty(\\\"groupMode\\\")] public string GroupMode { get; set; }\\n        }\\n\\n        public class Position\\n        {\\n            [JsonProperty(\\\"x\\\")] public double X { get; set; }\\n            [JsonProperty(\\\"y\\\")] public double Y { get; set; }\\n            [JsonProperty(\\\"z\\\")] public int Z { get; set; }\\n            [JsonProperty(\\\"height\\\")] public double Height { get; set; }\\n            [JsonProperty(\\\"width\\\")] public double Width { get; set; }\\n            [JsonProperty(\\\"tabOrder\\\")] public int TabOrder { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Visual\\n        {\\n            [JsonProperty(\\\"visualType\\\")] public string VisualType { get; set; }\\n            [JsonProperty(\\\"query\\\")] public Query Query { get; set; }\\n            [JsonProperty(\\\"objects\\\")] public Objects Objects { get; set; }\\n            [JsonProperty(\\\"visualContainerObjects\\\")]\\n            public VisualContainerObjects VisualContainerObjects { get; set; }\\n            [JsonProperty(\\\"drillFilterOtherVisuals\\\")] public bool DrillFilterOtherVisuals { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Query\\n        {\\n            [JsonProperty(\\\"queryState\\\")] public QueryState QueryState { get; set; }\\n            [JsonProperty(\\\"sortDefinition\\\")] public SortDefinition SortDefinition { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class QueryState\\n        {\\n            [JsonProperty(\\\"Rows\\\", Order = 1)] public VisualDto.ProjectionsSet Rows { get; set; }\\n            [JsonProperty(\\\"Category\\\", Order = 2)] public VisualDto.ProjectionsSet Category { get; set; }\\n            [JsonProperty(\\\"Y\\\", Order = 3)] public VisualDto.ProjectionsSet Y { get; set; }\\n            [JsonProperty(\\\"Y2\\\", Order = 4)] public VisualDto.ProjectionsSet Y2 { get; set; }\\n            [JsonProperty(\\\"Values\\\", Order = 5)] public VisualDto.ProjectionsSet Values { get; set; }\\n            \\n            [JsonProperty(\\\"Series\\\", Order = 6)] public VisualDto.ProjectionsSet Series { get; set; }\\n            [JsonProperty(\\\"Data\\\", Order = 7)] public VisualDto.ProjectionsSet Data { get; set; }\\n\\n            \\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ProjectionsSet\\n        {\\n            [JsonProperty(\\\"projections\\\")] public List<VisualDto.Projection> Projections { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Projection\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"queryRef\\\")] public string QueryRef { get; set; }\\n            [JsonProperty(\\\"nativeQueryRef\\\")] public string NativeQueryRef { get; set; }\\n            [JsonProperty(\\\"active\\\")] public bool? Active { get; set; }\\n            [JsonProperty(\\\"hidden\\\")] public bool? Hidden { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Field\\n        {\\n            [JsonProperty(\\\"Aggregation\\\")] public VisualDto.Aggregation Aggregation { get; set; }\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")] public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n            [JsonProperty(\\\"Measure\\\")] public VisualDto.MeasureObject Measure { get; set; }\\n            [JsonProperty(\\\"Column\\\")] public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Aggregation\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Function\\\")] public int Function { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class NativeVisualCalculation\\n        {\\n            [JsonProperty(\\\"Language\\\")] public string Language { get; set; }\\n            [JsonProperty(\\\"Expression\\\")] public string Expression { get; set; }\\n            [JsonProperty(\\\"Name\\\")] public string Name { get; set; }\\n\\n            [JsonProperty(\\\"DataType\\\")] public string DataType { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class MeasureObject\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnField\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Expression\\n        {\\n            [JsonProperty(\\\"Column\\\")] public ColumnExpression Column { get; set; }\\n            [JsonProperty(\\\"SourceRef\\\")] public VisualDto.SourceRef SourceRef { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnExpression\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.SourceRef Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SourceRef\\n        {\\n            [JsonProperty(\\\"Schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"Entity\\\")] public string Entity { get; set; }\\n            [JsonProperty(\\\"Source\\\")] public string Source { get; set; }\\n\\n            \\n        }\\n\\n        public class SortDefinition\\n        {\\n            [JsonProperty(\\\"sort\\\")] public List<VisualDto.Sort> Sort { get; set; }\\n            [JsonProperty(\\\"isDefaultSort\\\")] public bool IsDefaultSort { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Sort\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"direction\\\")] public string Direction { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Objects\\n        {\\n            [JsonProperty(\\\"valueAxis\\\")] public List<VisualDto.ObjectProperties> ValueAxis { get; set; }\\n            [JsonProperty(\\\"general\\\")] public List<VisualDto.ObjectProperties> General { get; set; }\\n            [JsonProperty(\\\"data\\\")] public List<VisualDto.ObjectProperties> Data { get; set; }\\n            [JsonProperty(\\\"title\\\")] public List<VisualDto.ObjectProperties> Title { get; set; }\\n            [JsonProperty(\\\"legend\\\")] public List<VisualDto.ObjectProperties> Legend { get; set; }\\n            [JsonProperty(\\\"labels\\\")] public List<VisualDto.ObjectProperties> Labels { get; set; }\\n            [JsonProperty(\\\"dataPoint\\\")] public List<VisualDto.ObjectProperties> DataPoint { get; set; }\\n\\n\\n            [JsonProperty(\\\"referenceLabel\\\")] public List<VisualDto.ObjectProperties> ReferenceLabel { get; set; }\\n            [JsonProperty(\\\"referenceLabelDetail\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelDetail { get; set; }\\n            [JsonProperty(\\\"referenceLabelValue\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelValue { get; set; }\\n\\n            [JsonProperty(\\\"values\\\")] public List<VisualDto.ObjectProperties> Values { get; set; }\\n\\n            [JsonProperty(\\\"y1AxisReferenceLine\\\")] public List<VisualDto.ObjectProperties> Y1AxisReferenceLine { get; set; }\\n\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ObjectProperties\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            [JsonConverter(typeof(PropertiesConverter))]\\n            public Dictionary<string, object> Properties { get; set; }\\n\\n            [JsonProperty(\\\"selector\\\")]\\n            public Selector Selector { get; set; }\\n\\n\\n            [JsonExtensionData] public IDictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n\\n\\n        public class VisualObjectProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")] public Field Expr { get; set; }\\n            [JsonProperty(\\\"solid\\\")] public SolidColor Solid { get; set; }\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n\\n            [JsonProperty(\\\"paragraphs\\\")]\\n            public List<Paragraph> Paragraphs { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Paragraph\\n        {\\n            [JsonProperty(\\\"textRuns\\\")]\\n            public List<TextRun> TextRuns { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class TextRun\\n        {\\n            [JsonProperty(\\\"value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonProperty(\\\"url\\\")]\\n            public string Url { get; set; }\\n\\n            [JsonProperty(\\\"textStyle\\\")]\\n            public Dictionary<string, object> TextStyle { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SolidColor\\n        {\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColorExpression\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualColorExprWrapper Expr { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExprWrapper\\n        {\\n            [JsonProperty(\\\"FillRule\\\")] public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExpression\\n        {\\n            [JsonProperty(\\\"Input\\\")] public VisualDto.Field Input { get; set; }\\n            [JsonProperty(\\\"FillRule\\\")] public Dictionary<string, object> FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualColorExprWrapper\\n        {\\n            [JsonProperty(\\\"Measure\\\")]\\n            public VisualDto.MeasureObject Measure { get; set; }\\n\\n            [JsonProperty(\\\"Column\\\")]\\n            public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonProperty(\\\"Aggregation\\\")]\\n            public VisualDto.Aggregation Aggregation { get; set; }\\n\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")]\\n            public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n\\n            [JsonProperty(\\\"FillRule\\\")]\\n            public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        \\n\\n        public class Selector\\n        {\\n            \\n\\n            [JsonProperty(\\\"id\\\")]\\n            public string Id { get; set; }\\n\\n            [JsonProperty(\\\"order\\\")]\\n            public int? Order { get; set; }\\n\\n            [JsonProperty(\\\"data\\\")]\\n            public List<object> Data { get; set; }\\n\\n            [JsonProperty(\\\"metadata\\\")]\\n            public string Metadata { get; set; }\\n\\n            [JsonProperty(\\\"scopeId\\\")]\\n            public string ScopeId { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class PropertiesConverter : JsonConverter\\n        {\\n            public override bool CanConvert(Type objectType) => objectType == typeof(Dictionary<string, object>);\\n\\n            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)\\n            {\\n                var result = new Dictionary<string, object>();\\n                var jObj = JObject.Load(reader);\\n\\n                foreach (var prop in jObj.Properties())\\n                {\\n                    if (prop.Name == \\\"paragraphs\\\")\\n                    {\\n                        var paragraphs = prop.Value.ToObject<List<Paragraph>>(serializer);\\n                        result[prop.Name] = paragraphs;\\n                    }\\n                    else\\n                    {\\n                        var visualProp = prop.Value.ToObject<VisualObjectProperty>(serializer);\\n                        result[prop.Name] = visualProp;\\n                    }\\n                }\\n\\n                return result;\\n            }\\n\\n            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\\n            {\\n                var dict = (Dictionary<string, object>)value;\\n                writer.WriteStartObject();\\n\\n                foreach (var kvp in dict)\\n                {\\n                    writer.WritePropertyName(kvp.Key);\\n\\n                    if (kvp.Value is VisualObjectProperty vo)\\n                        serializer.Serialize(writer, vo);\\n                    else if (kvp.Value is List<Paragraph> ps)\\n                        serializer.Serialize(writer, ps);\\n                    else\\n                        serializer.Serialize(writer, kvp.Value);\\n                }\\n\\n                writer.WriteEndObject();\\n            }\\n        }\\n    }\\n\\n\\n    public class VisualExtended\\n    {\\n        public VisualDto.Root Content { get; set; }\\n\\n        public string VisualFilePath { get; set; }\\n\\n\\n        public Boolean isVisualGroup => Content?.VisualGroup != null;\\n        public Boolean isGroupedVisual => Content?.ParentGroupName != null;\\n\\n        public bool IsBilingualVisualGroup()\\n        {\\n            if (!isVisualGroup || string.IsNullOrEmpty(Content.VisualGroup.DisplayName))\\n                return false;\\n            return System.Text.RegularExpressions.Regex.IsMatch(Content.VisualGroup.DisplayName, @\\\"^P\\d{2}-\\d{3}$\\\");\\n        }\\n\\n        public PageExtended ParentPage { get; set; }\\n\\n        public bool IsInBilingualVisualGroup()\\n        {\\n            if (ParentPage == null || ParentPage.Visuals == null || Content.ParentGroupName == null)\\n                return false;\\n            return ParentPage.Visuals.Any(v => v.IsBilingualVisualGroup() && v.Content.Name == Content.ParentGroupName);\\n        }\\n\\n        [JsonIgnore]\\n        public string AltText\\n        {\\n            get\\n            {\\n                var general = Content?.Visual?.VisualContainerObjects?.General;\\n                if (general == null || general.Count == 0)\\n                    return null;\\n                if (!general[0].Properties.ContainsKey(\\\"altText\\\"))\\n                    return null;\\n                return general[0].Properties[\\\"altText\\\"]?.Expr?.Literal?.Value?.Trim('\\'');\\n            }\\n            set\\n            {\\n                if(Content?.Visual == null)\\n                    Content.Visual = new VisualDto.Visual();\\n\\n                // Ensure the structure exists\\n                if (Content?.Visual?.VisualContainerObjects == null)\\n                    Content.Visual.VisualContainerObjects = new VisualDto.VisualContainerObjects();\\n\\n                if (Content.Visual?.VisualContainerObjects.General == null || Content.Visual?.VisualContainerObjects.General.Count == 0)\\n                    Content.Visual.VisualContainerObjects.General = \\n                        new List<VisualDto.VisualContainerObject> { \\n                            new VisualDto.VisualContainerObject { \\n                                Properties = new Dictionary<string, VisualDto.VisualContainerProperty>() \\n                            } \\n                        };\\n\\n                var general = Content.Visual.VisualContainerObjects.General[0];\\n\\n                if (general.Properties == null)\\n                    general.Properties = new Dictionary<string, VisualDto.VisualContainerProperty>();\\n\\n                general.Properties[\\\"altText\\\"] = new VisualDto.VisualContainerProperty\\n                {\\n                    Expr = new VisualDto.VisualExpr\\n                    {\\n                        Literal = new VisualDto.VisualLiteral\\n                        {\\n                            Value = value == null ? null : \\\"'\\\" + value.Replace(\\\"'\\\", \\\"\\\\'\\\") + \\\"'\\\"\\n                        }\\n                    }\\n                };\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetAllFields()\\n        {\\n            var fields = new List<VisualDto.Field>();\\n            var queryState = Content?.Visual?.Query?.QueryState;\\n\\n            if (queryState != null)\\n            {\\n                fields.AddRange(GetFieldsFromProjections(queryState.Values));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y2));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Category));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Series));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Data));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Rows));\\n            }\\n\\n            var sortList = Content?.Visual?.Query?.SortDefinition?.Sort;\\n            if (sortList != null)\\n                fields.AddRange(sortList.Select(s => s.Field));\\n\\n            var objects = Content?.Visual?.Objects;\\n            if (objects != null)\\n            {\\n                fields.AddRange(GetFieldsFromObjectList(objects.DataPoint));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Data));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Labels));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Title));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Legend));\\n                fields.AddRange(GetFieldsFromObjectList(objects.General));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ValueAxis));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Y1AxisReferenceLine));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabel));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelDetail));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelValue));\\n\\n            }\\n\\n            fields.AddRange(GetFieldsFromFilterConfig(Content?.FilterConfig));\\n\\n            return fields.Where(f => f != null);\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromProjections(VisualDto.ProjectionsSet set)\\n        {\\n            return set?.Projections?.Select(p => p.Field) ?? Enumerable.Empty<VisualDto.Field>();\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromObjectList(List<VisualDto.ObjectProperties> objectList)\\n        {\\n            if (objectList == null) yield break;\\n\\n            foreach (var obj in objectList)\\n            {\\n                if (obj.Properties == null) continue;\\n\\n                foreach (var val in obj.Properties.Values)\\n                {\\n                    var prop = val as VisualDto.VisualObjectProperty;\\n                    if (prop == null) continue;\\n\\n                    if (prop.Expr != null)\\n                    {\\n                        if (prop.Expr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = prop.Expr.Measure };\\n\\n                        if (prop.Expr.Column != null)\\n                            yield return new VisualDto.Field { Column = prop.Expr.Column };\\n                    }\\n\\n                    if (prop.Color != null &&\\n                        prop.Color.Expr != null &&\\n                        prop.Color.Expr.FillRule != null &&\\n                        prop.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    if (prop.Solid != null &&\\n                        prop.Solid.Color != null &&\\n                        prop.Solid.Color.Expr != null &&\\n                        prop.Solid.Color.Expr.FillRule != null &&\\n                        prop.Solid.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Solid.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    var solidExpr = prop.Solid != null &&\\n                                    prop.Solid.Color != null\\n                                    ? prop.Solid.Color.Expr\\n                                    : null;\\n\\n                    if (solidExpr != null)\\n                    {\\n                        if (solidExpr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = solidExpr.Measure };\\n\\n                        if (solidExpr.Column != null)\\n                            yield return new VisualDto.Field { Column = solidExpr.Column };\\n                    }\\n                }\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromFilterConfig(object filterConfig)\\n        {\\n            var fields = new List<VisualDto.Field>();\\n\\n            if (filterConfig is JObject jObj)\\n            {\\n                foreach (var token in jObj.DescendantsAndSelf().OfType<JObject>())\\n                {\\n                    var table = token[\\\"table\\\"]?.ToString();\\n                    var property = token[\\\"column\\\"]?.ToString() ?? token[\\\"measure\\\"]?.ToString();\\n\\n                    if (!string.IsNullOrEmpty(table) && !string.IsNullOrEmpty(property))\\n                    {\\n                        var field = new VisualDto.Field();\\n\\n                        if (token[\\\"measure\\\"] != null)\\n                        {\\n                            field.Measure = new VisualDto.MeasureObject\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n                        else if (token[\\\"column\\\"] != null)\\n                        {\\n                            field.Column = new VisualDto.ColumnField\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n\\n                        fields.Add(field);\\n                    }\\n                }\\n            }\\n\\n            return fields;\\n        }\\n\\n\\n        public IEnumerable<string> GetAllReferencedMeasures()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Measure)\\n                .Where(m => m?.Expression?.SourceRef?.Entity != null && m.Property != null)\\n                .Select(m => $\\\"'{m.Expression.SourceRef.Entity}'[{m.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public IEnumerable<string> GetAllReferencedColumns()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Column)\\n                .Where(c => c?.Expression?.SourceRef?.Entity != null && c.Property != null)\\n                .Select(c => $\\\"'{c.Expression.SourceRef.Entity}'[{c.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public void ReplaceMeasure(string oldFieldKey, Measure newMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Measure = new VisualDto.MeasureObject\\n                {\\n                    Property = newMeasure.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newMeasure.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: true, modifiedSet);\\n        }\\n\\n        public void ReplaceColumn(string oldFieldKey, Column newColumn, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Column = new VisualDto.ColumnField\\n                {\\n                    Property = newColumn.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newColumn.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: false, modifiedSet);\\n        }\\n\\n        private string ToFieldKey(VisualDto.Field f)\\n        {\\n            if (f?.Measure?.Expression?.SourceRef?.Entity is string mEntity && f.Measure.Property is string mProp)\\n                return $\\\"'{mEntity}'[{mProp}]\\\";\\n\\n            if (f?.Column?.Expression?.SourceRef?.Entity is string cEntity && f.Column.Property is string cProp)\\n                return $\\\"'{cEntity}'[{cProp}]\\\";\\n\\n            return null;\\n        }\\n\\n        private void ReplaceField(string oldFieldKey, VisualDto.Field newField, bool isMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var query = Content?.Visual?.Query;\\n            var objects = Content?.Visual?.Objects;\\n            bool wasModified = false;\\n\\n            void Replace(VisualDto.Field f)\\n            {\\n                if (f == null) return;\\n\\n                if (isMeasure)\\n                {\\n                    f.Measure = newField.Measure;\\n                    f.Column = null;\\n                    wasModified = true;\\n                }\\n                else\\n                {\\n                    f.Column = newField.Column;\\n                    f.Measure = null;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            void UpdateProjection(VisualDto.Projection proj)\\n            {\\n                if (proj == null) return;\\n\\n                if (ToFieldKey(proj.Field) == oldFieldKey)\\n                {\\n                    Replace(proj.Field);\\n\\n                    string entity = isMeasure\\n                        ? newField.Measure.Expression?.SourceRef?.Entity\\n                        : newField.Column.Expression?.SourceRef?.Entity;\\n\\n                    string prop = isMeasure\\n                        ? newField.Measure.Property\\n                        : newField.Column.Property;\\n\\n                    if (!string.IsNullOrEmpty(entity) && !string.IsNullOrEmpty(prop))\\n                    {\\n                        proj.QueryRef = $\\\"{entity}.{prop}\\\";\\n                        //proj.NativeQueryRef = prop;\\n                    }\\n\\n                    wasModified = true;\\n                }\\n            }\\n\\n            foreach (var proj in query?.QueryState?.Values?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Y?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n            \\n            foreach (var proj in query?.QueryState?.Y2?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Category?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Series?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Data?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Rows?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var sort in query?.SortDefinition?.Sort ?? Enumerable.Empty<VisualDto.Sort>())\\n                if (ToFieldKey(sort.Field) == oldFieldKey) Replace(sort.Field);\\n\\n            string oldMetadata = oldFieldKey.Replace(\\\"'\\\", \\\"\\\").Replace(\\\"[\\\", \\\".\\\").Replace(\\\"]\\\", \\\"\\\");\\n            string newMetadata = isMeasure\\n                ? $\\\"{newField.Measure.Expression.SourceRef.Entity}.{newField.Measure.Property}\\\"\\n                : $\\\"{newField.Column.Expression.SourceRef.Entity}.{newField.Column.Property}\\\";\\n\\n            IEnumerable<VisualDto.ObjectProperties> AllObjectProperties() =>\\n                (objects?.DataPoint ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Data ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Labels ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Title ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Legend ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.General ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ValueAxis ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabel ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelDetail ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelValue ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Values ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Y1AxisReferenceLine ?? Enumerable.Empty<VisualDto.ObjectProperties>());\\n\\n            foreach (var obj in AllObjectProperties())\\n            {\\n                foreach (var prop in obj.Properties.Values.OfType<VisualDto.VisualObjectProperty>())\\n                {\\n                    var field = isMeasure ? new VisualDto.Field { Measure = prop.Expr?.Measure } : new VisualDto.Field { Column = prop.Expr?.Column };\\n                    if (ToFieldKey(field) == oldFieldKey)\\n                    {\\n                        if (prop.Expr != null)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                prop.Expr.Measure = newField.Measure;\\n                                prop.Expr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                prop.Expr.Column = newField.Column;\\n                                prop.Expr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n\\n                    var fillInput = prop.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(fillInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            fillInput.Measure = newField.Measure;\\n                            fillInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            fillInput.Column = newField.Column;\\n                            fillInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    var solidInput = prop.Solid?.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(solidInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            solidInput.Measure = newField.Measure;\\n                            solidInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            solidInput.Column = newField.Column;\\n                            solidInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    // ✅ NEW: handle direct measure/column under solid.color.expr\\n                    var solidExpr = prop.Solid?.Color?.Expr;\\n                    if (solidExpr != null)\\n                    {\\n                        var solidField = isMeasure\\n                            ? new VisualDto.Field { Measure = solidExpr.Measure }\\n                            : new VisualDto.Field { Column = solidExpr.Column };\\n\\n                        if (ToFieldKey(solidField) == oldFieldKey)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                solidExpr.Measure = newField.Measure;\\n                                solidExpr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                solidExpr.Column = newField.Column;\\n                                solidExpr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (obj.Selector?.Metadata == oldMetadata)\\n                {\\n                    obj.Selector.Metadata = newMetadata;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            if (Content.FilterConfig != null)\\n            {\\n                var filterConfigString = Content.FilterConfig.ToString();\\n                string table = isMeasure ? newField.Measure.Expression.SourceRef.Entity : newField.Column.Expression.SourceRef.Entity;\\n                string prop = isMeasure ? newField.Measure.Property : newField.Column.Property;\\n\\n                string oldPattern = oldFieldKey;\\n                string newPattern = $\\\"'{table}'[{prop}]\\\";\\n\\n                if (filterConfigString.Contains(oldPattern))\\n                {\\n                    Content.FilterConfig = filterConfigString.Replace(oldPattern, newPattern);\\n                    wasModified = true;\\n                }\\n            }\\n            if (wasModified && modifiedSet != null)\\n                modifiedSet.Add(this);\\n\\n        }\\n\\n        public void ReplaceInFilterConfigRaw(\\n            Dictionary<string, string> tableMap,\\n            Dictionary<string, string> fieldMap,\\n            HashSet<VisualExtended> modifiedVisuals = null)\\n        {\\n            if (Content.FilterConfig == null) return;\\n\\n            string originalJson = JsonConvert.SerializeObject(Content.FilterConfig);\\n            string updatedJson = originalJson;\\n\\n            foreach (var kv in tableMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            foreach (var kv in fieldMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            // Only update and track if something actually changed\\n            if (updatedJson != originalJson)\\n            {\\n                Content.FilterConfig = JsonConvert.DeserializeObject(updatedJson);\\n                modifiedVisuals?.Add(this);\\n            }\\n        }\\n\\n    }\\n\\n\\n\\n    public class PageExtended\\n    {\\n        public PageDto Page { get; set; }\\n\\n        public ReportExtended ParentReport { get; set; }\\n\\n        public int PageIndex\\n        {\\n            get\\n            {\\n                if (ParentReport == null || ParentReport.PagesConfig == null || ParentReport.PagesConfig.PageOrder == null)\\n                    return -1;\\n                return ParentReport.PagesConfig.PageOrder.IndexOf(Page.Name);\\n            }\\n        }\\n\\n\\n        public IList<VisualExtended> Visuals { get; set; } = new List<VisualExtended>();\\n        public string PageFilePath { get; set; }\\n    }\\n\\n\\n    public class ReportExtended\\n    {\\n        public IList<PageExtended> Pages { get; set; } = new List<PageExtended>();\\n        public string PagesFilePath { get; set; }\\n        public PagesDto PagesConfig { get; set; }\\n    }\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\Report Layer Macros\\Copy Visual",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\n\\n\\nusing Microsoft.VisualBasic;\\nusing System.IO;\\nusing Newtonsoft.Json.Linq;\\n// 2025-07-05/B.Agullo\\n// This script will copy a visual from a template report to the target report. \\n// Target report must be connected with the model that this instance of tabular editor is connected to. \\n// Both target report and template report must use PBIR format\\n// If you are executing this in Tabular Editor 2 you need to \\n// configure Roslyn compiler as explained here:\\n// https://docs.tabulareditor.com/te2/Advanced-Scripting.html#compiling-with-roslyn\\n// Step 1: Initialize source and target reports\\nReportExtended sourceReport = Rx.InitReport(label: @\\\"Select the SOURCE report\\\");\\nif (sourceReport == null) return;\\nReportExtended targetReport = Rx.InitReport(label: @\\\"Select the TARGET report\\\");\\nif (targetReport == null) return;\\n// Step 2: Let user select a single visual from the source report\\nVisualExtended sourceVisual = Rx.SelectVisual(sourceReport);\\nif (sourceVisual == null) return;\\n// Step 3: For each measure and column used, find equivalent in connected model and replace\\nvar referencedMeasures = sourceVisual.GetAllReferencedMeasures().ToList();\\nvar referencedColumns = sourceVisual.GetAllReferencedColumns().ToList();\\n// Prepare replacement maps\\nvar measureReplacementMap = new Dictionary<string, Measure>();\\nvar columnReplacementMap = new Dictionary<string, Column>();\\nforeach (string measureRef in referencedMeasures)\\n{\\n    Measure preselect = Model.AllMeasures.FirstOrDefault(m =>\\n        String.Format(@\\\"{0}[{1}]\\\", m.Table.DaxObjectFullName, m.Name) == measureRef\\n    );\\n    Measure replacement = SelectMeasure(preselect: preselect, label: String.Format(@\\\"Select replacement for measure {0}\\\", measureRef));\\n    if (replacement == null)\\n    {\\n        Error(String.Format(@\\\"No replacement selected for measure {0}.\\\", measureRef));\\n        return;\\n    }\\n    measureReplacementMap[measureRef] = replacement;\\n}\\nforeach (string columnRef in referencedColumns)\\n{\\n    Column preselect = Model.AllColumns.FirstOrDefault(c =>\\n        c.DaxObjectFullName == columnRef\\n    );\\n    Column replacement = SelectColumn(Model.AllColumns, preselect: preselect, label: String.Format(@\\\"Select replacement for column {0}\\\", columnRef));\\n    if (replacement == null)\\n    {\\n        Error(String.Format(@\\\"No replacement selected for column {0}.\\\", columnRef));\\n        return;\\n    }\\n    columnReplacementMap[columnRef] = replacement;\\n}\\n// Step 4: Replace fields in the visual object\\nforeach (var kv in measureReplacementMap)\\n{\\n    sourceVisual.ReplaceMeasure(kv.Key, kv.Value);\\n}\\nforeach (var kv in columnReplacementMap)\\n{\\n    sourceVisual.ReplaceColumn(kv.Key, kv.Value);\\n}\\n// Step 5: Ask in which page of the target report the new visual should be created\\nvar targetPages = targetReport.Pages.ToList();\\nvar pageDisplayList = targetPages.Select(p => p.Page.DisplayName).ToList();\\nstring newPageOption = @\\\"<Create new page>\\\";\\npageDisplayList.Add(newPageOption);\\nstring selectedPageDisplay = Fx.ChooseString(OptionList: pageDisplayList, label: @\\\"Select target page for the new visual\\\");\\nif (String.IsNullOrEmpty(selectedPageDisplay))\\n{\\n    Info(@\\\"No target page selected.\\\");\\n    return;\\n}\\nobject targetPage = null;\\n// Step 5.1: If the user selected the option to create a new page, replicate the first page as blank\\nif (selectedPageDisplay == newPageOption)\\n{\\n    targetPage = Rx.ReplicateFirstPageAsBlank(targetReport);\\n}\\nelse\\n{\\n    targetPage = targetPages.First(p => p.Page.DisplayName == selectedPageDisplay);\\n}\\n// Step 5.2: Assign a new GUID as the visual name to avoid conflicts\\nstring newVisualName = Guid.NewGuid().ToString().Replace(\\\"-\\\", \\\"\\\").Substring(0, 20);\\nsourceVisual.Content.Name = newVisualName;\\n// Step 6: Build new visual file path\\nstring targetPageFolder = Path.GetDirectoryName(((PageExtended)targetPage).PageFilePath);\\nstring visualsFolder = Path.Combine(targetPageFolder, \\\"visuals\\\");\\nstring newVisualJsonPath = Path.Combine(visualsFolder, sourceVisual.Content.Name, \\\"visual.json\\\");\\n// Update visual's file path and parent page\\nsourceVisual.VisualFilePath = newVisualJsonPath;\\n// Step 7: Save the visual generating the visual.json file in the target report\\nRx.SaveVisual(sourceVisual);\\nOutput(String.Format(@\\\"Visual copied to page '{0}' in target report.\\\", ((PageExtended)targetPage).Page.DisplayName));\\n\\npublic static class Fx\\n{\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        return model.Tables.FirstOrDefault(t =>\\n                            string.Equals(t.Name, tableName, StringComparison.OrdinalIgnoreCase)) //case insensitive search\\n                            ?? model.AddCalculatedTable(tableName, tableExpression);\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {\\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList, string label = \\\"Choose item\\\")\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect: false, label:label) as string;\\n    }\\n    public static List<string> ChooseStringMultiple(IList<string> OptionList, string label = \\\"Choose item(s)\\\")\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect:true, label:label) as List<string>;\\n    }\\n    private static object ChooseStringInternal(IList<string> OptionList, bool MultiSelect, string label = \\\"Choose item(s)\\\")\\n    {\\n        Form form = new Form\\n        {\\n            Text =label,\\n            Width = 400,\\n            Height = 500,\\n            StartPosition = FormStartPosition.CenterScreen,\\n            Padding = new Padding(20)\\n        };\\n        ListBox listbox = new ListBox\\n        {\\n            Dock = DockStyle.Fill,\\n            SelectionMode = MultiSelect ? SelectionMode.MultiExtended : SelectionMode.One\\n        };\\n        listbox.Items.AddRange(OptionList.ToArray());\\n        if (!MultiSelect && OptionList.Count > 0)\\n            listbox.SelectedItem = OptionList[0];\\n        FlowLayoutPanel buttonPanel = new FlowLayoutPanel\\n        {\\n            Dock = DockStyle.Bottom,\\n            Height = 40,\\n            FlowDirection = FlowDirection.LeftToRight,\\n            Padding = new Padding(10)\\n        };\\n        Button selectAllButton = new Button { Text = \\\"Select All\\\", Visible = MultiSelect };\\n        Button selectNoneButton = new Button { Text = \\\"Select None\\\", Visible = MultiSelect };\\n        Button okButton = new Button { Text = \\\"OK\\\", DialogResult = DialogResult.OK };\\n        Button cancelButton = new Button { Text = \\\"Cancel\\\", DialogResult = DialogResult.Cancel };\\n        selectAllButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, true);\\n        };\\n        selectNoneButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, false);\\n        };\\n        buttonPanel.Controls.Add(selectAllButton);\\n        buttonPanel.Controls.Add(selectNoneButton);\\n        buttonPanel.Controls.Add(okButton);\\n        buttonPanel.Controls.Add(cancelButton);\\n        form.Controls.Add(listbox);\\n        form.Controls.Add(buttonPanel);\\n        DialogResult result = form.ShowDialog();\\n        if (result == DialogResult.Cancel)\\n        {\\n            Info(\\\"You Cancelled!\\\");\\n            return null;\\n        }\\n        if (MultiSelect)\\n        {\\n            List<string> selectedItems = new List<string>();\\n            foreach (object item in listbox.SelectedItems)\\n                selectedItems.Add(item.ToString());\\n            return selectedItems;\\n        }\\n        else\\n        {\\n            return listbox.SelectedItem != null ? listbox.SelectedItem.ToString() : null;\\n        }\\n    }\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        var dateTables = model.Tables\\n            .Where(t => t.DataCategory == \\\"Time\\\" &&\\n                   t.Columns.Any(c => c.IsKey && c.DataType == DataType.DateTime))\\n            .ToList();\\n        if (!dateTables.Any())\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n            return null;\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        return GetFilteredTables(tables, lambda).FirstOrDefault();\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table, bool> lambda)\\n    {\\n        var filteredTables = tables.Where(t => lambda(t));\\n        return filteredTables.Any() ? filteredTables : null;\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column, bool> lambda, bool returnAllIfNoneFound = true)\\n    {\\n        var filteredColumns = columns.Where(c => lambda(c));\\n        return filteredColumns.Any() || returnAllIfNoneFound ? filteredColumns : null;\\n    }\\n}\\n\\npublic static class Rx\\n\\n{\\n\\n\\n\\n\\n\\n    \\n\\n    \\n\\n    public static VisualExtended DuplicateVisual(VisualExtended visualExtended)\\n\\n    {\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes)\\n\\n        string newVisualName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        string sourceFolder = Path.GetDirectoryName(visualExtended.VisualFilePath);\\n\\n        string targetFolder = Path.Combine(Path.GetDirectoryName(sourceFolder), newVisualName);\\n\\n        if (Directory.Exists(targetFolder))\\n\\n        {\\n\\n            Error(string.Format(\\\"Folder already exists: {0}\\\", targetFolder));\\n\\n            return null;\\n\\n        }\\n\\n        Directory.CreateDirectory(targetFolder);\\n\\n\\n\\n        // Deep clone the VisualDto.Root object\\n\\n        string originalJson = JsonConvert.SerializeObject(visualExtended.Content, Newtonsoft.Json.Formatting.Indented);\\n\\n        VisualDto.Root clonedContent = \\n\\n            JsonConvert.DeserializeObject<VisualDto.Root>(\\n\\n                originalJson, \\n\\n                new JsonSerializerSettings {\\n\\n                    DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                    NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n                });\\n\\n\\n\\n        // Update the name property if it exists\\n\\n        if (clonedContent != null && clonedContent.Name != null)\\n\\n        {\\n\\n            clonedContent.Name = newVisualName;\\n\\n        }\\n\\n\\n\\n        // Set the new file path\\n\\n        string newVisualFilePath = Path.Combine(targetFolder, \\\"visual.json\\\");\\n\\n\\n\\n        // Create the new VisualExtended object\\n\\n        VisualExtended newVisual = new VisualExtended\\n\\n        {\\n\\n            Content = clonedContent,\\n\\n            VisualFilePath = newVisualFilePath\\n\\n        };\\n\\n\\n\\n        return newVisual;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended GroupVisuals(List<VisualExtended> visualsToGroup, string groupName = null, string groupDisplayName = null)\\n\\n    {\\n\\n        if (visualsToGroup == null || visualsToGroup.Count == 0)\\n\\n        {\\n\\n            Error(\\\"No visuals to group.\\\");\\n\\n            return null;\\n\\n        }\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes) if no group name is provided\\n\\n        if (string.IsNullOrEmpty(groupName))\\n\\n        {\\n\\n            groupName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        }\\n\\n        if (string.IsNullOrEmpty(groupDisplayName))\\n\\n        {\\n\\n            groupDisplayName = groupName;\\n\\n        }\\n\\n\\n\\n        // Find minimum X and Y\\n\\n        double minX = visualsToGroup.Min(v => v.Content.Position != null ? (double)v.Content.Position.X : 0);\\n\\n        double minY = visualsToGroup.Min(v => v.Content.Position != null ? (double)v.Content.Position.Y : 0);\\n\\n\\n\\n       //Info(\\\"minX:\\\" + minX.ToString() + \\\", minY: \\\" + minY.ToString());\\n\\n\\n\\n        // Calculate width and height\\n\\n        double groupWidth = 0;\\n\\n        double groupHeight = 0;\\n\\n        foreach (var v in visualsToGroup)\\n\\n        {\\n\\n            if (v.Content != null && v.Content.Position != null)\\n\\n            {\\n\\n                double visualWidth = v.Content.Position != null ? (double)v.Content.Position.Width : 0;\\n\\n                double visualHeight = v.Content.Position != null ? (double)v.Content.Position.Height : 0;\\n\\n                double xOffset = (double)v.Content.Position.X - (double)minX;\\n\\n                double yOffset = (double)v.Content.Position.Y - (double)minY;\\n\\n                double totalWidth = xOffset + visualWidth;\\n\\n                double totalHeight = yOffset + visualHeight;\\n\\n                if (totalWidth > groupWidth) groupWidth = totalWidth;\\n\\n                if (totalHeight > groupHeight) groupHeight = totalHeight;\\n\\n            }\\n\\n        }\\n\\n\\n\\n        // Create the group visual content\\n\\n        var groupContent = new VisualDto.Root\\n\\n        {\\n\\n            Schema = visualsToGroup.FirstOrDefault().Content.Schema,\\n\\n            Name = groupName,\\n\\n            Position = new VisualDto.Position\\n\\n            {\\n\\n                X = minX,\\n\\n                Y = minY,\\n\\n                Width = groupWidth,\\n\\n                Height = groupHeight\\n\\n            },\\n\\n            VisualGroup = new VisualDto.VisualGroup\\n\\n            {\\n\\n                DisplayName = groupDisplayName,\\n\\n                GroupMode = \\\"ScaleMode\\\"\\n\\n            }\\n\\n        };\\n\\n\\n\\n        // Set VisualFilePath for the group visual\\n\\n        // Use the VisualFilePath of the first visual as a template\\n\\n        string groupVisualFilePath = null;\\n\\n        var firstVisual = visualsToGroup.FirstOrDefault(v => !string.IsNullOrEmpty(v.VisualFilePath));\\n\\n        if (firstVisual != null && !string.IsNullOrEmpty(firstVisual.VisualFilePath))\\n\\n        {\\n\\n            string originalPath = firstVisual.VisualFilePath;\\n\\n            string parentDir = Path.GetDirectoryName(Path.GetDirectoryName(originalPath)); // up to 'visuals'\\n\\n            if (!string.IsNullOrEmpty(parentDir))\\n\\n            {\\n\\n                string groupFolder = Path.Combine(parentDir, groupName);\\n\\n                groupVisualFilePath = Path.Combine(groupFolder, \\\"visual.json\\\");\\n\\n            }\\n\\n        }\\n\\n\\n\\n        // Create the new VisualExtended for the group\\n\\n        var groupVisual = new VisualExtended\\n\\n        {\\n\\n            Content = groupContent,\\n\\n            VisualFilePath = groupVisualFilePath // Set as described\\n\\n        };\\n\\n\\n\\n        // Update grouped visuals: set parentGroupName and adjust X/Y\\n\\n        foreach (var v in visualsToGroup)\\n\\n        {\\n\\n            \\n\\n            if (v.Content == null) continue;\\n\\n            v.Content.ParentGroupName = groupName;\\n\\n\\n\\n            if (v.Content.Position != null)\\n\\n            {\\n\\n                v.Content.Position.X = v.Content.Position.X - minX + 0;\\n\\n                v.Content.Position.Y = v.Content.Position.Y - minY + 0;\\n\\n            }\\n\\n        }\\n\\n\\n\\n        return groupVisual;\\n\\n    }\\n\\n\\n\\n    \\n\\n\\n\\n    private static readonly string RecentPathsFile = Path.Combine(\\n\\n    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\\n\\n    \\\"YourAppName\\\", \\\"recentPbirPaths.json\\\");\\n\\n\\n\\n    public static string GetPbirFilePathWithHistory(string label = \\\"Select definition.pbir file\\\")\\n\\n    {\\n\\n        // Load recent paths\\n\\n        List<string> recentPaths = LoadRecentPbirPaths();\\n\\n\\n\\n        // Filter out non-existing files\\n\\n        recentPaths = recentPaths.Where(File.Exists).ToList();\\n\\n\\n\\n        // Present options to the user\\n\\n        var options = new List<string>(recentPaths);\\n\\n        options.Add(\\\"Browse for new file...\\\");\\n\\n\\n\\n        string selected = Fx.ChooseString(options,label:label);\\n\\n\\n\\n        string chosenPath = null;\\n\\n        if (selected == \\\"Browse for new file...\\\" || string.IsNullOrEmpty(selected))\\n\\n        {\\n\\n            chosenPath = GetPbirFilePath(label);\\n\\n        }\\n\\n        else\\n\\n        {\\n\\n            chosenPath = selected;\\n\\n        }\\n\\n\\n\\n        if (!string.IsNullOrEmpty(chosenPath))\\n\\n        {\\n\\n            // Update recent paths\\n\\n            UpdateRecentPbirPaths(chosenPath, recentPaths);\\n\\n        }\\n\\n\\n\\n        return chosenPath;\\n\\n    }\\n\\n\\n\\n    private static List<string> LoadRecentPbirPaths()\\n\\n    {\\n\\n        try\\n\\n        {\\n\\n            if (File.Exists(RecentPathsFile))\\n\\n            {\\n\\n                string json = File.ReadAllText(RecentPathsFile);\\n\\n                return JsonConvert.DeserializeObject<List<string>>(json) ?? new List<string>();\\n\\n            }\\n\\n        }\\n\\n        catch { }\\n\\n        return new List<string>();\\n\\n    }\\n\\n\\n\\n    private static void UpdateRecentPbirPaths(string newPath, List<string> recentPaths)\\n\\n    {\\n\\n        // Remove if already exists, insert at top\\n\\n        recentPaths.RemoveAll(p => string.Equals(p, newPath, StringComparison.OrdinalIgnoreCase));\\n\\n        recentPaths.Insert(0, newPath);\\n\\n\\n\\n        // Keep only the latest 10\\n\\n        while (recentPaths.Count > 10)\\n\\n            recentPaths.RemoveAt(recentPaths.Count - 1);\\n\\n\\n\\n        // Ensure directory exists\\n\\n        Directory.CreateDirectory(Path.GetDirectoryName(RecentPathsFile));\\n\\n        File.WriteAllText(RecentPathsFile, JsonConvert.SerializeObject(recentPaths, Newtonsoft.Json.Formatting.Indented));\\n\\n    }\\n\\n\\n\\n\\n\\n    public static ReportExtended InitReport(string label = \\\"Please select definition.pbir file of the target report\\\")\\n\\n    {\\n\\n        // Get the base path from the user  \\n\\n        string basePath = Rx.GetPbirFilePathWithHistory(label:label);\\n\\n        if (basePath == null)\\n\\n        {\\n\\n            Error(\\\"Operation canceled by the user.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Define the target path  \\n\\n        string baseDirectory = Path.GetDirectoryName(basePath);\\n\\n        string targetPath = Path.Combine(baseDirectory, \\\"definition\\\", \\\"pages\\\");\\n\\n\\n\\n        // Check if the target path exists  \\n\\n        if (!Directory.Exists(targetPath))\\n\\n        {\\n\\n            Error(String.Format(\\\"The path '{0}' does not exist.\\\", targetPath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Get all subfolders in the target path  \\n\\n        List<string> subfolders = Directory.GetDirectories(targetPath).ToList();\\n\\n\\n\\n        string pagesFilePath = Path.Combine(targetPath, \\\"pages.json\\\");\\n\\n        string pagesJsonContent = File.ReadAllText(pagesFilePath);\\n\\n        \\n\\n        if (string.IsNullOrEmpty(pagesJsonContent))\\n\\n        {\\n\\n            Error(String.Format(\\\"The file '{0}' is empty or does not exist.\\\", pagesFilePath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        PagesDto pagesDto = JsonConvert.DeserializeObject<PagesDto>(pagesJsonContent);\\n\\n\\n\\n        ReportExtended report = new ReportExtended();\\n\\n        report.PagesFilePath = pagesFilePath;\\n\\n        report.PagesConfig = pagesDto;\\n\\n\\n\\n        // Process each folder  \\n\\n        foreach (string folder in subfolders)\\n\\n        {\\n\\n            string pageJsonPath = Path.Combine(folder, \\\"page.json\\\");\\n\\n            if (File.Exists(pageJsonPath))\\n\\n            {\\n\\n                try\\n\\n                {\\n\\n                    string jsonContent = File.ReadAllText(pageJsonPath);\\n\\n                    PageDto page = JsonConvert.DeserializeObject<PageDto>(jsonContent);\\n\\n\\n\\n                    PageExtended pageExtended = new PageExtended();\\n\\n                    pageExtended.Page = page;\\n\\n                    pageExtended.PageFilePath = pageJsonPath;\\n\\n\\n\\n                    pageExtended.ParentReport = report;\\n\\n\\n\\n                    string visualsPath = Path.Combine(folder, \\\"visuals\\\");\\n\\n\\n\\n                    if (!Directory.Exists(visualsPath))\\n\\n                    {\\n\\n                        report.Pages.Add(pageExtended); // still add the page\\n\\n                        continue; // skip visual loading\\n\\n                    }\\n\\n\\n\\n                    List<string> visualSubfolders = Directory.GetDirectories(visualsPath).ToList();\\n\\n\\n\\n                    foreach (string visualFolder in visualSubfolders)\\n\\n                    {\\n\\n                        string visualJsonPath = Path.Combine(visualFolder, \\\"visual.json\\\");\\n\\n                        if (File.Exists(visualJsonPath))\\n\\n                        {\\n\\n                            try\\n\\n                            {\\n\\n                                string visualJsonContent = File.ReadAllText(visualJsonPath);\\n\\n                                VisualDto.Root visual = JsonConvert.DeserializeObject<VisualDto.Root>(visualJsonContent);\\n\\n\\n\\n                                VisualExtended visualExtended = new VisualExtended();\\n\\n                                visualExtended.Content = visual;\\n\\n                                visualExtended.VisualFilePath = visualJsonPath;\\n\\n                                visualExtended.ParentPage = pageExtended; // Set parent page reference\\n\\n                                pageExtended.Visuals.Add(visualExtended);\\n\\n                            }\\n\\n                            catch (Exception ex2)\\n\\n                            {\\n\\n                                Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", visualJsonPath, ex2.Message));\\n\\n                                return null;\\n\\n                            }\\n\\n\\n\\n                        }\\n\\n                    }\\n\\n\\n\\n                    report.Pages.Add(pageExtended);\\n\\n\\n\\n                }\\n\\n                catch (Exception ex)\\n\\n                {\\n\\n                    Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", pageJsonPath, ex.Message));\\n\\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        return report;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended SelectVisual(ReportExtended report)\\n\\n    {\\n\\n        // Step 1: Build selection list\\n\\n        var visualSelectionList = report.Pages\\n\\n            .SelectMany(p => p.Visuals.Select(v => new\\n\\n            {\\n\\n                Display = string.Format(\\\"{0} - {1} ({2}, {3})\\\", p.Page.DisplayName, v.Content.Visual.VisualType, (int)v.Content.Position.X, (int)v.Content.Position.Y),\\n\\n                Page = p,\\n\\n                Visual = v\\n\\n            }))\\n\\n            .ToList();\\n\\n\\n\\n        // Step 2: Let user choose a visual\\n\\n        var options = visualSelectionList.Select(v => v.Display).ToList();\\n\\n        string selected = Fx.ChooseString(options);\\n\\n\\n\\n        if (string.IsNullOrEmpty(selected))\\n\\n        {\\n\\n            Info(\\\"You cancelled.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Step 3: Find the selected visual\\n\\n        var selectedVisual = visualSelectionList.FirstOrDefault(v => v.Display == selected);\\n\\n\\n\\n        if (selectedVisual == null)\\n\\n        {\\n\\n            Error(\\\"Selected visual not found.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        return selectedVisual.Visual;\\n\\n    }\\n\\n\\n\\n    public static PageExtended ReplicateFirstPageAsBlank(ReportExtended report, bool showMessages = false)\\n\\n    {\\n\\n        if (report.Pages == null || !report.Pages.Any())\\n\\n        {\\n\\n            Error(\\\"No pages found in the report.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        PageExtended firstPage = report.Pages[0];\\n\\n\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes)\\n\\n        string newPageName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        string newPageDisplayName = firstPage.Page.DisplayName + \\\" - Copy\\\";\\n\\n\\n\\n        string sourceFolder = Path.GetDirectoryName(firstPage.PageFilePath);\\n\\n        string targetFolder = Path.Combine(Path.GetDirectoryName(sourceFolder), newPageName);\\n\\n        string visualsFolder = Path.Combine(targetFolder, \\\"visuals\\\");\\n\\n\\n\\n        if (Directory.Exists(targetFolder))\\n\\n        {\\n\\n            Error($\\\"Folder already exists: {targetFolder}\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        Directory.CreateDirectory(targetFolder);\\n\\n        Directory.CreateDirectory(visualsFolder);\\n\\n\\n\\n        var newPageDto = new PageDto\\n\\n        {\\n\\n            Name = newPageName,\\n\\n            DisplayName = newPageDisplayName,\\n\\n            DisplayOption = firstPage.Page.DisplayOption,\\n\\n            Height = firstPage.Page.Height,\\n\\n            Width = firstPage.Page.Width,\\n\\n            Schema = firstPage.Page.Schema\\n\\n        };\\n\\n\\n\\n        var newPage = new PageExtended\\n\\n        {\\n\\n            Page = newPageDto,\\n\\n            PageFilePath = Path.Combine(targetFolder, \\\"page.json\\\"),\\n\\n            Visuals = new List<VisualExtended>() // empty visuals\\n\\n        };\\n\\n\\n\\n        File.WriteAllText(newPage.PageFilePath, JsonConvert.SerializeObject(newPageDto, Newtonsoft.Json.Formatting.Indented));\\n\\n\\n\\n        report.Pages.Add(newPage);\\n\\n\\n\\n        if(showMessages) Info($\\\"Created new blank page: {newPageName}\\\");\\n\\n\\n\\n        return newPage; \\n\\n    }\\n\\n\\n\\n\\n\\n    public static void SaveVisual(VisualExtended visual)\\n\\n    {\\n\\n\\n\\n        // Save new JSON, ignoring nulls\\n\\n        string newJson = JsonConvert.SerializeObject(\\n\\n            visual.Content,\\n\\n            Newtonsoft.Json.Formatting.Indented,\\n\\n            new JsonSerializerSettings\\n\\n            {\\n\\n                //DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n            }\\n\\n        );\\n\\n        // Ensure the directory exists before saving\\n\\n        string visualFolder = Path.GetDirectoryName(visual.VisualFilePath);\\n\\n        if (!Directory.Exists(visualFolder))\\n\\n        {\\n\\n            Directory.CreateDirectory(visualFolder);\\n\\n        }\\n\\n        File.WriteAllText(visual.VisualFilePath, newJson);\\n\\n    }\\n\\n\\n\\n\\n\\n    public static string ReplacePlaceholders(string pageContents, Dictionary<string, string> placeholders)\\n\\n    {\\n\\n        if (placeholders != null)\\n\\n        {\\n\\n            foreach (string placeholder in placeholders.Keys)\\n\\n            {\\n\\n                string valueToReplace = placeholders[placeholder];\\n\\n\\n\\n                pageContents = pageContents.Replace(placeholder, valueToReplace);\\n\\n\\n\\n            }\\n\\n        }\\n\\n\\n\\n\\n\\n        return pageContents;\\n\\n    }\\n\\n\\n\\n\\n\\n    public static String GetPbirFilePath(string label = \\\"Please select definition.pbir file of the target report\\\")\\n\\n    {\\n\\n\\n\\n        // Create an instance of the OpenFileDialog\\n\\n        OpenFileDialog openFileDialog = new OpenFileDialog\\n\\n        {\\n\\n            Title = label,\\n\\n            // Set filter options and filter index.\\n\\n            Filter = \\\"PBIR Files (*.pbir)|*.pbir\\\",\\n\\n            FilterIndex = 1\\n\\n        };\\n\\n        // Call the ShowDialog method to show the dialog box.\\n\\n        DialogResult result = openFileDialog.ShowDialog();\\n\\n        // Process input if the user clicked OK.\\n\\n        if (result != DialogResult.OK)\\n\\n        {\\n\\n            Error(\\\"You cancelled\\\");\\n\\n            return null;\\n\\n        }\\n\\n        return openFileDialog.FileName;\\n\\n\\n\\n    }\\n\\n\\n\\n\\n\\n}\\n\\n\\n\\n   \\n\\n    public class PagesDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"pageOrder\\\")]\\n        public List<string> PageOrder { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"activePageName\\\")]\\n        public string ActivePageName { get; set; }\\n        \\n    }\\n\\n\\n    public class PageDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"name\\\")]\\n        public string Name { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayName\\\")]\\n        public string DisplayName { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayOption\\\")]\\n        public string DisplayOption { get; set; } // Could create enum if you want stricter typing\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"height\\\")]\\n        public double? Height { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"width\\\")]\\n        public double? Width { get; set; }\\n    }\\n\\n\\n\\n    public partial class VisualDto\\n    {\\n        public class Root\\n        {\\n            [JsonProperty(\\\"$schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"name\\\")] public string Name { get; set; }\\n            [JsonProperty(\\\"position\\\")] public Position Position { get; set; }\\n            [JsonProperty(\\\"visual\\\")] public Visual Visual { get; set; }\\n            \\n\\n            [JsonProperty(\\\"visualGroup\\\")] public VisualGroup VisualGroup { get; set; }\\n            [JsonProperty(\\\"parentGroupName\\\")] public string ParentGroupName { get; set; }\\n            [JsonProperty(\\\"filterConfig\\\")] public object FilterConfig { get; set; }\\n            [JsonProperty(\\\"isHidden\\\")] public bool IsHidden { get; set; }\\n\\n            [JsonExtensionData]\\n            \\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        public class VisualContainerObjects\\n        {\\n            [JsonProperty(\\\"general\\\")]\\n            public List<VisualContainerObject> General { get; set; }\\n\\n            // Add other known properties as needed, e.g.:\\n            [JsonProperty(\\\"title\\\")]\\n            public List<VisualContainerObject> Title { get; set; }\\n\\n            [JsonProperty(\\\"subTitle\\\")]\\n            public List<VisualContainerObject> SubTitle { get; set; }\\n\\n            // This will capture any additional properties not explicitly defined above\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualContainerObject\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            public Dictionary<string, VisualContainerProperty> Properties { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualContainerProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualExpr Expr { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualExpr\\n        {\\n            [JsonProperty(\\\"Literal\\\")]\\n            public VisualLiteral Literal { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualLiteral\\n        {\\n            [JsonProperty(\\\"Value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualGroup\\n        {\\n            [JsonProperty(\\\"displayName\\\")] public string DisplayName { get; set; }\\n            [JsonProperty(\\\"groupMode\\\")] public string GroupMode { get; set; }\\n        }\\n\\n        public class Position\\n        {\\n            [JsonProperty(\\\"x\\\")] public double X { get; set; }\\n            [JsonProperty(\\\"y\\\")] public double Y { get; set; }\\n            [JsonProperty(\\\"z\\\")] public int Z { get; set; }\\n            [JsonProperty(\\\"height\\\")] public double Height { get; set; }\\n            [JsonProperty(\\\"width\\\")] public double Width { get; set; }\\n            [JsonProperty(\\\"tabOrder\\\")] public int TabOrder { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Visual\\n        {\\n            [JsonProperty(\\\"visualType\\\")] public string VisualType { get; set; }\\n            [JsonProperty(\\\"query\\\")] public Query Query { get; set; }\\n            [JsonProperty(\\\"objects\\\")] public Objects Objects { get; set; }\\n            [JsonProperty(\\\"visualContainerObjects\\\")]\\n            public VisualContainerObjects VisualContainerObjects { get; set; }\\n            [JsonProperty(\\\"drillFilterOtherVisuals\\\")] public bool DrillFilterOtherVisuals { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Query\\n        {\\n            [JsonProperty(\\\"queryState\\\")] public QueryState QueryState { get; set; }\\n            [JsonProperty(\\\"sortDefinition\\\")] public SortDefinition SortDefinition { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class QueryState\\n        {\\n            [JsonProperty(\\\"Rows\\\", Order = 1)] public VisualDto.ProjectionsSet Rows { get; set; }\\n            [JsonProperty(\\\"Category\\\", Order = 2)] public VisualDto.ProjectionsSet Category { get; set; }\\n            [JsonProperty(\\\"Y\\\", Order = 3)] public VisualDto.ProjectionsSet Y { get; set; }\\n            [JsonProperty(\\\"Y2\\\", Order = 4)] public VisualDto.ProjectionsSet Y2 { get; set; }\\n            [JsonProperty(\\\"Values\\\", Order = 5)] public VisualDto.ProjectionsSet Values { get; set; }\\n            \\n            [JsonProperty(\\\"Series\\\", Order = 6)] public VisualDto.ProjectionsSet Series { get; set; }\\n            [JsonProperty(\\\"Data\\\", Order = 7)] public VisualDto.ProjectionsSet Data { get; set; }\\n\\n            \\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ProjectionsSet\\n        {\\n            [JsonProperty(\\\"projections\\\")] public List<VisualDto.Projection> Projections { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Projection\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"queryRef\\\")] public string QueryRef { get; set; }\\n            [JsonProperty(\\\"nativeQueryRef\\\")] public string NativeQueryRef { get; set; }\\n            [JsonProperty(\\\"active\\\")] public bool? Active { get; set; }\\n            [JsonProperty(\\\"hidden\\\")] public bool? Hidden { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Field\\n        {\\n            [JsonProperty(\\\"Aggregation\\\")] public VisualDto.Aggregation Aggregation { get; set; }\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")] public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n            [JsonProperty(\\\"Measure\\\")] public VisualDto.MeasureObject Measure { get; set; }\\n            [JsonProperty(\\\"Column\\\")] public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Aggregation\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Function\\\")] public int Function { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class NativeVisualCalculation\\n        {\\n            [JsonProperty(\\\"Language\\\")] public string Language { get; set; }\\n            [JsonProperty(\\\"Expression\\\")] public string Expression { get; set; }\\n            [JsonProperty(\\\"Name\\\")] public string Name { get; set; }\\n\\n            [JsonProperty(\\\"DataType\\\")] public string DataType { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class MeasureObject\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnField\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Expression\\n        {\\n            [JsonProperty(\\\"Column\\\")] public ColumnExpression Column { get; set; }\\n            [JsonProperty(\\\"SourceRef\\\")] public VisualDto.SourceRef SourceRef { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnExpression\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.SourceRef Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SourceRef\\n        {\\n            [JsonProperty(\\\"Schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"Entity\\\")] public string Entity { get; set; }\\n            [JsonProperty(\\\"Source\\\")] public string Source { get; set; }\\n\\n            \\n        }\\n\\n        public class SortDefinition\\n        {\\n            [JsonProperty(\\\"sort\\\")] public List<VisualDto.Sort> Sort { get; set; }\\n            [JsonProperty(\\\"isDefaultSort\\\")] public bool IsDefaultSort { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Sort\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"direction\\\")] public string Direction { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Objects\\n        {\\n            [JsonProperty(\\\"valueAxis\\\")] public List<VisualDto.ObjectProperties> ValueAxis { get; set; }\\n            [JsonProperty(\\\"general\\\")] public List<VisualDto.ObjectProperties> General { get; set; }\\n            [JsonProperty(\\\"data\\\")] public List<VisualDto.ObjectProperties> Data { get; set; }\\n            [JsonProperty(\\\"title\\\")] public List<VisualDto.ObjectProperties> Title { get; set; }\\n            [JsonProperty(\\\"legend\\\")] public List<VisualDto.ObjectProperties> Legend { get; set; }\\n            [JsonProperty(\\\"labels\\\")] public List<VisualDto.ObjectProperties> Labels { get; set; }\\n            [JsonProperty(\\\"dataPoint\\\")] public List<VisualDto.ObjectProperties> DataPoint { get; set; }\\n\\n\\n            [JsonProperty(\\\"referenceLabel\\\")] public List<VisualDto.ObjectProperties> ReferenceLabel { get; set; }\\n            [JsonProperty(\\\"referenceLabelDetail\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelDetail { get; set; }\\n            [JsonProperty(\\\"referenceLabelValue\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelValue { get; set; }\\n\\n            [JsonProperty(\\\"values\\\")] public List<VisualDto.ObjectProperties> Values { get; set; }\\n\\n            [JsonProperty(\\\"y1AxisReferenceLine\\\")] public List<VisualDto.ObjectProperties> Y1AxisReferenceLine { get; set; }\\n\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ObjectProperties\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            [JsonConverter(typeof(PropertiesConverter))]\\n            public Dictionary<string, object> Properties { get; set; }\\n\\n            [JsonProperty(\\\"selector\\\")]\\n            public Selector Selector { get; set; }\\n\\n\\n            [JsonExtensionData] public IDictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n\\n\\n        public class VisualObjectProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")] public Field Expr { get; set; }\\n            [JsonProperty(\\\"solid\\\")] public SolidColor Solid { get; set; }\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n\\n            [JsonProperty(\\\"paragraphs\\\")]\\n            public List<Paragraph> Paragraphs { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Paragraph\\n        {\\n            [JsonProperty(\\\"textRuns\\\")]\\n            public List<TextRun> TextRuns { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class TextRun\\n        {\\n            [JsonProperty(\\\"value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonProperty(\\\"url\\\")]\\n            public string Url { get; set; }\\n\\n            [JsonProperty(\\\"textStyle\\\")]\\n            public Dictionary<string, object> TextStyle { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SolidColor\\n        {\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColorExpression\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualColorExprWrapper Expr { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExprWrapper\\n        {\\n            [JsonProperty(\\\"FillRule\\\")] public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExpression\\n        {\\n            [JsonProperty(\\\"Input\\\")] public VisualDto.Field Input { get; set; }\\n            [JsonProperty(\\\"FillRule\\\")] public Dictionary<string, object> FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualColorExprWrapper\\n        {\\n            [JsonProperty(\\\"Measure\\\")]\\n            public VisualDto.MeasureObject Measure { get; set; }\\n\\n            [JsonProperty(\\\"Column\\\")]\\n            public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonProperty(\\\"Aggregation\\\")]\\n            public VisualDto.Aggregation Aggregation { get; set; }\\n\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")]\\n            public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n\\n            [JsonProperty(\\\"FillRule\\\")]\\n            public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        \\n\\n        public class Selector\\n        {\\n            \\n\\n            [JsonProperty(\\\"id\\\")]\\n            public string Id { get; set; }\\n\\n            [JsonProperty(\\\"order\\\")]\\n            public int? Order { get; set; }\\n\\n            [JsonProperty(\\\"data\\\")]\\n            public List<object> Data { get; set; }\\n\\n            [JsonProperty(\\\"metadata\\\")]\\n            public string Metadata { get; set; }\\n\\n            [JsonProperty(\\\"scopeId\\\")]\\n            public string ScopeId { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class PropertiesConverter : JsonConverter\\n        {\\n            public override bool CanConvert(Type objectType) => objectType == typeof(Dictionary<string, object>);\\n\\n            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)\\n            {\\n                var result = new Dictionary<string, object>();\\n                var jObj = JObject.Load(reader);\\n\\n                foreach (var prop in jObj.Properties())\\n                {\\n                    if (prop.Name == \\\"paragraphs\\\")\\n                    {\\n                        var paragraphs = prop.Value.ToObject<List<Paragraph>>(serializer);\\n                        result[prop.Name] = paragraphs;\\n                    }\\n                    else\\n                    {\\n                        var visualProp = prop.Value.ToObject<VisualObjectProperty>(serializer);\\n                        result[prop.Name] = visualProp;\\n                    }\\n                }\\n\\n                return result;\\n            }\\n\\n            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\\n            {\\n                var dict = (Dictionary<string, object>)value;\\n                writer.WriteStartObject();\\n\\n                foreach (var kvp in dict)\\n                {\\n                    writer.WritePropertyName(kvp.Key);\\n\\n                    if (kvp.Value is VisualObjectProperty vo)\\n                        serializer.Serialize(writer, vo);\\n                    else if (kvp.Value is List<Paragraph> ps)\\n                        serializer.Serialize(writer, ps);\\n                    else\\n                        serializer.Serialize(writer, kvp.Value);\\n                }\\n\\n                writer.WriteEndObject();\\n            }\\n        }\\n    }\\n\\n\\n    public class VisualExtended\\n    {\\n        public VisualDto.Root Content { get; set; }\\n\\n        public string VisualFilePath { get; set; }\\n\\n\\n        public Boolean isVisualGroup => Content?.VisualGroup != null;\\n        public Boolean isGroupedVisual => Content?.ParentGroupName != null;\\n\\n        public bool IsBilingualVisualGroup()\\n        {\\n            if (!isVisualGroup || string.IsNullOrEmpty(Content.VisualGroup.DisplayName))\\n                return false;\\n            return System.Text.RegularExpressions.Regex.IsMatch(Content.VisualGroup.DisplayName, @\\\"^P\\d{2}-\\d{3}$\\\");\\n        }\\n\\n        public PageExtended ParentPage { get; set; }\\n\\n        public bool IsInBilingualVisualGroup()\\n        {\\n            if (ParentPage == null || ParentPage.Visuals == null || Content.ParentGroupName == null)\\n                return false;\\n            return ParentPage.Visuals.Any(v => v.IsBilingualVisualGroup() && v.Content.Name == Content.ParentGroupName);\\n        }\\n\\n        [JsonIgnore]\\n        public string AltText\\n        {\\n            get\\n            {\\n                var general = Content?.Visual?.VisualContainerObjects?.General;\\n                if (general == null || general.Count == 0)\\n                    return null;\\n                if (!general[0].Properties.ContainsKey(\\\"altText\\\"))\\n                    return null;\\n                return general[0].Properties[\\\"altText\\\"]?.Expr?.Literal?.Value?.Trim('\\'');\\n            }\\n            set\\n            {\\n                if(Content?.Visual == null)\\n                    Content.Visual = new VisualDto.Visual();\\n\\n                // Ensure the structure exists\\n                if (Content?.Visual?.VisualContainerObjects == null)\\n                    Content.Visual.VisualContainerObjects = new VisualDto.VisualContainerObjects();\\n\\n                if (Content.Visual?.VisualContainerObjects.General == null || Content.Visual?.VisualContainerObjects.General.Count == 0)\\n                    Content.Visual.VisualContainerObjects.General = \\n                        new List<VisualDto.VisualContainerObject> { \\n                            new VisualDto.VisualContainerObject { \\n                                Properties = new Dictionary<string, VisualDto.VisualContainerProperty>() \\n                            } \\n                        };\\n\\n                var general = Content.Visual.VisualContainerObjects.General[0];\\n\\n                if (general.Properties == null)\\n                    general.Properties = new Dictionary<string, VisualDto.VisualContainerProperty>();\\n\\n                general.Properties[\\\"altText\\\"] = new VisualDto.VisualContainerProperty\\n                {\\n                    Expr = new VisualDto.VisualExpr\\n                    {\\n                        Literal = new VisualDto.VisualLiteral\\n                        {\\n                            Value = value == null ? null : \\\"'\\\" + value.Replace(\\\"'\\\", \\\"\\\\'\\\") + \\\"'\\\"\\n                        }\\n                    }\\n                };\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetAllFields()\\n        {\\n            var fields = new List<VisualDto.Field>();\\n            var queryState = Content?.Visual?.Query?.QueryState;\\n\\n            if (queryState != null)\\n            {\\n                fields.AddRange(GetFieldsFromProjections(queryState.Values));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y2));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Category));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Series));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Data));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Rows));\\n            }\\n\\n            var sortList = Content?.Visual?.Query?.SortDefinition?.Sort;\\n            if (sortList != null)\\n                fields.AddRange(sortList.Select(s => s.Field));\\n\\n            var objects = Content?.Visual?.Objects;\\n            if (objects != null)\\n            {\\n                fields.AddRange(GetFieldsFromObjectList(objects.DataPoint));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Data));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Labels));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Title));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Legend));\\n                fields.AddRange(GetFieldsFromObjectList(objects.General));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ValueAxis));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Y1AxisReferenceLine));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabel));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelDetail));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelValue));\\n\\n            }\\n\\n            fields.AddRange(GetFieldsFromFilterConfig(Content?.FilterConfig));\\n\\n            return fields.Where(f => f != null);\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromProjections(VisualDto.ProjectionsSet set)\\n        {\\n            return set?.Projections?.Select(p => p.Field) ?? Enumerable.Empty<VisualDto.Field>();\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromObjectList(List<VisualDto.ObjectProperties> objectList)\\n        {\\n            if (objectList == null) yield break;\\n\\n            foreach (var obj in objectList)\\n            {\\n                if (obj.Properties == null) continue;\\n\\n                foreach (var val in obj.Properties.Values)\\n                {\\n                    var prop = val as VisualDto.VisualObjectProperty;\\n                    if (prop == null) continue;\\n\\n                    if (prop.Expr != null)\\n                    {\\n                        if (prop.Expr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = prop.Expr.Measure };\\n\\n                        if (prop.Expr.Column != null)\\n                            yield return new VisualDto.Field { Column = prop.Expr.Column };\\n                    }\\n\\n                    if (prop.Color != null &&\\n                        prop.Color.Expr != null &&\\n                        prop.Color.Expr.FillRule != null &&\\n                        prop.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    if (prop.Solid != null &&\\n                        prop.Solid.Color != null &&\\n                        prop.Solid.Color.Expr != null &&\\n                        prop.Solid.Color.Expr.FillRule != null &&\\n                        prop.Solid.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Solid.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    var solidExpr = prop.Solid != null &&\\n                                    prop.Solid.Color != null\\n                                    ? prop.Solid.Color.Expr\\n                                    : null;\\n\\n                    if (solidExpr != null)\\n                    {\\n                        if (solidExpr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = solidExpr.Measure };\\n\\n                        if (solidExpr.Column != null)\\n                            yield return new VisualDto.Field { Column = solidExpr.Column };\\n                    }\\n                }\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromFilterConfig(object filterConfig)\\n        {\\n            var fields = new List<VisualDto.Field>();\\n\\n            if (filterConfig is JObject jObj)\\n            {\\n                foreach (var token in jObj.DescendantsAndSelf().OfType<JObject>())\\n                {\\n                    var table = token[\\\"table\\\"]?.ToString();\\n                    var property = token[\\\"column\\\"]?.ToString() ?? token[\\\"measure\\\"]?.ToString();\\n\\n                    if (!string.IsNullOrEmpty(table) && !string.IsNullOrEmpty(property))\\n                    {\\n                        var field = new VisualDto.Field();\\n\\n                        if (token[\\\"measure\\\"] != null)\\n                        {\\n                            field.Measure = new VisualDto.MeasureObject\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n                        else if (token[\\\"column\\\"] != null)\\n                        {\\n                            field.Column = new VisualDto.ColumnField\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n\\n                        fields.Add(field);\\n                    }\\n                }\\n            }\\n\\n            return fields;\\n        }\\n\\n\\n        public IEnumerable<string> GetAllReferencedMeasures()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Measure)\\n                .Where(m => m?.Expression?.SourceRef?.Entity != null && m.Property != null)\\n                .Select(m => $\\\"'{m.Expression.SourceRef.Entity}'[{m.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public IEnumerable<string> GetAllReferencedColumns()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Column)\\n                .Where(c => c?.Expression?.SourceRef?.Entity != null && c.Property != null)\\n                .Select(c => $\\\"'{c.Expression.SourceRef.Entity}'[{c.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public void ReplaceMeasure(string oldFieldKey, Measure newMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Measure = new VisualDto.MeasureObject\\n                {\\n                    Property = newMeasure.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newMeasure.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: true, modifiedSet);\\n        }\\n\\n        public void ReplaceColumn(string oldFieldKey, Column newColumn, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Column = new VisualDto.ColumnField\\n                {\\n                    Property = newColumn.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newColumn.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: false, modifiedSet);\\n        }\\n\\n        private string ToFieldKey(VisualDto.Field f)\\n        {\\n            if (f?.Measure?.Expression?.SourceRef?.Entity is string mEntity && f.Measure.Property is string mProp)\\n                return $\\\"'{mEntity}'[{mProp}]\\\";\\n\\n            if (f?.Column?.Expression?.SourceRef?.Entity is string cEntity && f.Column.Property is string cProp)\\n                return $\\\"'{cEntity}'[{cProp}]\\\";\\n\\n            return null;\\n        }\\n\\n        private void ReplaceField(string oldFieldKey, VisualDto.Field newField, bool isMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var query = Content?.Visual?.Query;\\n            var objects = Content?.Visual?.Objects;\\n            bool wasModified = false;\\n\\n            void Replace(VisualDto.Field f)\\n            {\\n                if (f == null) return;\\n\\n                if (isMeasure)\\n                {\\n                    f.Measure = newField.Measure;\\n                    f.Column = null;\\n                    wasModified = true;\\n                }\\n                else\\n                {\\n                    f.Column = newField.Column;\\n                    f.Measure = null;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            void UpdateProjection(VisualDto.Projection proj)\\n            {\\n                if (proj == null) return;\\n\\n                if (ToFieldKey(proj.Field) == oldFieldKey)\\n                {\\n                    Replace(proj.Field);\\n\\n                    string entity = isMeasure\\n                        ? newField.Measure.Expression?.SourceRef?.Entity\\n                        : newField.Column.Expression?.SourceRef?.Entity;\\n\\n                    string prop = isMeasure\\n                        ? newField.Measure.Property\\n                        : newField.Column.Property;\\n\\n                    if (!string.IsNullOrEmpty(entity) && !string.IsNullOrEmpty(prop))\\n                    {\\n                        proj.QueryRef = $\\\"{entity}.{prop}\\\";\\n                        //proj.NativeQueryRef = prop;\\n                    }\\n\\n                    wasModified = true;\\n                }\\n            }\\n\\n            foreach (var proj in query?.QueryState?.Values?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Y?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n            \\n            foreach (var proj in query?.QueryState?.Y2?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Category?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Series?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Data?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Rows?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var sort in query?.SortDefinition?.Sort ?? Enumerable.Empty<VisualDto.Sort>())\\n                if (ToFieldKey(sort.Field) == oldFieldKey) Replace(sort.Field);\\n\\n            string oldMetadata = oldFieldKey.Replace(\\\"'\\\", \\\"\\\").Replace(\\\"[\\\", \\\".\\\").Replace(\\\"]\\\", \\\"\\\");\\n            string newMetadata = isMeasure\\n                ? $\\\"{newField.Measure.Expression.SourceRef.Entity}.{newField.Measure.Property}\\\"\\n                : $\\\"{newField.Column.Expression.SourceRef.Entity}.{newField.Column.Property}\\\";\\n\\n            IEnumerable<VisualDto.ObjectProperties> AllObjectProperties() =>\\n                (objects?.DataPoint ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Data ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Labels ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Title ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Legend ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.General ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ValueAxis ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabel ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelDetail ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelValue ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Values ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Y1AxisReferenceLine ?? Enumerable.Empty<VisualDto.ObjectProperties>());\\n\\n            foreach (var obj in AllObjectProperties())\\n            {\\n                foreach (var prop in obj.Properties.Values.OfType<VisualDto.VisualObjectProperty>())\\n                {\\n                    var field = isMeasure ? new VisualDto.Field { Measure = prop.Expr?.Measure } : new VisualDto.Field { Column = prop.Expr?.Column };\\n                    if (ToFieldKey(field) == oldFieldKey)\\n                    {\\n                        if (prop.Expr != null)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                prop.Expr.Measure = newField.Measure;\\n                                prop.Expr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                prop.Expr.Column = newField.Column;\\n                                prop.Expr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n\\n                    var fillInput = prop.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(fillInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            fillInput.Measure = newField.Measure;\\n                            fillInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            fillInput.Column = newField.Column;\\n                            fillInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    var solidInput = prop.Solid?.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(solidInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            solidInput.Measure = newField.Measure;\\n                            solidInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            solidInput.Column = newField.Column;\\n                            solidInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    // ✅ NEW: handle direct measure/column under solid.color.expr\\n                    var solidExpr = prop.Solid?.Color?.Expr;\\n                    if (solidExpr != null)\\n                    {\\n                        var solidField = isMeasure\\n                            ? new VisualDto.Field { Measure = solidExpr.Measure }\\n                            : new VisualDto.Field { Column = solidExpr.Column };\\n\\n                        if (ToFieldKey(solidField) == oldFieldKey)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                solidExpr.Measure = newField.Measure;\\n                                solidExpr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                solidExpr.Column = newField.Column;\\n                                solidExpr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (obj.Selector?.Metadata == oldMetadata)\\n                {\\n                    obj.Selector.Metadata = newMetadata;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            if (Content.FilterConfig != null)\\n            {\\n                var filterConfigString = Content.FilterConfig.ToString();\\n                string table = isMeasure ? newField.Measure.Expression.SourceRef.Entity : newField.Column.Expression.SourceRef.Entity;\\n                string prop = isMeasure ? newField.Measure.Property : newField.Column.Property;\\n\\n                string oldPattern = oldFieldKey;\\n                string newPattern = $\\\"'{table}'[{prop}]\\\";\\n\\n                if (filterConfigString.Contains(oldPattern))\\n                {\\n                    Content.FilterConfig = filterConfigString.Replace(oldPattern, newPattern);\\n                    wasModified = true;\\n                }\\n            }\\n            if (wasModified && modifiedSet != null)\\n                modifiedSet.Add(this);\\n\\n        }\\n\\n        public void ReplaceInFilterConfigRaw(\\n            Dictionary<string, string> tableMap,\\n            Dictionary<string, string> fieldMap,\\n            HashSet<VisualExtended> modifiedVisuals = null)\\n        {\\n            if (Content.FilterConfig == null) return;\\n\\n            string originalJson = JsonConvert.SerializeObject(Content.FilterConfig);\\n            string updatedJson = originalJson;\\n\\n            foreach (var kv in tableMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            foreach (var kv in fieldMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            // Only update and track if something actually changed\\n            if (updatedJson != originalJson)\\n            {\\n                Content.FilterConfig = JsonConvert.DeserializeObject(updatedJson);\\n                modifiedVisuals?.Add(this);\\n            }\\n        }\\n\\n    }\\n\\n\\n\\n    public class PageExtended\\n    {\\n        public PageDto Page { get; set; }\\n\\n        public ReportExtended ParentReport { get; set; }\\n\\n        public int PageIndex\\n        {\\n            get\\n            {\\n                if (ParentReport == null || ParentReport.PagesConfig == null || ParentReport.PagesConfig.PageOrder == null)\\n                    return -1;\\n                return ParentReport.PagesConfig.PageOrder.IndexOf(Page.Name);\\n            }\\n        }\\n\\n\\n        public IList<VisualExtended> Visuals { get; set; } = new List<VisualExtended>();\\n        public string PageFilePath { get; set; }\\n    }\\n\\n\\n    public class ReportExtended\\n    {\\n        public IList<PageExtended> Pages { get; set; } = new List<PageExtended>();\\n        public string PagesFilePath { get; set; }\\n        public PagesDto PagesConfig { get; set; }\\n    }\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\Report Layer Macros\\Create Data Problems Button",
      "Enabled": "true",
      "Execute": "using System.Windows.Forms;\\nusing System.IO;\\n// '2024-07-10 / B.Agullo / \\n// Instructions:\\n// execute after running latest version of dataProblemsButtomMeasureCreation macro\\n// See https://www.esbrina-ba.com/c-scripting-the-report-layer-with-tabular-editor/ for detail\\n\\n\\n/*uncomment in TE3 to avoid wating cursor infront of dialogs*/\\n\\n//ScriptHelper.WaitFormVisible = false;\\n//\\n//bool waitCursor = Application.UseWaitCursor;\\n//Application.UseWaitCursor = false;\\n\\nDialogResult dialogResult = MessageBox.Show(text:\\\"Did you save changes in PBI Desktop before running this macro?\\\", caption:\\\"Saved changes?\\\", buttons:MessageBoxButtons.YesNo);\\n\\nif(dialogResult != DialogResult.Yes){\\n    Info(\\\"Please save your changes first and then run this macro\\\"); \\n    return; \\n};\\n\\nstring annotationLabel = \\\"DataProblemsMeasures\\\";\\nstring annotationValueNavigation = \\\"ButtonNavigationMeasure\\\";\\nstring annotationValueText = \\\"ButtonTextMeasure\\\";\\nstring annotationValueBackground = \\\"ButtonBackgroundMeasure\\\";\\nstring[] annotationArray = new string[3] { annotationValueNavigation, annotationValueText, annotationValueBackground };\\nforeach(string annotation in annotationArray)\\n{\\n    if(!Model.AllMeasures.Any(m => m.GetAnnotation(annotationLabel) == annotation))\\n    {\\n        Error(String.Format(\\\"No measure found with annotation {0} = {1} \\\", annotationLabel, annotationValueNavigation));\\n        return;\\n    }\\n}\\n\\n\\n// Create an instance of the OpenFileDialog\\nOpenFileDialog openFileDialog = new OpenFileDialog();\\n\\nopenFileDialog.Title = \\\"Please select definition.pbir file of the target report\\\";\\n// Set filter options and filter index.\\nopenFileDialog.Filter = \\\"PBIR Files (*.pbir)|*.pbir\\\";\\nopenFileDialog.FilterIndex = 1;\\n\\n// Call the ShowDialog method to show the dialog box.\\nDialogResult result = openFileDialog.ShowDialog();\\n\\n// Process input if the user clicked OK.\\nif (result != DialogResult.OK)\\n{\\n    Error(\\\"You cancelled\\\");\\n    return;\\n}\\n\\n// Get the file name.\\nstring pbirFilePath = openFileDialog.FileName;\\n    \\n\\n\\nstring newPageId = Guid.NewGuid().ToString();\\n\\nstring newVisualId = Guid.NewGuid().ToString();\\n\\n\\n\\n\\nMeasure navigationMeasure = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annotationLabel) == annotationValueNavigation)\\n        .FirstOrDefault();\\nMeasure textMeasure = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annotationLabel) == annotationValueText)\\n        .FirstOrDefault();\\nMeasure backgroundMeasure = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annotationLabel) == annotationValueBackground)\\n        .FirstOrDefault();\\n\\n\\n\\nstring newPageContent =@\\\"\\n{\\n  \\\"\\\"$schema\\\"\\\": \\\"\\\"https://developer.microsoft.com/json-schemas/fabric/item/report/definition/page/1.0.0/schema.json\\\"\\\",\\n  \\\"\\\"name\\\"\\\": \\\"\\\"{{newPageId}}\\\"\\\",\\n  \\\"\\\"displayName\\\"\\\": \\\"\\\"Problems Button\\\"\\\",\\n  \\\"\\\"displayOption\\\"\\\": \\\"\\\"FitToPage\\\"\\\",\\n  \\\"\\\"height\\\"\\\": 720,\\n  \\\"\\\"width\\\"\\\": 1280\\n}\\\";\\n \\n\\n\\nstring newVisualContent = @\\\"{\\n\t\\\"\\\"$schema\\\"\\\": \\\"\\\"https://developer.microsoft.com/json-schemas/fabric/item/report/definition/visualContainer/1.0.0/schema.json\\\"\\\",\\n\t\\\"\\\"name\\\"\\\": \\\"\\\"{{newVisualId}}\\\"\\\",\\n\t\\\"\\\"position\\\"\\\": {\\n\t\t\\\"\\\"x\\\"\\\": 510.44776119402987,\\n\t\t\\\"\\\"y\\\"\\\": 256.1194029850746,\\n\t\t\\\"\\\"z\\\"\\\": 0,\\n\t\t\\\"\\\"width\\\"\\\": 188.0597014925373,\\n\t\t\\\"\\\"height\\\"\\\": 50.14925373134328\\n\t},\\n\t\\\"\\\"visual\\\"\\\": {\\n\t\t\\\"\\\"visualType\\\"\\\": \\\"\\\"actionButton\\\"\\\",\\n\t\t\\\"\\\"objects\\\"\\\": {\\n\t\t\t\\\"\\\"icon\\\"\\\": [\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"shapeType\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"'blank'\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t},\\n\t\t\t\t\t\\\"\\\"selector\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"id\\\"\\\": \\\"\\\"default\\\"\\\"\\n\t\t\t\t\t}\\n\t\t\t\t},\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"show\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"false\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t],\\n\t\t\t\\\"\\\"outline\\\"\\\": [\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"show\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"false\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t],\\n\t\t\t\\\"\\\"text\\\"\\\": [\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"show\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"true\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t},\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"text\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Measure\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Expression\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\\\"\\\"SourceRef\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"Entity\\\"\\\": \\\"\\\"{{textMeasureTable}}\\\"\\\"\\n\t\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\t},\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Property\\\"\\\": \\\"\\\"{{textMeasureName}}\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t},\\n\t\t\t\t\t\t\\\"\\\"bold\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"true\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t},\\n\t\t\t\t\t\t\\\"\\\"fontColor\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"solid\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"color\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\\\"\\\"ThemeDataColor\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"ColorId\\\"\\\": 0,\\n\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"Percent\\\"\\\": 0\\n\t\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t},\\n\t\t\t\t\t\\\"\\\"selector\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"id\\\"\\\": \\\"\\\"default\\\"\\\"\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t],\\n\t\t\t\\\"\\\"fill\\\"\\\": [\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"show\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"true\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t},\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"fillColor\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"solid\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"color\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\\\"\\\"Measure\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"Expression\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"SourceRef\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"Entity\\\"\\\": \\\"\\\"{{backgroundMeasureTable}}\\\"\\\"\\n\t\t\t\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\t\t\t},\\n\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"Property\\\"\\\": \\\"\\\"{{backgroundMeasureName}}\\\"\\\"\\n\t\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t},\\n\t\t\t\t\t\t\\\"\\\"transparency\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"0D\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t},\\n\t\t\t\t\t\\\"\\\"selector\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"id\\\"\\\": \\\"\\\"default\\\"\\\"\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t]\\n\t\t},\\n\t\t\\\"\\\"visualContainerObjects\\\"\\\": {\\n\t\t\t\\\"\\\"visualLink\\\"\\\": [\\n\t\t\t\t{\\n\t\t\t\t\t\\\"\\\"properties\\\"\\\": {\\n\t\t\t\t\t\t\\\"\\\"show\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"true\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t},\\n\t\t\t\t\t\t\\\"\\\"type\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Literal\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Value\\\"\\\": \\\"\\\"'PageNavigation'\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t},\\n\t\t\t\t\t\t\\\"\\\"navigationSection\\\"\\\": {\\n\t\t\t\t\t\t\t\\\"\\\"expr\\\"\\\": {\\n\t\t\t\t\t\t\t\t\\\"\\\"Measure\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Expression\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\\\"\\\"SourceRef\\\"\\\": {\\n\t\t\t\t\t\t\t\t\t\t\t\\\"\\\"Entity\\\"\\\": \\\"\\\"{{navigationMeasureTable}}\\\"\\\"\\n\t\t\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t\t\t},\\n\t\t\t\t\t\t\t\t\t\\\"\\\"Property\\\"\\\": \\\"\\\"{{navigationMeasureName}}\\\"\\\"\\n\t\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t\t}\\n\t\t\t\t\t\t}\\n\t\t\t\t\t}\\n\t\t\t\t}\\n\t\t\t]\\n\t\t},\\n\t\t\\\"\\\"drillFilterOtherVisuals\\\"\\\": true\\n\t},\\n\t\\\"\\\"howCreated\\\"\\\": \\\"\\\"InsertVisualButton\\\"\\\"\\n}\\\";\\n\\n\\nDictionary<string,string> placeholders = new Dictionary<string,string>();\\nplaceholders.Add(\\\"{{newPageId}}\\\", newPageId);\\nplaceholders.Add(\\\"{{newVisualId}}\\\", newVisualId);\\nplaceholders.Add(\\\"{{textMeasureTable}}\\\",textMeasure.Table.Name);\\nplaceholders.Add(\\\"{{textMeasureName}}\\\",textMeasure.Name);\\nplaceholders.Add(\\\"{{backgroundMeasureTable}}\\\",backgroundMeasure.Table.Name);\\nplaceholders.Add(\\\"{{backgroundMeasureName}}\\\",backgroundMeasure.Name);\\nplaceholders.Add(\\\"{{navigationMeasureTable}}\\\",navigationMeasure.Table.Name);\\nplaceholders.Add(\\\"{{navigationMeasureName}}\\\",navigationMeasure.Name);\\n\\n\\nnewPageContent = ReportManager.ReplacePlaceholders(newPageContent,placeholders);\\nnewVisualContent = ReportManager.ReplacePlaceholders(newVisualContent, placeholders);\\nReportManager.AddNewPage(newPageContent, newVisualContent,pbirFilePath,newPageId,newVisualId);\\n\\n\\n\\nInfo(\\\"New page added successfully. Close your PBIP project on Power BI desktop *without saving changes* and open again to see the new page with the button.\\\");\\n//Application.UseWaitCursor = waitCursor;\\n\\npublic static class ReportManager\\n{\\n\\n    public static string ReplacePlaceholders(string jsonContents, Dictionary<string, string> placeholders)\\n    {\\n        foreach(string placeholder in placeholders.Keys)\\n        {\\n            string valueToReplace = placeholders[placeholder];\\n\\n            jsonContents = jsonContents.Replace(placeholder, valueToReplace);\\n\\n        }\\n\\n        return jsonContents;\\n    }\\n    \\n    \\n    public static void AddNewPage(string pageContents, string visualContents, string pbirFilePath, string newPageId, string newVisualId)\\n    {\\n        \\n        FileInfo pbirFileInfo = new FileInfo(pbirFilePath);\\n\\n        string pbirFolder = pbirFileInfo.Directory.FullName;\\n        string pagesFolder = Path.Combine(pbirFolder, \\\"definition\\\", \\\"pages\\\");\\n        string pagesFilePath = Path.Combine(pagesFolder, \\\"pages.json\\\");\\n\\n        string newPageFolder = Path.Combine(pagesFolder, newPageId);\\n\\n        Directory.CreateDirectory(newPageFolder);\\n\\n        string newPageFilePath = Path.Combine(newPageFolder, \\\"page.json\\\");\\n        File.WriteAllText(newPageFilePath, pageContents);\\n\\n        string visualsFolder = Path.Combine(newPageFolder,\\\"visuals\\\");\\n        Directory.CreateDirectory(visualsFolder);\\n\\n        string newVisualFolder = Path.Combine(visualsFolder,newVisualId);\\n        Directory.CreateDirectory(newVisualFolder); \\n\\n        string newVisualFilePath = Path.Combine(newVisualFolder,\\\"visual.json\\\"); \\n        File.WriteAllText(newVisualFilePath,visualContents); \\n\\n        AddPageIdToPages(pagesFilePath, newPageId);\\n    }\\n\\n    private static void AddPageIdToPages(string pagesFilePath, string pageId)\\n    {\\n        string pagesFileContents = File.ReadAllText(pagesFilePath);\\n        PagesDto pagesDto = JsonConvert.DeserializeObject<PagesDto>(pagesFileContents);\\n        if(pagesDto.pageOrder == null)\\n        {\\n            pagesDto.pageOrder = new List<string>();\\n        }\\n        \\n\\n        if (!pagesDto.pageOrder.Contains(pageId)) { \\n\\n            pagesDto.pageOrder.Add(pageId);\\n            string resultFile = JsonConvert.SerializeObject(pagesDto, Formatting.Indented);\\n            File.WriteAllText(pagesFilePath, resultFile);\\n        }\\n    }\\n}\\n\\npublic class PagesDto\\n{\\n    [JsonProperty(\\\"$schema\\\")]\\n    public string schema { get; set; }\\n    public List<string> pageOrder { get; set; }\\n    public string activePageName { get; set; }\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\Report Layer Macros\\Create Referential Integrity Page",
      "Enabled": "true",
      "Execute": "using Microsoft.VisualBasic;\\nusing System.Windows.Forms;\\nusing System.IO;\\n\\n// '2024-07-14 / B.Agullo / \\n//\\n// Requirements:\\n// execute after running the Referential integrity check measures script (version  2024-07-13 or later)\\n// https://github.com/bernatagulloesbrina/TabularEditor-Scripts/blob/main/Advanced/One-Click%20Macros/Referential%20Integrity%20Check%20Measures.csx\\n// \\n// See blog posts here: \\n// https://www.esbrina-ba.com/easy-management-of-referential-integrity/\\n// https://www.esbrina-ba.com/building-a-referential-integrity-report-page-with-a-c-script/\\n\\n\\nstring pageName = \\\"Referential Integrity\\\";\\nint interObjectGap = 15; \\nint totalCardX = interObjectGap;\\nint totalCardY = interObjectGap;\\nint totalCardWidth = 300;\\nint totalCardHeight = 150;\\nint detailCardFontSize = 14;\\nint detailCardX = interObjectGap;\\nint detailCardY = totalCardY + totalCardHeight + interObjectGap;\\nint detailCardWidth = 300;\\nint detailCardHeight = 200;\\nint tableHorizontalGap = 10;\\nint tablesPerRow = 3;\\nint tableHeight = 250;\\nint tableWidth = 300;\\nint backgroundTransparency = 0;\\nstring backgroundColor = \\\"#F0ECEC\\\"; \\n\\n// do not modify below this line -- \\nstring annLabel = \\\"ReferencialIntegrityMeasures\\\";\\nstring annValueTotal = \\\"TotalUnmappedItems\\\";\\nstring annValueDetail = \\\"DataProblems\\\";\\nstring annValueDataQualityMeasures = \\\"DataQualityMeasure\\\";\\nstring annValueDataQualityTitles = \\\"DataQualityTitle\\\";\\nstring annValueDataQualitySubtitles = \\\"DataQualitySubitle\\\";\\nstring annValueFactColumn = \\\"FactColumn\\\";\\n\\n/*uncomment in TE3 to avoid wating cursor infront of dialogs*/\\n\\nScriptHelper.WaitFormVisible = false;\\n\\nbool waitCursor = Application.UseWaitCursor;\\nApplication.UseWaitCursor = false;\\n\\nDialogResult dialogResult = MessageBox.Show(text:\\\"Did you save changes in PBI Desktop before running this macro?\\\", caption:\\\"Saved changes?\\\", buttons:MessageBoxButtons.YesNo);\\n\\nif(dialogResult != DialogResult.Yes){\\n    Info(\\\"Please save your changes first and then run this macro\\\"); \\n    return; \\n};\\n\\n\\n\\nstring[] annotationArray = new string[4] { annValueTotal, annValueDetail, annValueDataQualityMeasures, annValueDataQualityTitles };\\nforeach (string annotation in annotationArray)\\n{\\n    if (!Model.AllMeasures.Any(m => m.GetAnnotation(annLabel).StartsWith(annotation)))\\n    {\\n        Error(String.Format(\\\"No measure found with annotation {0} starting with {1} \\\", annLabel, annotation));\\n        return;\\n    }\\n}\\nMeasure totalMeasure = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annLabel) == annValueTotal)\\n        .FirstOrDefault();\\nMeasure detailMeasure = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annLabel) == annValueDetail)\\n        .FirstOrDefault();\\nIList<Measure> dataQualityMeasures = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annLabel) != null\\n            && m.GetAnnotation(annLabel).StartsWith(annValueDataQualityMeasures))\\n        .OrderBy(m => m.GetAnnotation(annLabel))\\n        .ToList<Measure>();\\n\\nIList<Measure> dataQualityTitles = \\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annLabel) != null\\n            && m.GetAnnotation(annLabel).StartsWith(annValueDataQualityTitles))\\n        .OrderBy(m => m.GetAnnotation(annLabel))\\n        .ToList<Measure>();\\n\\n\\nIList<Measure> dataQualitySubtitles =\\n    Model.AllMeasures\\n        .Where(m => m.GetAnnotation(annLabel) != null\\n            && m.GetAnnotation(annLabel).StartsWith(annValueDataQualitySubtitles))\\n        .OrderBy(m => m.GetAnnotation(annLabel))\\n        .ToList<Measure>();\\n\\nIList<Column> factTableColumns =\\n    Model.AllColumns\\n        .Where(c => c.GetAnnotation(annLabel) != null\\n            && c.GetAnnotation(annLabel).StartsWith(annValueFactColumn))\\n        .OrderBy(c => c.GetAnnotation(annLabel))\\n        .ToList<Column>();\\n//now that we now number of tables we'll need, let's set up the page size. \\nint tableCount = dataQualityMeasures.Count();\\ndecimal rowsRaw = (decimal) tableCount / (decimal) tablesPerRow;\\nint rowsOfTables = (int)Math.Ceiling(rowsRaw);\\nint pageWidth = totalCardX + totalCardWidth + interObjectGap + (tableWidth + interObjectGap) * tablesPerRow ;\\nint totalTablesHeight = interObjectGap + (tableHeight + interObjectGap) * rowsOfTables;\\nint totalCardsHeight = detailCardY + detailCardHeight + interObjectGap;\\nint pageHeight = Math.Max(totalTablesHeight,totalCardsHeight); \\n\\n//adjust detail card height to fill the height if tables are taller\\ndetailCardHeight = pageHeight - 3 * interObjectGap - totalCardHeight;\\n\\n// Create an instance of the OpenFileDialog\\nOpenFileDialog openFileDialog = new OpenFileDialog();\\nopenFileDialog.Title = \\\"Please select definition.pbir file of the target report\\\";\\n// Set filter options and filter index.\\nopenFileDialog.Filter = \\\"PBIR Files (*.pbir)|*.pbir\\\";\\nopenFileDialog.FilterIndex = 1;\\n// Call the ShowDialog method to show the dialog box.\\nDialogResult result = openFileDialog.ShowDialog();\\n// Process input if the user clicked OK.\\nif (result != DialogResult.OK)\\n{\\n    Error(\\\"You cancelled\\\");\\n    return;\\n}\\n// Get the file name.\\nstring pbirFilePath = openFileDialog.FileName;\\nstring pageContentsTemplate = @\\\"\\n{\\n    \\\"\\\"$schema\\\"\\\": \\\"\\\"https://developer.microsoft.com/json-schemas/fabric/item/report/definition/page/1.0.0/schema.json\\\"\\\",\\n    \\\"\\\"name\\\"\\\": \\\"\\\"{{newPageId}}\\\"\\\",\\n    \\\"\\\"displayName\\\"\\\": \\\"\\\"Referential Integrity\\\"\\\",\\n    \\\"\\\"displayOption\\\"\\\": \\\"\\\"FitToPage\\\"\\\",\\n    \\\"\\\"height\\\"\\\": {{pageHeight}},\\n    \\\"\\\"width\\\"\\\": {{pageWidth}},\\n    \\\"\\\"objects\\\"\\\": {\\n        \\\"\\\"background\\\"\\\": [\\n          {\\n            \\\"\\\"properties\\\"\\\": {\\n              \\\"\\\"transparency\\\"\\\": {\\n                \\\"\\\"expr\\\"\\\": {\\n                  \\\"\\\"Literal\\\"\\\": {\\n                    \\\"\\\"Value\\\"\\\": \\\"\\\"{{backgroundTransparency}}D\\\"\\\"\\n                  }\\n                }\\n              },\\n              \\\"\\\"color\\\"\\\": {\\n                \\\"\\\"solid\\\"\\\": {\\n                  \\\"\\\"color\\\"\\\": {\\n                    \\\"\\\"expr\\\"\\\": {\\n                      \\\"\\\"Literal\\\"\\\": {\\n                        \\\"\\\"Value\\\"\\\": \\\"\\\"'{{backgroundColor}}'\\\"\\\"\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        ]\\n      }\\n}\\\";\\nstring totalCardContentsTemplate = @\\\"\\n    {\\n        \\\"\\\"$schema\\\"\\\": \\\"\\\"https://developer.microsoft.com/json-schemas/fabric/item/report/definition/visualContainer/1.0.0/schema.json\\\"\\\",\\n        \\\"\\\"name\\\"\\\": \\\"\\\"{{newVisualId}}\\\"\\\",\\n        \\\"\\\"position\\\"\\\": {\\n            \\\"\\\"x\\\"\\\": {{totalCardX}},\\n            \\\"\\\"y\\\"\\\": {{totalCardY}},\\n            \\\"\\\"z\\\"\\\": {{zTabOrder}},\\n            \\\"\\\"width\\\"\\\": {{totalCardWidth}},\\n            \\\"\\\"height\\\"\\\": {{totalCardHeight}},\\n            \\\"\\\"tabOrder\\\"\\\": {{zTabOrder}}\\n          },\\n      \\\"\\\"visual\\\"\\\": {\\n        \\\"\\\"visualType\\\"\\\": \\\"\\\"card\\\"\\\",\\n        \\\"\\\"query\\\"\\\": {\\n          \\\"\\\"queryState\\\"\\\": {\\n            \\\"\\\"Values\\\"\\\": {\\n              \\\"\\\"projections\\\"\\\": [\\n                {\\n                  \\\"\\\"field\\\"\\\": {\\n                    \\\"\\\"Measure\\\"\\\": {\\n                      \\\"\\\"Expression\\\"\\\": {\\n                        \\\"\\\"SourceRef\\\"\\\": {\\n                          \\\"\\\"Entity\\\"\\\": \\\"\\\"{{totalMeasureTable}}\\\"\\\"\\n                        }\\n                      },\\n                      \\\"\\\"Property\\\"\\\": \\\"\\\"{{totalMeasureName}}\\\"\\\"\\n                    }\\n                  },\\n                  \\\"\\\"queryRef\\\"\\\": \\\"\\\"{{totalMeasureTable}}.{{totalMeasureName}}\\\"\\\",\\n                  \\\"\\\"nativeQueryRef\\\"\\\": \\\"\\\"{{totalMeasureName}}\\\"\\\"\\n                }\\n              ]\\n            }\\n          },\\n          \\\"\\\"sortDefinition\\\"\\\": {\\n            \\\"\\\"sort\\\"\\\": [\\n              {\\n                \\\"\\\"field\\\"\\\": {\\n                  \\\"\\\"Measure\\\"\\\": {\\n                    \\\"\\\"Expression\\\"\\\": {\\n                      \\\"\\\"SourceRef\\\"\\\": {\\n                        \\\"\\\"Entity\\\"\\\": \\\"\\\"{{totalMeasureTable}}\\\"\\\"\\n                      }\\n                    },\\n                    \\\"\\\"Property\\\"\\\": \\\"\\\"{{totalMeasureName}}\\\"\\\"\\n                  }\\n                },\\n                \\\"\\\"direction\\\"\\\": \\\"\\\"Descending\\\"\\\"\\n              }\\n            ],\\n            \\\"\\\"isDefaultSort\\\"\\\": true\\n          }\\n        },\\n        \\\"\\\"drillFilterOtherVisuals\\\"\\\": true\\n      }\\n    }\\\";\\nstring detailCardContentsTemplate = @\\\"\\n    {\\n      \\\"\\\"$schema\\\"\\\": \\\"\\\"https://developer.microsoft.com/json-schemas/fabric/item/report/definition/visualContainer/1.0.0/schema.json\\\"\\\",\\n      \\\"\\\"name\\\"\\\": \\\"\\\"{{newVisualId}}\\\"\\\",\\n      \\\"\\\"position\\\"\\\": {\\n        \\\"\\\"x\\\"\\\": {{detailCardX}},\\n        \\\"\\\"y\\\"\\\": {{detailCardY}},\\n        \\\"\\\"z\\\"\\\": {{zTabOrder}},\\n        \\\"\\\"width\\\"\\\": {{detailCardWidth}},\\n        \\\"\\\"height\\\"\\\": {{detailCardHeight}},\\n        \\\"\\\"tabOrder\\\"\\\": {{zTabOrder}}\\n      },\\n      \\\"\\\"visual\\\"\\\": {\\n        \\\"\\\"visualType\\\"\\\": \\\"\\\"card\\\"\\\",\\n        \\\"\\\"query\\\"\\\": {\\n          \\\"\\\"queryState\\\"\\\": {\\n            \\\"\\\"Values\\\"\\\": {\\n              \\\"\\\"projections\\\"\\\": [\\n                {\\n                  \\\"\\\"field\\\"\\\": {\\n                    \\\"\\\"Measure\\\"\\\": {\\n                      \\\"\\\"Expression\\\"\\\": {\\n                        \\\"\\\"SourceRef\\\"\\\": {\\n                          \\\"\\\"Entity\\\"\\\": \\\"\\\"{{dataProblemsMeasureTable}}\\\"\\\"\\n                        }\\n                      },\\n                      \\\"\\\"Property\\\"\\\": \\\"\\\"{{dataProblemsMeasureName}}\\\"\\\"\\n                    }\\n                  },\\n                  \\\"\\\"queryRef\\\"\\\": \\\"\\\"{{dataProblemsMeasureTable}}.{{dataProblemsMeasureName}}\\\"\\\",\\n                  \\\"\\\"nativeQueryRef\\\"\\\": \\\"\\\"{{dataProblemsMeasureName}}\\\"\\\"\\n                }\\n              ]\\n            }\\n          }\\n        },\\n        \\\"\\\"objects\\\"\\\": {\\n          \\\"\\\"labels\\\"\\\": [\\n            {\\n              \\\"\\\"properties\\\"\\\": {\\n                \\\"\\\"fontSize\\\"\\\": {\\n                  \\\"\\\"expr\\\"\\\": {\\n                    \\\"\\\"Literal\\\"\\\": {\\n                      \\\"\\\"Value\\\"\\\": \\\"\\\"{{detailCardFontSize}}D\\\"\\\"\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          ]\\n        },\\n        \\\"\\\"drillFilterOtherVisuals\\\"\\\": true\\n      }\\n    }\\\";\\nstring tableContentsTemplate = @\\\"\\n    {\\n      \\\"\\\"$schema\\\"\\\": \\\"\\\"https://developer.microsoft.com/json-schemas/fabric/item/report/definition/visualContainer/1.0.0/schema.json\\\"\\\",\\n      \\\"\\\"name\\\"\\\": \\\"\\\"{{newVisualId}}\\\"\\\",\\n      \\\"\\\"position\\\"\\\": {\\n        \\\"\\\"x\\\"\\\": {{tableX}},\\n        \\\"\\\"y\\\"\\\": {{tableY}},\\n        \\\"\\\"z\\\"\\\": {{zTabOrder}},\\n        \\\"\\\"width\\\"\\\": {{tableWidth}},\\n        \\\"\\\"height\\\"\\\": {{tableHeight}},\\n        \\\"\\\"tabOrder\\\"\\\": {{zTabOrder}}\\n      },\\n      \\\"\\\"visual\\\"\\\": {\\n        \\\"\\\"visualType\\\"\\\": \\\"\\\"tableEx\\\"\\\",\\n        \\\"\\\"query\\\"\\\": {\\n          \\\"\\\"queryState\\\"\\\": {\\n            \\\"\\\"Values\\\"\\\": {\\n              \\\"\\\"projections\\\"\\\": [\\n                {\\n                  \\\"\\\"field\\\"\\\": {\\n                    \\\"\\\"Column\\\"\\\": {\\n                      \\\"\\\"Expression\\\"\\\": {\\n                        \\\"\\\"SourceRef\\\"\\\": {\\n                          \\\"\\\"Entity\\\"\\\": \\\"\\\"{{factTableName}}\\\"\\\"\\n                        }\\n                      },\\n                      \\\"\\\"Property\\\"\\\": \\\"\\\"{{factColumnName}}\\\"\\\"\\n                    }\\n                  },\\n                  \\\"\\\"queryRef\\\"\\\": \\\"\\\"{{factTableName}}.{{factColumnName}}\\\"\\\",\\n                  \\\"\\\"nativeQueryRef\\\"\\\": \\\"\\\"{{factColumnName}}\\\"\\\"\\n                },\\n                {\\n                  \\\"\\\"field\\\"\\\": {\\n                    \\\"\\\"Measure\\\"\\\": {\\n                      \\\"\\\"Expression\\\"\\\": {\\n                        \\\"\\\"SourceRef\\\"\\\": {\\n                          \\\"\\\"Entity\\\"\\\": \\\"\\\"{{dataQualityMeasureTable}}\\\"\\\"\\n                        }\\n                      },\\n                      \\\"\\\"Property\\\"\\\": \\\"\\\"{{dataQualityMeasureName}}\\\"\\\"\\n                    }\\n                  },\\n                  \\\"\\\"queryRef\\\"\\\": \\\"\\\"{{dataQualityMeasureTable}}.{{dataQualityMeasureName}}\\\"\\\",\\n                  \\\"\\\"nativeQueryRef\\\"\\\": \\\"\\\"{{dataQualityMeasureName}}\\\"\\\"\\n                }\\n              ]\\n            }\\n          }\\n        },\\n        \\\"\\\"visualContainerObjects\\\"\\\": {\\n          \\\"\\\"title\\\"\\\": [\\n            {\\n              \\\"\\\"properties\\\"\\\": {\\n                \\\"\\\"show\\\"\\\": {\\n                  \\\"\\\"expr\\\"\\\": {\\n                    \\\"\\\"Literal\\\"\\\": {\\n                      \\\"\\\"Value\\\"\\\": \\\"\\\"true\\\"\\\"\\n                    }\\n                  }\\n                },\\n                \\\"\\\"text\\\"\\\": {\\n                  \\\"\\\"expr\\\"\\\": {\\n                    \\\"\\\"Measure\\\"\\\": {\\n                      \\\"\\\"Expression\\\"\\\": {\\n                        \\\"\\\"SourceRef\\\"\\\": {\\n                          \\\"\\\"Entity\\\"\\\": \\\"\\\"{{dataQualityTitleMeasureTable}}\\\"\\\"\\n                        }\\n                      },\\n                      \\\"\\\"Property\\\"\\\": \\\"\\\"{{dataQualityTitleMeasureName}}\\\"\\\"\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          ],\\n          \\\"\\\"subTitle\\\"\\\": [\\n            {\\n              \\\"\\\"properties\\\"\\\": {\\n                \\\"\\\"show\\\"\\\": {\\n                  \\\"\\\"expr\\\"\\\": {\\n                    \\\"\\\"Literal\\\"\\\": {\\n                      \\\"\\\"Value\\\"\\\": \\\"\\\"true\\\"\\\"\\n                    }\\n                  }\\n                },\\n                \\\"\\\"text\\\"\\\": {\\n                  \\\"\\\"expr\\\"\\\": {\\n                    \\\"\\\"Measure\\\"\\\": {\\n                      \\\"\\\"Expression\\\"\\\": {\\n                        \\\"\\\"SourceRef\\\"\\\": {\\n                          \\\"\\\"Entity\\\"\\\": \\\"\\\"{{dataQualitySubtitleMeasureTable}}\\\"\\\"\\n                        }\\n                      },\\n                      \\\"\\\"Property\\\"\\\": \\\"\\\"{{dataQualitySubtitleMeasureName}}\\\"\\\"\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          ]\\n        },\\n        \\\"\\\"drillFilterOtherVisuals\\\"\\\": true\\n      }\\n    }\\\";\\nDictionary<string, string> placeholders = new Dictionary<string, string>();\\nplaceholders.Add(\\\"{{newPageId}}\\\", \\\"\\\");\\nplaceholders.Add(\\\"{{newVisualId}}\\\", \\\"\\\");\\nplaceholders.Add(\\\"{{pageName}}\\\", pageName);\\nplaceholders.Add(\\\"{{totalMeasureTable}}\\\", totalMeasure.Table.Name);\\nplaceholders.Add(\\\"{{totalMeasureName}}\\\", totalMeasure.Name);\\nplaceholders.Add(\\\"{{dataProblemsMeasureTable}}\\\", detailMeasure.Table.Name);\\nplaceholders.Add(\\\"{{dataProblemsMeasureName}}\\\", detailMeasure.Name);\\nplaceholders.Add(\\\"{{factTableName}}\\\", \\\"\\\");  //factColumn.Table.Name);\\nplaceholders.Add(\\\"{{factColumnName}}\\\", \\\"\\\");  // factColumn.Name);\\nplaceholders.Add(\\\"{{dataQualityMeasureTable}}\\\", \\\"\\\");  // dataQualityMeasure.Table.Name);\\nplaceholders.Add(\\\"{{dataQualityMeasureName}}\\\", \\\"\\\");  //dataQualityMeasure.Name);\\nplaceholders.Add(\\\"{{dataQualityTitleMeasureTable}}\\\", \\\"\\\");  // dataQualityTitleMeasure.Table.Name);\\nplaceholders.Add(\\\"{{dataQualityTitleMeasureName}}\\\", \\\"\\\");  //dataQualityTitleMeasure.Name);\\nplaceholders.Add(\\\"{{dataQualitySubtitleMeasureTable}}\\\", \\\"\\\");  //dataQualitySubtitleMeasure.Table.Name);\\nplaceholders.Add(\\\"{{dataQualitySubtitleMeasureName}}\\\", \\\"\\\");  //dataQualitySubtitleMeasure.Name);\\nplaceholders.Add(\\\"{{pageHeight}}\\\", pageHeight.ToString());\\nplaceholders.Add(\\\"{{pageWidth}}\\\", pageWidth.ToString());\\nplaceholders.Add(\\\"{{detailCardX}}\\\", detailCardX.ToString());\\nplaceholders.Add(\\\"{{detailCardY}}\\\", detailCardY.ToString());\\nplaceholders.Add(\\\"{{detailCardWidth}}\\\", detailCardWidth.ToString());\\nplaceholders.Add(\\\"{{detailCardHeight}}\\\", detailCardHeight.ToString());\\nplaceholders.Add(\\\"{{detailCardFontSize}}\\\", detailCardFontSize.ToString());\\nplaceholders.Add(\\\"{{totalCardX}}\\\", totalCardX.ToString());\\nplaceholders.Add(\\\"{{totalCardY}}\\\", totalCardY.ToString());\\nplaceholders.Add(\\\"{{totalCardWidth}}\\\", totalCardWidth.ToString());\\nplaceholders.Add(\\\"{{totalCardHeight}}\\\", totalCardHeight.ToString());\\nplaceholders.Add(\\\"{{zTabOrder}}\\\", 0.ToString());\\nplaceholders.Add(\\\"{{tableX}}\\\", 0.ToString());\\nplaceholders.Add(\\\"{{tableY}}\\\", 0.ToString());\\nplaceholders.Add(\\\"{{tableWidth}}\\\", tableWidth.ToString());\\nplaceholders.Add(\\\"{{tableHeight}}\\\", tableHeight.ToString());\\nplaceholders.Add(\\\"{{backgroundColor}}\\\", backgroundColor);\\nplaceholders.Add(\\\"{{backgroundTransparency}}\\\", backgroundTransparency.ToString());\\n\\nstring pagesFolder = Fx.GetPagesFolder(pbirFilePath);\\nstring newVisualId = \\\"\\\";\\nstring tableContents = \\\"\\\";\\nint zTabOrder = -1000; \\n\\n//create new page\\nstring newPageId = Guid.NewGuid().ToString();\\nplaceholders[\\\"{{newPageId}}\\\"] = newPageId;\\nzTabOrder = zTabOrder + 1000;\\nplaceholders[\\\"{{zTabOrder}}\\\"] = zTabOrder.ToString();\\nstring pageContents = Fx.ReplacePlaceholders(pageContentsTemplate,placeholders);\\nstring newPageFolder = Fx.AddNewPage(pageContents, pagesFolder, newPageId);\\n\\n//create total card\\nnewVisualId = Guid.NewGuid().ToString();\\nplaceholders[\\\"{{newVisualId}}\\\"] = newVisualId;\\nzTabOrder = zTabOrder + 1000;\\nplaceholders[\\\"{{zTabOrder}}\\\"] = zTabOrder.ToString();\\nstring totalCardContents = Fx.ReplacePlaceholders(totalCardContentsTemplate,placeholders);\\nFx.AddNewVisual(visualContents: totalCardContents, pageFolder: newPageFolder, newVisualId: newVisualId); \\n\\n//create detail card\\nnewVisualId = Guid.NewGuid().ToString();\\nplaceholders[\\\"{{newVisualId}}\\\"] = newVisualId;\\nzTabOrder = zTabOrder + 1000;\\nplaceholders[\\\"{{zTabOrder}}\\\"] = zTabOrder.ToString();\\nstring detailCardContents = Fx.ReplacePlaceholders(detailCardContentsTemplate, placeholders);\\nFx.AddNewVisual(visualContents: detailCardContents, pageFolder: newPageFolder, newVisualId: newVisualId);\\n\\nint currentRow = 1;\\nint currentColumn = 1;\\nint startX = totalCardX + totalCardWidth + interObjectGap; \\nint startY = interObjectGap;\\n\\nfor(int i = 0; i < dataQualityMeasures.Count(); i++)\\n{\\n    //get references and calculate values\\n    Column factColumn = factTableColumns[i];\\n    Measure dataQualityMeasure = dataQualityMeasures[i];\\n    Measure dataQualityTitleMeasure = dataQualityTitles[i];\\n    Measure dataQualitySubtitleMeasure = dataQualitySubtitles[i];\\n    zTabOrder = zTabOrder + 1000;\\n    newVisualId = Guid.NewGuid().ToString();\\n    int tableX = startX + (currentColumn - 1) * (tableWidth + interObjectGap) ;\\n    int tableY = startY + (currentRow - 1) * (tableHeight + interObjectGap) ;\\n    //update the dictionary\\n    placeholders[\\\"{{newVisualId}}\\\"] = newVisualId;\\n    placeholders[\\\"{{zTabOrder}}\\\"] = zTabOrder.ToString();\\n    placeholders[\\\"{{factTableName}}\\\"] =factColumn.Table.Name;\\n    placeholders[\\\"{{factColumnName}}\\\"] = factColumn.Name;\\n    placeholders[\\\"{{dataQualityMeasureTable}}\\\"] = dataQualityMeasure.Table.Name;\\n    placeholders[\\\"{{dataQualityMeasureName}}\\\"] =dataQualityMeasure.Name;\\n    placeholders[\\\"{{dataQualityTitleMeasureTable}}\\\"] = dataQualityTitleMeasure.Table.Name;\\n    placeholders[\\\"{{dataQualityTitleMeasureName}}\\\"] =dataQualityTitleMeasure.Name;\\n    placeholders[\\\"{{dataQualitySubtitleMeasureTable}}\\\"] =dataQualitySubtitleMeasure.Table.Name;\\n    placeholders[\\\"{{dataQualitySubtitleMeasureName}}\\\"] =dataQualitySubtitleMeasure.Name;\\n    placeholders[\\\"{{tableX}}\\\"] = tableX.ToString();\\n    placeholders[\\\"{{tableY}}\\\"] = tableY.ToString();\\n    //fill the template\\n    tableContents = Fx.ReplacePlaceholders(tableContentsTemplate, placeholders);\\n    //create the folder & Json file\\n    Fx.AddNewVisual(visualContents: tableContents, pageFolder: newPageFolder, newVisualId: newVisualId);\\n    //update variables for the next table\\n    currentColumn = currentColumn + 1;\\n    if (currentColumn > tablesPerRow)\\n    {\\n        currentRow = currentRow + 1;\\n        currentColumn = 1;\\n    }\\n    \\n}\\n\\nInfo(\\\"New page added successfully. Close your PBIP project on Power BI desktop *without saving changes* and open again to see the new page with the button.\\\");\\n//Uncomment in TE3\\nApplication.UseWaitCursor = waitCursor;\\n\\n\\npublic static class Fx\\n{\\n    public static string ReplacePlaceholders(string pageContentsTemplate, Dictionary<string, string> placeholders)\\n    {\\n        string pageContents = pageContentsTemplate; \\n        if (placeholders != null)\\n        {\\n            foreach (string placeholder in placeholders.Keys)\\n            {\\n                string valueToReplace = placeholders[placeholder];\\n                pageContents = pageContents.Replace(placeholder, valueToReplace);\\n            }\\n        }\\n        return pageContents;\\n    }\\n    public static string GetPagesFolder(string pbirFilePath)\\n    {\\n        FileInfo pbirFileInfo = new FileInfo(pbirFilePath);\\n        string pbirFolder = pbirFileInfo.Directory.FullName;\\n        string pagesFolder = Path.Combine(pbirFolder, \\\"definition\\\", \\\"pages\\\");\\n        return pagesFolder;\\n    }\\n    public static string AddNewPage(string pageContents, string pagesFolder, string newPageId)\\n    {\\n\\n        string newPageFolder = Path.Combine(pagesFolder, newPageId);\\n\\n        Directory.CreateDirectory(newPageFolder);\\n\\n        string newPageFilePath = Path.Combine(newPageFolder, \\\"page.json\\\");\\n        File.WriteAllText(newPageFilePath, pageContents);\\n\\n        string pagesFilePath = Path.Combine(pagesFolder, \\\"pages.json\\\");\\n        AddPageIdToPages(pagesFilePath, newPageId);\\n\\n        return newPageFolder;\\n    }\\n    public static void AddNewVisual(string visualContents, string pageFolder, string newVisualId)\\n    {\\n        string visualsFolder = Path.Combine(pageFolder, \\\"visuals\\\");\\n\\n        //maybe created earlier\\n        if (!Directory.Exists(visualsFolder))\\n        {\\n            Directory.CreateDirectory(visualsFolder);\\n        }\\n\\n        string newVisualFolder = Path.Combine(visualsFolder, newVisualId); \\n\\n        Directory.CreateDirectory(newVisualFolder);\\n\\n        string newVisualFilePath = Path.Combine(newVisualFolder, \\\"visual.json\\\");\\n        File.WriteAllText(newVisualFilePath, visualContents);\\n\\n    }\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        if (!model.Tables.Any(t => t.Name == tableName))\\n        {\\n            return model.AddCalculatedTable(tableName, tableExpression);\\n        }\\n        else\\n        {\\n            return model.Tables.Where(t => t.Name == tableName).First();\\n        }\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {\\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList)\\n    {\\n        Func<IList<string>, string, string> SelectString = (IList<string> options, string title) =>\\n        {\\n            var form = new Form();\\n            form.Text = title;\\n            var buttonPanel = new Panel();\\n            buttonPanel.Dock = DockStyle.Bottom;\\n            buttonPanel.Height = 30;\\n            var okButton = new Button() { DialogResult = DialogResult.OK, Text = \\\"OK\\\" };\\n            var cancelButton = new Button() { DialogResult = DialogResult.Cancel, Text = \\\"Cancel\\\", Left = 80 };\\n            var listbox = new ListBox();\\n            listbox.Dock = DockStyle.Fill;\\n            listbox.Items.AddRange(options.ToArray());\\n            listbox.SelectedItem = options[0];\\n            form.Controls.Add(listbox);\\n            form.Controls.Add(buttonPanel);\\n            buttonPanel.Controls.Add(okButton);\\n            buttonPanel.Controls.Add(cancelButton);\\n            var result = form.ShowDialog();\\n            if (result == DialogResult.Cancel) return null;\\n            return listbox.SelectedItem.ToString();\\n        };\\n        //let the user select the name of the macro to copy\\n        String select = SelectString(OptionList, \\\"Choose a macro\\\");\\n        //check that indeed one macro was selected\\n        if (select == null)\\n        {\\n            Info(\\\"You cancelled!\\\");\\n        }\\n        return select;\\n    }\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        IEnumerable<Table> dateTables = null as IEnumerable<Table>;\\n        if (model.Tables.Any(t => t.DataCategory == \\\"Time\\\" && t.Columns.Any(c => c.IsKey == true)))\\n        {\\n            dateTables = model.Tables.Where(t => t.DataCategory == \\\"Time\\\" && t.Columns.Any(c => c.IsKey == true && c.DataType == DataType.DateTime));\\n        }\\n        else\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        if (matchTables == null)\\n        {\\n            return null;\\n        }\\n        else\\n        {\\n            return matchTables.First();\\n        }\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table, bool> lambda)\\n    {\\n        if (tables.Any(t => lambda(t)))\\n        {\\n            return tables.Where(t => lambda(t));\\n        }\\n        else\\n        {\\n            return null as IEnumerable<Table>;\\n        }\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column, bool> lambda, bool returnAllIfNoneFound = true)\\n    {\\n        if (columns.Any(c => lambda(c)))\\n        {\\n            return columns.Where(c => lambda(c));\\n        }\\n        else\\n        {\\n            if (returnAllIfNoneFound)\\n            {\\n                return columns;\\n            }\\n            else\\n            {\\n                return null as IEnumerable<Column>;\\n            }\\n        }\\n    }\\n    public static Table SelectTableExt(Model model, string possibleName = null, string annotationName = null, string annotationValue = null, \\n        Func<Table,bool>  lambdaExpression = null, string label = \\\"Select Table\\\", bool skipDialogIfSingleMatch = true, bool showOnlyMatchingTables = true)\\n    {\\n        if (lambdaExpression == null)\\n        {\\n            if (possibleName != null) { \\n                lambdaExpression = (t) => t.Name == possibleName;\\n            } else if(annotationName!= null && annotationValue != null)\\n            {\\n                lambdaExpression = (t) => t.GetAnnotation(annotationName) == annotationValue;\\n            }\\n        }\\n        IEnumerable<Table> tables = model.Tables.Where(lambdaExpression);\\n        //none found, let the user choose from all tables\\n        if (tables.Count() == 0)\\n        {\\n            return SelectTable(tables: model.Tables, label: label);\\n        }\\n        else if (tables.Count() == 1 && !skipDialogIfSingleMatch)\\n        {\\n            return SelectTable(tables: model.Tables, preselect: tables.First(), label: label);\\n        }\\n        else if (tables.Count() == 1 && skipDialogIfSingleMatch)\\n        {\\n            return tables.First();\\n        } \\n        else if (tables.Count() > 1 && showOnlyMatchingTables)\\n        {\\n            return SelectTable(tables: tables, preselect: tables.First(), label: label);\\n        }\\n        else if (tables.Count() > 1 && !showOnlyMatchingTables)\\n        {\\n            return SelectTable(tables: model.Tables, preselect: tables.First(), label: label);\\n        } else\\n        {\\n            Error(@\\\"Unexpected logic in \\\"\\\"SelectTableExt\\\"\\\"\\\");\\n            return null;\\n        }\\n    }\\n    //add other methods always as \\\"public static\\\" followed by the data type they will return or void if they do not return anything.\\n\\n    private static void AddPageIdToPages(string pagesFilePath, string pageId)\\n    {\\n        string pagesFileContents = File.ReadAllText(pagesFilePath);\\n        PagesDto pagesDto = JsonConvert.DeserializeObject<PagesDto>(pagesFileContents);\\n        if(pagesDto.pageOrder == null)\\n        {\\n            pagesDto.pageOrder = new List<string>();\\n        }\\n        \\n        if (!pagesDto.pageOrder.Contains(pageId)) { \\n\\n            pagesDto.pageOrder.Add(pageId);\\n            string resultFile = JsonConvert.SerializeObject(pagesDto, Formatting.Indented);\\n            File.WriteAllText(pagesFilePath, resultFile);\\n        }\\n    }\\n}\\n\\npublic class PagesDto\\n{\\n    [JsonProperty(\\\"$schema\\\")]\\n    public string schema { get; set; }\\n    public List<string> pageOrder { get; set; }\\n    public string activePageName { get; set; }\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\Report Layer Macros\\Open Visual Json file",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\n\\n\\nusing Microsoft.VisualBasic;\\nusing System.IO;\\nusing Newtonsoft.Json.Linq;\\n//2025-05-25/B.Agullo\\n//this script allows the user to open the JSON file of one or more visuals in the report.\\n//see https://www.esbrina-ba.com/pbir-scripts-to-replace-field-and-open-visual-json-files/ for reference on how to use it\\n// Step 1: Initialize the report object\\nReportExtended report = Rx.InitReport();\\nif (report == null) return;\\n// Step 2: Gather all visuals with page info\\nvar allVisuals = report.Pages\\n    .SelectMany(p => p.Visuals.Select(v => new { Page = p.Page, Visual = v }))\\n    .ToList();\\nif (allVisuals.Count == 0)\\n{\\n    Info(\\\"No visuals found in the report.\\\");\\n    return;\\n}\\n// Step 3: Prepare display names for selection\\nvar visualDisplayList = allVisuals.Select(x =>\\n    String.Format(\\n        @\\\"{0} - {1} ({2}, {3})\\\", \\n        x.Page.DisplayName, \\n        x.Visual?.Content?.Visual?.VisualType \\n            ?? x.Visual?.Content?.VisualGroup?.DisplayName, \\n        (int)x.Visual.Content.Position.X, \\n        (int)x.Visual.Content.Position.Y)\\n).ToList();\\n// Step 4: Let the user select one or more visuals\\nList<string> selected = Fx.ChooseStringMultiple(OptionList: visualDisplayList, label: \\\"Select visuals to open JSON files\\\");\\nif (selected == null || selected.Count == 0)\\n{\\n    Info(\\\"No visuals selected.\\\");\\n    return;\\n}\\n// Step 5: For each selected visual, open its JSON file\\nforeach (var visualEntry in allVisuals)\\n{\\n    string display = String.Format\\n        (@\\\"{0} - {1} ({2}, {3})\\\", \\n        visualEntry.Page.DisplayName, \\n        visualEntry?.Visual?.Content?.Visual?.VisualType \\n            ?? visualEntry.Visual?.Content?.VisualGroup?.DisplayName, \\n        (int)visualEntry.Visual.Content.Position.X, \\n        (int)visualEntry.Visual.Content.Position.Y);\\n    if (selected.Contains(display))\\n    {\\n        string jsonPath = visualEntry.Visual.VisualFilePath;\\n        if (!File.Exists(jsonPath))\\n        {\\n            Error(String.Format(@\\\"JSON file not found: {0}\\\", jsonPath));\\n            continue;\\n        }\\n        System.Diagnostics.Process.Start(jsonPath);\\n    }\\n}\\n\\npublic static class Fx\\n{\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        return model.Tables.FirstOrDefault(t =>\\n                            string.Equals(t.Name, tableName, StringComparison.OrdinalIgnoreCase)) //case insensitive search\\n                            ?? model.AddCalculatedTable(tableName, tableExpression);\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {\\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList, string label = \\\"Choose item\\\")\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect: false, label:label) as string;\\n    }\\n    public static List<string> ChooseStringMultiple(IList<string> OptionList, string label = \\\"Choose item(s)\\\")\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect:true, label:label) as List<string>;\\n    }\\n    private static object ChooseStringInternal(IList<string> OptionList, bool MultiSelect, string label = \\\"Choose item(s)\\\")\\n    {\\n        Form form = new Form\\n        {\\n            Text =label,\\n            Width = 400,\\n            Height = 500,\\n            StartPosition = FormStartPosition.CenterScreen,\\n            Padding = new Padding(20)\\n        };\\n        ListBox listbox = new ListBox\\n        {\\n            Dock = DockStyle.Fill,\\n            SelectionMode = MultiSelect ? SelectionMode.MultiExtended : SelectionMode.One\\n        };\\n        listbox.Items.AddRange(OptionList.ToArray());\\n        if (!MultiSelect && OptionList.Count > 0)\\n            listbox.SelectedItem = OptionList[0];\\n        FlowLayoutPanel buttonPanel = new FlowLayoutPanel\\n        {\\n            Dock = DockStyle.Bottom,\\n            Height = 40,\\n            FlowDirection = FlowDirection.LeftToRight,\\n            Padding = new Padding(10)\\n        };\\n        Button selectAllButton = new Button { Text = \\\"Select All\\\", Visible = MultiSelect };\\n        Button selectNoneButton = new Button { Text = \\\"Select None\\\", Visible = MultiSelect };\\n        Button okButton = new Button { Text = \\\"OK\\\", DialogResult = DialogResult.OK };\\n        Button cancelButton = new Button { Text = \\\"Cancel\\\", DialogResult = DialogResult.Cancel };\\n        selectAllButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, true);\\n        };\\n        selectNoneButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, false);\\n        };\\n        buttonPanel.Controls.Add(selectAllButton);\\n        buttonPanel.Controls.Add(selectNoneButton);\\n        buttonPanel.Controls.Add(okButton);\\n        buttonPanel.Controls.Add(cancelButton);\\n        form.Controls.Add(listbox);\\n        form.Controls.Add(buttonPanel);\\n        DialogResult result = form.ShowDialog();\\n        if (result == DialogResult.Cancel)\\n        {\\n            Info(\\\"You Cancelled!\\\");\\n            return null;\\n        }\\n        if (MultiSelect)\\n        {\\n            List<string> selectedItems = new List<string>();\\n            foreach (object item in listbox.SelectedItems)\\n                selectedItems.Add(item.ToString());\\n            return selectedItems;\\n        }\\n        else\\n        {\\n            return listbox.SelectedItem != null ? listbox.SelectedItem.ToString() : null;\\n        }\\n    }\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        var dateTables = model.Tables\\n            .Where(t => t.DataCategory == \\\"Time\\\" &&\\n                   t.Columns.Any(c => c.IsKey && c.DataType == DataType.DateTime))\\n            .ToList();\\n        if (!dateTables.Any())\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n            return null;\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        return GetFilteredTables(tables, lambda).FirstOrDefault();\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table, bool> lambda)\\n    {\\n        var filteredTables = tables.Where(t => lambda(t));\\n        return filteredTables.Any() ? filteredTables : null;\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column, bool> lambda, bool returnAllIfNoneFound = true)\\n    {\\n        var filteredColumns = columns.Where(c => lambda(c));\\n        return filteredColumns.Any() || returnAllIfNoneFound ? filteredColumns : null;\\n    }\\n}\\n\\npublic static class Rx\\n\\n{\\n\\n\\n\\n\\n\\n    \\n\\n    \\n\\n    public static VisualExtended DuplicateVisual(VisualExtended visualExtended)\\n\\n    {\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes)\\n\\n        string newVisualName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        string sourceFolder = Path.GetDirectoryName(visualExtended.VisualFilePath);\\n\\n        string targetFolder = Path.Combine(Path.GetDirectoryName(sourceFolder), newVisualName);\\n\\n        if (Directory.Exists(targetFolder))\\n\\n        {\\n\\n            Error(string.Format(\\\"Folder already exists: {0}\\\", targetFolder));\\n\\n            return null;\\n\\n        }\\n\\n        Directory.CreateDirectory(targetFolder);\\n\\n\\n\\n        // Deep clone the VisualDto.Root object\\n\\n        string originalJson = JsonConvert.SerializeObject(visualExtended.Content, Newtonsoft.Json.Formatting.Indented);\\n\\n        VisualDto.Root clonedContent = \\n\\n            JsonConvert.DeserializeObject<VisualDto.Root>(\\n\\n                originalJson, \\n\\n                new JsonSerializerSettings {\\n\\n                    DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                    NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n                });\\n\\n\\n\\n        // Update the name property if it exists\\n\\n        if (clonedContent != null && clonedContent.Name != null)\\n\\n        {\\n\\n            clonedContent.Name = newVisualName;\\n\\n        }\\n\\n\\n\\n        // Set the new file path\\n\\n        string newVisualFilePath = Path.Combine(targetFolder, \\\"visual.json\\\");\\n\\n\\n\\n        // Create the new VisualExtended object\\n\\n        VisualExtended newVisual = new VisualExtended\\n\\n        {\\n\\n            Content = clonedContent,\\n\\n            VisualFilePath = newVisualFilePath\\n\\n        };\\n\\n\\n\\n        return newVisual;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended GroupVisuals(List<VisualExtended> visualsToGroup, string groupName = null, string groupDisplayName = null)\\n\\n    {\\n\\n        if (visualsToGroup == null || visualsToGroup.Count == 0)\\n\\n        {\\n\\n            Error(\\\"No visuals to group.\\\");\\n\\n            return null;\\n\\n        }\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes) if no group name is provided\\n\\n        if (string.IsNullOrEmpty(groupName))\\n\\n        {\\n\\n            groupName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        }\\n\\n        if (string.IsNullOrEmpty(groupDisplayName))\\n\\n        {\\n\\n            groupDisplayName = groupName;\\n\\n        }\\n\\n\\n\\n        // Find minimum X and Y\\n\\n        double minX = visualsToGroup.Min(v => v.Content.Position != null ? (double)v.Content.Position.X : 0);\\n\\n        double minY = visualsToGroup.Min(v => v.Content.Position != null ? (double)v.Content.Position.Y : 0);\\n\\n\\n\\n       //Info(\\\"minX:\\\" + minX.ToString() + \\\", minY: \\\" + minY.ToString());\\n\\n\\n\\n        // Calculate width and height\\n\\n        double groupWidth = 0;\\n\\n        double groupHeight = 0;\\n\\n        foreach (var v in visualsToGroup)\\n\\n        {\\n\\n            if (v.Content != null && v.Content.Position != null)\\n\\n            {\\n\\n                double visualWidth = v.Content.Position != null ? (double)v.Content.Position.Width : 0;\\n\\n                double visualHeight = v.Content.Position != null ? (double)v.Content.Position.Height : 0;\\n\\n                double xOffset = (double)v.Content.Position.X - (double)minX;\\n\\n                double yOffset = (double)v.Content.Position.Y - (double)minY;\\n\\n                double totalWidth = xOffset + visualWidth;\\n\\n                double totalHeight = yOffset + visualHeight;\\n\\n                if (totalWidth > groupWidth) groupWidth = totalWidth;\\n\\n                if (totalHeight > groupHeight) groupHeight = totalHeight;\\n\\n            }\\n\\n        }\\n\\n\\n\\n        // Create the group visual content\\n\\n        var groupContent = new VisualDto.Root\\n\\n        {\\n\\n            Schema = visualsToGroup.FirstOrDefault().Content.Schema,\\n\\n            Name = groupName,\\n\\n            Position = new VisualDto.Position\\n\\n            {\\n\\n                X = minX,\\n\\n                Y = minY,\\n\\n                Width = groupWidth,\\n\\n                Height = groupHeight\\n\\n            },\\n\\n            VisualGroup = new VisualDto.VisualGroup\\n\\n            {\\n\\n                DisplayName = groupDisplayName,\\n\\n                GroupMode = \\\"ScaleMode\\\"\\n\\n            }\\n\\n        };\\n\\n\\n\\n        // Set VisualFilePath for the group visual\\n\\n        // Use the VisualFilePath of the first visual as a template\\n\\n        string groupVisualFilePath = null;\\n\\n        var firstVisual = visualsToGroup.FirstOrDefault(v => !string.IsNullOrEmpty(v.VisualFilePath));\\n\\n        if (firstVisual != null && !string.IsNullOrEmpty(firstVisual.VisualFilePath))\\n\\n        {\\n\\n            string originalPath = firstVisual.VisualFilePath;\\n\\n            string parentDir = Path.GetDirectoryName(Path.GetDirectoryName(originalPath)); // up to 'visuals'\\n\\n            if (!string.IsNullOrEmpty(parentDir))\\n\\n            {\\n\\n                string groupFolder = Path.Combine(parentDir, groupName);\\n\\n                groupVisualFilePath = Path.Combine(groupFolder, \\\"visual.json\\\");\\n\\n            }\\n\\n        }\\n\\n\\n\\n        // Create the new VisualExtended for the group\\n\\n        var groupVisual = new VisualExtended\\n\\n        {\\n\\n            Content = groupContent,\\n\\n            VisualFilePath = groupVisualFilePath // Set as described\\n\\n        };\\n\\n\\n\\n        // Update grouped visuals: set parentGroupName and adjust X/Y\\n\\n        foreach (var v in visualsToGroup)\\n\\n        {\\n\\n            \\n\\n            if (v.Content == null) continue;\\n\\n            v.Content.ParentGroupName = groupName;\\n\\n\\n\\n            if (v.Content.Position != null)\\n\\n            {\\n\\n                v.Content.Position.X = v.Content.Position.X - minX + 0;\\n\\n                v.Content.Position.Y = v.Content.Position.Y - minY + 0;\\n\\n            }\\n\\n        }\\n\\n\\n\\n        return groupVisual;\\n\\n    }\\n\\n\\n\\n    \\n\\n\\n\\n    private static readonly string RecentPathsFile = Path.Combine(\\n\\n    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\\n\\n    \\\"YourAppName\\\", \\\"recentPbirPaths.json\\\");\\n\\n\\n\\n    public static string GetPbirFilePathWithHistory(string label = \\\"Select definition.pbir file\\\")\\n\\n    {\\n\\n        // Load recent paths\\n\\n        List<string> recentPaths = LoadRecentPbirPaths();\\n\\n\\n\\n        // Filter out non-existing files\\n\\n        recentPaths = recentPaths.Where(File.Exists).ToList();\\n\\n\\n\\n        // Present options to the user\\n\\n        var options = new List<string>(recentPaths);\\n\\n        options.Add(\\\"Browse for new file...\\\");\\n\\n\\n\\n        string selected = Fx.ChooseString(options,label:label);\\n\\n\\n\\n        string chosenPath = null;\\n\\n        if (selected == \\\"Browse for new file...\\\" || string.IsNullOrEmpty(selected))\\n\\n        {\\n\\n            chosenPath = GetPbirFilePath(label);\\n\\n        }\\n\\n        else\\n\\n        {\\n\\n            chosenPath = selected;\\n\\n        }\\n\\n\\n\\n        if (!string.IsNullOrEmpty(chosenPath))\\n\\n        {\\n\\n            // Update recent paths\\n\\n            UpdateRecentPbirPaths(chosenPath, recentPaths);\\n\\n        }\\n\\n\\n\\n        return chosenPath;\\n\\n    }\\n\\n\\n\\n    private static List<string> LoadRecentPbirPaths()\\n\\n    {\\n\\n        try\\n\\n        {\\n\\n            if (File.Exists(RecentPathsFile))\\n\\n            {\\n\\n                string json = File.ReadAllText(RecentPathsFile);\\n\\n                return JsonConvert.DeserializeObject<List<string>>(json) ?? new List<string>();\\n\\n            }\\n\\n        }\\n\\n        catch { }\\n\\n        return new List<string>();\\n\\n    }\\n\\n\\n\\n    private static void UpdateRecentPbirPaths(string newPath, List<string> recentPaths)\\n\\n    {\\n\\n        // Remove if already exists, insert at top\\n\\n        recentPaths.RemoveAll(p => string.Equals(p, newPath, StringComparison.OrdinalIgnoreCase));\\n\\n        recentPaths.Insert(0, newPath);\\n\\n\\n\\n        // Keep only the latest 10\\n\\n        while (recentPaths.Count > 10)\\n\\n            recentPaths.RemoveAt(recentPaths.Count - 1);\\n\\n\\n\\n        // Ensure directory exists\\n\\n        Directory.CreateDirectory(Path.GetDirectoryName(RecentPathsFile));\\n\\n        File.WriteAllText(RecentPathsFile, JsonConvert.SerializeObject(recentPaths, Newtonsoft.Json.Formatting.Indented));\\n\\n    }\\n\\n\\n\\n\\n\\n    public static ReportExtended InitReport(string label = \\\"Please select definition.pbir file of the target report\\\")\\n\\n    {\\n\\n        // Get the base path from the user  \\n\\n        string basePath = Rx.GetPbirFilePathWithHistory(label:label);\\n\\n        if (basePath == null)\\n\\n        {\\n\\n            Error(\\\"Operation canceled by the user.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Define the target path  \\n\\n        string baseDirectory = Path.GetDirectoryName(basePath);\\n\\n        string targetPath = Path.Combine(baseDirectory, \\\"definition\\\", \\\"pages\\\");\\n\\n\\n\\n        // Check if the target path exists  \\n\\n        if (!Directory.Exists(targetPath))\\n\\n        {\\n\\n            Error(String.Format(\\\"The path '{0}' does not exist.\\\", targetPath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Get all subfolders in the target path  \\n\\n        List<string> subfolders = Directory.GetDirectories(targetPath).ToList();\\n\\n\\n\\n        string pagesFilePath = Path.Combine(targetPath, \\\"pages.json\\\");\\n\\n        string pagesJsonContent = File.ReadAllText(pagesFilePath);\\n\\n        \\n\\n        if (string.IsNullOrEmpty(pagesJsonContent))\\n\\n        {\\n\\n            Error(String.Format(\\\"The file '{0}' is empty or does not exist.\\\", pagesFilePath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        PagesDto pagesDto = JsonConvert.DeserializeObject<PagesDto>(pagesJsonContent);\\n\\n\\n\\n        ReportExtended report = new ReportExtended();\\n\\n        report.PagesFilePath = pagesFilePath;\\n\\n        report.PagesConfig = pagesDto;\\n\\n\\n\\n        // Process each folder  \\n\\n        foreach (string folder in subfolders)\\n\\n        {\\n\\n            string pageJsonPath = Path.Combine(folder, \\\"page.json\\\");\\n\\n            if (File.Exists(pageJsonPath))\\n\\n            {\\n\\n                try\\n\\n                {\\n\\n                    string jsonContent = File.ReadAllText(pageJsonPath);\\n\\n                    PageDto page = JsonConvert.DeserializeObject<PageDto>(jsonContent);\\n\\n\\n\\n                    PageExtended pageExtended = new PageExtended();\\n\\n                    pageExtended.Page = page;\\n\\n                    pageExtended.PageFilePath = pageJsonPath;\\n\\n\\n\\n                    pageExtended.ParentReport = report;\\n\\n\\n\\n                    string visualsPath = Path.Combine(folder, \\\"visuals\\\");\\n\\n\\n\\n                    if (!Directory.Exists(visualsPath))\\n\\n                    {\\n\\n                        report.Pages.Add(pageExtended); // still add the page\\n\\n                        continue; // skip visual loading\\n\\n                    }\\n\\n\\n\\n                    List<string> visualSubfolders = Directory.GetDirectories(visualsPath).ToList();\\n\\n\\n\\n                    foreach (string visualFolder in visualSubfolders)\\n\\n                    {\\n\\n                        string visualJsonPath = Path.Combine(visualFolder, \\\"visual.json\\\");\\n\\n                        if (File.Exists(visualJsonPath))\\n\\n                        {\\n\\n                            try\\n\\n                            {\\n\\n                                string visualJsonContent = File.ReadAllText(visualJsonPath);\\n\\n                                VisualDto.Root visual = JsonConvert.DeserializeObject<VisualDto.Root>(visualJsonContent);\\n\\n\\n\\n                                VisualExtended visualExtended = new VisualExtended();\\n\\n                                visualExtended.Content = visual;\\n\\n                                visualExtended.VisualFilePath = visualJsonPath;\\n\\n                                visualExtended.ParentPage = pageExtended; // Set parent page reference\\n\\n                                pageExtended.Visuals.Add(visualExtended);\\n\\n                            }\\n\\n                            catch (Exception ex2)\\n\\n                            {\\n\\n                                Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", visualJsonPath, ex2.Message));\\n\\n                                return null;\\n\\n                            }\\n\\n\\n\\n                        }\\n\\n                    }\\n\\n\\n\\n                    report.Pages.Add(pageExtended);\\n\\n\\n\\n                }\\n\\n                catch (Exception ex)\\n\\n                {\\n\\n                    Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", pageJsonPath, ex.Message));\\n\\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        return report;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended SelectVisual(ReportExtended report)\\n\\n    {\\n\\n        return SelectVisualInternal(report, Multiselect: false) as VisualExtended;\\n\\n    }\\n\\n\\n\\n    public static List<VisualExtended> SelectVisuals(ReportExtended report)\\n\\n    {\\n\\n        return SelectVisualInternal(report, Multiselect: true) as List<VisualExtended>;\\n\\n    }\\n\\n\\n\\n    private static object SelectVisualInternal(ReportExtended report, bool Multiselect)\\n\\n    {\\n\\n        // Step 1: Build selection list\\n\\n        var visualSelectionList = report.Pages\\n\\n            .SelectMany(p => p.Visuals.Select(v => new\\n\\n            {\\n\\n                Display = string.Format(\\\"{0} - {1} ({2}, {3})\\\", p.Page.DisplayName, v.Content.Visual.VisualType, (int)v.Content.Position.X, (int)v.Content.Position.Y),\\n\\n                Page = p,\\n\\n                Visual = v\\n\\n            }))\\n\\n            .ToList();\\n\\n\\n\\n        if(visualSelectionList.Count == 0)\\n\\n        {\\n\\n            Error(\\\"No visuals found in the report.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Step 2: Let user choose a visual\\n\\n        var options = visualSelectionList.Select(v => v.Display).ToList();\\n\\n\\n\\n\\n\\n        if (Multiselect)\\n\\n        {\\n\\n            // For multiselect, use ChooseStringMultiple\\n\\n            var multiSelelected = Fx.ChooseStringMultiple(options);\\n\\n            if (multiSelelected == null || multiSelelected.Count == 0)\\n\\n            {\\n\\n                Info(\\\"You cancelled.\\\");\\n\\n                return null;\\n\\n            }\\n\\n            // Find all selected visuals\\n\\n            var selectedVisuals = visualSelectionList.Where(v => multiSelelected.Contains(v.Display)).Select(v => v.Visual).ToList();\\n\\n\\n\\n            return selectedVisuals;\\n\\n        }\\n\\n        else\\n\\n        {\\n\\n            string selected = Fx.ChooseString(options);\\n\\n\\n\\n            if (string.IsNullOrEmpty(selected))\\n\\n            {\\n\\n                Info(\\\"You cancelled.\\\");\\n\\n                return null;\\n\\n            }\\n\\n\\n\\n            // Step 3: Find the selected visual\\n\\n            var selectedVisual = visualSelectionList.FirstOrDefault(v => v.Display == selected);\\n\\n\\n\\n            if (selectedVisual == null)\\n\\n            {\\n\\n                Error(\\\"Selected visual not found.\\\");\\n\\n                return null;\\n\\n            }\\n\\n\\n\\n            return selectedVisual.Visual;\\n\\n        }\\n\\n    }\\n\\n\\n\\n    public static PageExtended ReplicateFirstPageAsBlank(ReportExtended report, bool showMessages = false)\\n\\n    {\\n\\n        if (report.Pages == null || !report.Pages.Any())\\n\\n        {\\n\\n            Error(\\\"No pages found in the report.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        PageExtended firstPage = report.Pages[0];\\n\\n\\n\\n        // Generate a clean 16-character name from a GUID (no dashes or slashes)\\n\\n        string newPageName = Guid.NewGuid().ToString(\\\"N\\\").Substring(0, 16);\\n\\n        string newPageDisplayName = firstPage.Page.DisplayName + \\\" - Copy\\\";\\n\\n\\n\\n        string sourceFolder = Path.GetDirectoryName(firstPage.PageFilePath);\\n\\n        string targetFolder = Path.Combine(Path.GetDirectoryName(sourceFolder), newPageName);\\n\\n        string visualsFolder = Path.Combine(targetFolder, \\\"visuals\\\");\\n\\n\\n\\n        if (Directory.Exists(targetFolder))\\n\\n        {\\n\\n            Error($\\\"Folder already exists: {targetFolder}\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        Directory.CreateDirectory(targetFolder);\\n\\n        Directory.CreateDirectory(visualsFolder);\\n\\n\\n\\n        var newPageDto = new PageDto\\n\\n        {\\n\\n            Name = newPageName,\\n\\n            DisplayName = newPageDisplayName,\\n\\n            DisplayOption = firstPage.Page.DisplayOption,\\n\\n            Height = firstPage.Page.Height,\\n\\n            Width = firstPage.Page.Width,\\n\\n            Schema = firstPage.Page.Schema\\n\\n        };\\n\\n\\n\\n        var newPage = new PageExtended\\n\\n        {\\n\\n            Page = newPageDto,\\n\\n            PageFilePath = Path.Combine(targetFolder, \\\"page.json\\\"),\\n\\n            Visuals = new List<VisualExtended>() // empty visuals\\n\\n        };\\n\\n\\n\\n        File.WriteAllText(newPage.PageFilePath, JsonConvert.SerializeObject(newPageDto, Newtonsoft.Json.Formatting.Indented));\\n\\n\\n\\n        report.Pages.Add(newPage);\\n\\n\\n\\n        if(showMessages) Info($\\\"Created new blank page: {newPageName}\\\");\\n\\n\\n\\n        return newPage; \\n\\n    }\\n\\n\\n\\n\\n\\n    public static void SaveVisual(VisualExtended visual)\\n\\n    {\\n\\n\\n\\n        // Save new JSON, ignoring nulls\\n\\n        string newJson = JsonConvert.SerializeObject(\\n\\n            visual.Content,\\n\\n            Newtonsoft.Json.Formatting.Indented,\\n\\n            new JsonSerializerSettings\\n\\n            {\\n\\n                //DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n            }\\n\\n        );\\n\\n        // Ensure the directory exists before saving\\n\\n        string visualFolder = Path.GetDirectoryName(visual.VisualFilePath);\\n\\n        if (!Directory.Exists(visualFolder))\\n\\n        {\\n\\n            Directory.CreateDirectory(visualFolder);\\n\\n        }\\n\\n        File.WriteAllText(visual.VisualFilePath, newJson);\\n\\n    }\\n\\n\\n\\n\\n\\n    public static string ReplacePlaceholders(string pageContents, Dictionary<string, string> placeholders)\\n\\n    {\\n\\n        if (placeholders != null)\\n\\n        {\\n\\n            foreach (string placeholder in placeholders.Keys)\\n\\n            {\\n\\n                string valueToReplace = placeholders[placeholder];\\n\\n\\n\\n                pageContents = pageContents.Replace(placeholder, valueToReplace);\\n\\n\\n\\n            }\\n\\n        }\\n\\n\\n\\n\\n\\n        return pageContents;\\n\\n    }\\n\\n\\n\\n\\n\\n    public static String GetPbirFilePath(string label = \\\"Please select definition.pbir file of the target report\\\")\\n\\n    {\\n\\n\\n\\n        // Create an instance of the OpenFileDialog\\n\\n        OpenFileDialog openFileDialog = new OpenFileDialog\\n\\n        {\\n\\n            Title = label,\\n\\n            // Set filter options and filter index.\\n\\n            Filter = \\\"PBIR Files (*.pbir)|*.pbir\\\",\\n\\n            FilterIndex = 1\\n\\n        };\\n\\n        // Call the ShowDialog method to show the dialog box.\\n\\n        DialogResult result = openFileDialog.ShowDialog();\\n\\n        // Process input if the user clicked OK.\\n\\n        if (result != DialogResult.OK)\\n\\n        {\\n\\n            Error(\\\"You cancelled\\\");\\n\\n            return null;\\n\\n        }\\n\\n        return openFileDialog.FileName;\\n\\n\\n\\n    }\\n\\n\\n\\n\\n\\n}\\n\\n\\n\\n   \\n\\n    public class PagesDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"pageOrder\\\")]\\n        public List<string> PageOrder { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"activePageName\\\")]\\n        public string ActivePageName { get; set; }\\n        \\n    }\\n\\n\\n    public class PageDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"name\\\")]\\n        public string Name { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayName\\\")]\\n        public string DisplayName { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayOption\\\")]\\n        public string DisplayOption { get; set; } // Could create enum if you want stricter typing\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"height\\\")]\\n        public double? Height { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"width\\\")]\\n        public double? Width { get; set; }\\n    }\\n\\n\\n\\n    public partial class VisualDto\\n    {\\n        public class Root\\n        {\\n            [JsonProperty(\\\"$schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"name\\\")] public string Name { get; set; }\\n            [JsonProperty(\\\"position\\\")] public Position Position { get; set; }\\n            [JsonProperty(\\\"visual\\\")] public Visual Visual { get; set; }\\n            \\n\\n            [JsonProperty(\\\"visualGroup\\\")] public VisualGroup VisualGroup { get; set; }\\n            [JsonProperty(\\\"parentGroupName\\\")] public string ParentGroupName { get; set; }\\n            [JsonProperty(\\\"filterConfig\\\")] public object FilterConfig { get; set; }\\n            [JsonProperty(\\\"isHidden\\\")] public bool IsHidden { get; set; }\\n\\n            [JsonExtensionData]\\n            \\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        public class VisualContainerObjects\\n        {\\n            [JsonProperty(\\\"general\\\")]\\n            public List<VisualContainerObject> General { get; set; }\\n\\n            // Add other known properties as needed, e.g.:\\n            [JsonProperty(\\\"title\\\")]\\n            public List<VisualContainerObject> Title { get; set; }\\n\\n            [JsonProperty(\\\"subTitle\\\")]\\n            public List<VisualContainerObject> SubTitle { get; set; }\\n\\n            // This will capture any additional properties not explicitly defined above\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualContainerObject\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            public Dictionary<string, VisualContainerProperty> Properties { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualContainerProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualExpr Expr { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualExpr\\n        {\\n            [JsonProperty(\\\"Literal\\\")]\\n            public VisualLiteral Literal { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualLiteral\\n        {\\n            [JsonProperty(\\\"Value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualGroup\\n        {\\n            [JsonProperty(\\\"displayName\\\")] public string DisplayName { get; set; }\\n            [JsonProperty(\\\"groupMode\\\")] public string GroupMode { get; set; }\\n        }\\n\\n        public class Position\\n        {\\n            [JsonProperty(\\\"x\\\")] public double X { get; set; }\\n            [JsonProperty(\\\"y\\\")] public double Y { get; set; }\\n            [JsonProperty(\\\"z\\\")] public int Z { get; set; }\\n            [JsonProperty(\\\"height\\\")] public double Height { get; set; }\\n            [JsonProperty(\\\"width\\\")] public double Width { get; set; }\\n            [JsonProperty(\\\"tabOrder\\\")] public int TabOrder { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Visual\\n        {\\n            [JsonProperty(\\\"visualType\\\")] public string VisualType { get; set; }\\n            [JsonProperty(\\\"query\\\")] public Query Query { get; set; }\\n            [JsonProperty(\\\"objects\\\")] public Objects Objects { get; set; }\\n            [JsonProperty(\\\"visualContainerObjects\\\")]\\n            public VisualContainerObjects VisualContainerObjects { get; set; }\\n            [JsonProperty(\\\"drillFilterOtherVisuals\\\")] public bool DrillFilterOtherVisuals { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Query\\n        {\\n            [JsonProperty(\\\"queryState\\\")] public QueryState QueryState { get; set; }\\n            [JsonProperty(\\\"sortDefinition\\\")] public SortDefinition SortDefinition { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class QueryState\\n        {\\n            [JsonProperty(\\\"Rows\\\", Order = 1)] public VisualDto.ProjectionsSet Rows { get; set; }\\n            [JsonProperty(\\\"Category\\\", Order = 2)] public VisualDto.ProjectionsSet Category { get; set; }\\n            [JsonProperty(\\\"Y\\\", Order = 3)] public VisualDto.ProjectionsSet Y { get; set; }\\n            [JsonProperty(\\\"Y2\\\", Order = 4)] public VisualDto.ProjectionsSet Y2 { get; set; }\\n            [JsonProperty(\\\"Values\\\", Order = 5)] public VisualDto.ProjectionsSet Values { get; set; }\\n            \\n            [JsonProperty(\\\"Series\\\", Order = 6)] public VisualDto.ProjectionsSet Series { get; set; }\\n            [JsonProperty(\\\"Data\\\", Order = 7)] public VisualDto.ProjectionsSet Data { get; set; }\\n\\n            \\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ProjectionsSet\\n        {\\n            [JsonProperty(\\\"projections\\\")] public List<VisualDto.Projection> Projections { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Projection\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"queryRef\\\")] public string QueryRef { get; set; }\\n            [JsonProperty(\\\"nativeQueryRef\\\")] public string NativeQueryRef { get; set; }\\n            [JsonProperty(\\\"active\\\")] public bool? Active { get; set; }\\n            [JsonProperty(\\\"hidden\\\")] public bool? Hidden { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Field\\n        {\\n            [JsonProperty(\\\"Aggregation\\\")] public VisualDto.Aggregation Aggregation { get; set; }\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")] public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n            [JsonProperty(\\\"Measure\\\")] public VisualDto.MeasureObject Measure { get; set; }\\n            [JsonProperty(\\\"Column\\\")] public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Aggregation\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Function\\\")] public int Function { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class NativeVisualCalculation\\n        {\\n            [JsonProperty(\\\"Language\\\")] public string Language { get; set; }\\n            [JsonProperty(\\\"Expression\\\")] public string Expression { get; set; }\\n            [JsonProperty(\\\"Name\\\")] public string Name { get; set; }\\n\\n            [JsonProperty(\\\"DataType\\\")] public string DataType { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class MeasureObject\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnField\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Expression\\n        {\\n            [JsonProperty(\\\"Column\\\")] public ColumnExpression Column { get; set; }\\n            [JsonProperty(\\\"SourceRef\\\")] public VisualDto.SourceRef SourceRef { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnExpression\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.SourceRef Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SourceRef\\n        {\\n            [JsonProperty(\\\"Schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"Entity\\\")] public string Entity { get; set; }\\n            [JsonProperty(\\\"Source\\\")] public string Source { get; set; }\\n\\n            \\n        }\\n\\n        public class SortDefinition\\n        {\\n            [JsonProperty(\\\"sort\\\")] public List<VisualDto.Sort> Sort { get; set; }\\n            [JsonProperty(\\\"isDefaultSort\\\")] public bool IsDefaultSort { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Sort\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"direction\\\")] public string Direction { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Objects\\n        {\\n            [JsonProperty(\\\"valueAxis\\\")] public List<VisualDto.ObjectProperties> ValueAxis { get; set; }\\n            [JsonProperty(\\\"general\\\")] public List<VisualDto.ObjectProperties> General { get; set; }\\n            [JsonProperty(\\\"data\\\")] public List<VisualDto.ObjectProperties> Data { get; set; }\\n            [JsonProperty(\\\"title\\\")] public List<VisualDto.ObjectProperties> Title { get; set; }\\n            [JsonProperty(\\\"legend\\\")] public List<VisualDto.ObjectProperties> Legend { get; set; }\\n            [JsonProperty(\\\"labels\\\")] public List<VisualDto.ObjectProperties> Labels { get; set; }\\n            [JsonProperty(\\\"dataPoint\\\")] public List<VisualDto.ObjectProperties> DataPoint { get; set; }\\n\\n\\n            [JsonProperty(\\\"referenceLabel\\\")] public List<VisualDto.ObjectProperties> ReferenceLabel { get; set; }\\n            [JsonProperty(\\\"referenceLabelDetail\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelDetail { get; set; }\\n            [JsonProperty(\\\"referenceLabelValue\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelValue { get; set; }\\n\\n            [JsonProperty(\\\"values\\\")] public List<VisualDto.ObjectProperties> Values { get; set; }\\n\\n            [JsonProperty(\\\"y1AxisReferenceLine\\\")] public List<VisualDto.ObjectProperties> Y1AxisReferenceLine { get; set; }\\n\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ObjectProperties\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            [JsonConverter(typeof(PropertiesConverter))]\\n            public Dictionary<string, object> Properties { get; set; }\\n\\n            [JsonProperty(\\\"selector\\\")]\\n            public Selector Selector { get; set; }\\n\\n\\n            [JsonExtensionData] public IDictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n\\n\\n        public class VisualObjectProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")] public Field Expr { get; set; }\\n            [JsonProperty(\\\"solid\\\")] public SolidColor Solid { get; set; }\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n\\n            [JsonProperty(\\\"paragraphs\\\")]\\n            public List<Paragraph> Paragraphs { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Paragraph\\n        {\\n            [JsonProperty(\\\"textRuns\\\")]\\n            public List<TextRun> TextRuns { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class TextRun\\n        {\\n            [JsonProperty(\\\"value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonProperty(\\\"url\\\")]\\n            public string Url { get; set; }\\n\\n            [JsonProperty(\\\"textStyle\\\")]\\n            public Dictionary<string, object> TextStyle { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SolidColor\\n        {\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColorExpression\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualColorExprWrapper Expr { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExprWrapper\\n        {\\n            [JsonProperty(\\\"FillRule\\\")] public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExpression\\n        {\\n            [JsonProperty(\\\"Input\\\")] public VisualDto.Field Input { get; set; }\\n            [JsonProperty(\\\"FillRule\\\")] public Dictionary<string, object> FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualColorExprWrapper\\n        {\\n            [JsonProperty(\\\"Measure\\\")]\\n            public VisualDto.MeasureObject Measure { get; set; }\\n\\n            [JsonProperty(\\\"Column\\\")]\\n            public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonProperty(\\\"Aggregation\\\")]\\n            public VisualDto.Aggregation Aggregation { get; set; }\\n\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")]\\n            public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n\\n            [JsonProperty(\\\"FillRule\\\")]\\n            public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        \\n\\n        public class Selector\\n        {\\n            \\n\\n            [JsonProperty(\\\"id\\\")]\\n            public string Id { get; set; }\\n\\n            [JsonProperty(\\\"order\\\")]\\n            public int? Order { get; set; }\\n\\n            [JsonProperty(\\\"data\\\")]\\n            public List<object> Data { get; set; }\\n\\n            [JsonProperty(\\\"metadata\\\")]\\n            public string Metadata { get; set; }\\n\\n            [JsonProperty(\\\"scopeId\\\")]\\n            public string ScopeId { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class PropertiesConverter : JsonConverter\\n        {\\n            public override bool CanConvert(Type objectType) => objectType == typeof(Dictionary<string, object>);\\n\\n            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)\\n            {\\n                var result = new Dictionary<string, object>();\\n                var jObj = JObject.Load(reader);\\n\\n                foreach (var prop in jObj.Properties())\\n                {\\n                    if (prop.Name == \\\"paragraphs\\\")\\n                    {\\n                        var paragraphs = prop.Value.ToObject<List<Paragraph>>(serializer);\\n                        result[prop.Name] = paragraphs;\\n                    }\\n                    else\\n                    {\\n                        var visualProp = prop.Value.ToObject<VisualObjectProperty>(serializer);\\n                        result[prop.Name] = visualProp;\\n                    }\\n                }\\n\\n                return result;\\n            }\\n\\n            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\\n            {\\n                var dict = (Dictionary<string, object>)value;\\n                writer.WriteStartObject();\\n\\n                foreach (var kvp in dict)\\n                {\\n                    writer.WritePropertyName(kvp.Key);\\n\\n                    if (kvp.Value is VisualObjectProperty vo)\\n                        serializer.Serialize(writer, vo);\\n                    else if (kvp.Value is List<Paragraph> ps)\\n                        serializer.Serialize(writer, ps);\\n                    else\\n                        serializer.Serialize(writer, kvp.Value);\\n                }\\n\\n                writer.WriteEndObject();\\n            }\\n        }\\n    }\\n\\n\\n    public class VisualExtended\\n    {\\n        public VisualDto.Root Content { get; set; }\\n\\n        public string VisualFilePath { get; set; }\\n\\n\\n        public Boolean isVisualGroup => Content?.VisualGroup != null;\\n        public Boolean isGroupedVisual => Content?.ParentGroupName != null;\\n\\n        public bool IsBilingualVisualGroup()\\n        {\\n            if (!isVisualGroup || string.IsNullOrEmpty(Content.VisualGroup.DisplayName))\\n                return false;\\n            return System.Text.RegularExpressions.Regex.IsMatch(Content.VisualGroup.DisplayName, @\\\"^P\\d{2}-\\d{3}$\\\");\\n        }\\n\\n        public PageExtended ParentPage { get; set; }\\n\\n        public bool IsInBilingualVisualGroup()\\n        {\\n            if (ParentPage == null || ParentPage.Visuals == null || Content.ParentGroupName == null)\\n                return false;\\n            return ParentPage.Visuals.Any(v => v.IsBilingualVisualGroup() && v.Content.Name == Content.ParentGroupName);\\n        }\\n\\n        [JsonIgnore]\\n        public string AltText\\n        {\\n            get\\n            {\\n                var general = Content?.Visual?.VisualContainerObjects?.General;\\n                if (general == null || general.Count == 0)\\n                    return null;\\n                if (!general[0].Properties.ContainsKey(\\\"altText\\\"))\\n                    return null;\\n                return general[0].Properties[\\\"altText\\\"]?.Expr?.Literal?.Value?.Trim('\\'');\\n            }\\n            set\\n            {\\n                if(Content?.Visual == null)\\n                    Content.Visual = new VisualDto.Visual();\\n\\n                // Ensure the structure exists\\n                if (Content?.Visual?.VisualContainerObjects == null)\\n                    Content.Visual.VisualContainerObjects = new VisualDto.VisualContainerObjects();\\n\\n                if (Content.Visual?.VisualContainerObjects.General == null || Content.Visual?.VisualContainerObjects.General.Count == 0)\\n                    Content.Visual.VisualContainerObjects.General = \\n                        new List<VisualDto.VisualContainerObject> { \\n                            new VisualDto.VisualContainerObject { \\n                                Properties = new Dictionary<string, VisualDto.VisualContainerProperty>() \\n                            } \\n                        };\\n\\n                var general = Content.Visual.VisualContainerObjects.General[0];\\n\\n                if (general.Properties == null)\\n                    general.Properties = new Dictionary<string, VisualDto.VisualContainerProperty>();\\n\\n                general.Properties[\\\"altText\\\"] = new VisualDto.VisualContainerProperty\\n                {\\n                    Expr = new VisualDto.VisualExpr\\n                    {\\n                        Literal = new VisualDto.VisualLiteral\\n                        {\\n                            Value = value == null ? null : \\\"'\\\" + value.Replace(\\\"'\\\", \\\"\\\\'\\\") + \\\"'\\\"\\n                        }\\n                    }\\n                };\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetAllFields()\\n        {\\n            var fields = new List<VisualDto.Field>();\\n            var queryState = Content?.Visual?.Query?.QueryState;\\n\\n            if (queryState != null)\\n            {\\n                fields.AddRange(GetFieldsFromProjections(queryState.Values));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y2));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Category));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Series));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Data));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Rows));\\n            }\\n\\n            var sortList = Content?.Visual?.Query?.SortDefinition?.Sort;\\n            if (sortList != null)\\n                fields.AddRange(sortList.Select(s => s.Field));\\n\\n            var objects = Content?.Visual?.Objects;\\n            if (objects != null)\\n            {\\n                fields.AddRange(GetFieldsFromObjectList(objects.DataPoint));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Data));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Labels));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Title));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Legend));\\n                fields.AddRange(GetFieldsFromObjectList(objects.General));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ValueAxis));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Y1AxisReferenceLine));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabel));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelDetail));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelValue));\\n\\n            }\\n\\n            fields.AddRange(GetFieldsFromFilterConfig(Content?.FilterConfig));\\n\\n            return fields.Where(f => f != null);\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromProjections(VisualDto.ProjectionsSet set)\\n        {\\n            return set?.Projections?.Select(p => p.Field) ?? Enumerable.Empty<VisualDto.Field>();\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromObjectList(List<VisualDto.ObjectProperties> objectList)\\n        {\\n            if (objectList == null) yield break;\\n\\n            foreach (var obj in objectList)\\n            {\\n                if (obj.Properties == null) continue;\\n\\n                foreach (var val in obj.Properties.Values)\\n                {\\n                    var prop = val as VisualDto.VisualObjectProperty;\\n                    if (prop == null) continue;\\n\\n                    if (prop.Expr != null)\\n                    {\\n                        if (prop.Expr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = prop.Expr.Measure };\\n\\n                        if (prop.Expr.Column != null)\\n                            yield return new VisualDto.Field { Column = prop.Expr.Column };\\n                    }\\n\\n                    if (prop.Color != null &&\\n                        prop.Color.Expr != null &&\\n                        prop.Color.Expr.FillRule != null &&\\n                        prop.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    if (prop.Solid != null &&\\n                        prop.Solid.Color != null &&\\n                        prop.Solid.Color.Expr != null &&\\n                        prop.Solid.Color.Expr.FillRule != null &&\\n                        prop.Solid.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Solid.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    var solidExpr = prop.Solid != null &&\\n                                    prop.Solid.Color != null\\n                                    ? prop.Solid.Color.Expr\\n                                    : null;\\n\\n                    if (solidExpr != null)\\n                    {\\n                        if (solidExpr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = solidExpr.Measure };\\n\\n                        if (solidExpr.Column != null)\\n                            yield return new VisualDto.Field { Column = solidExpr.Column };\\n                    }\\n                }\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromFilterConfig(object filterConfig)\\n        {\\n            var fields = new List<VisualDto.Field>();\\n\\n            if (filterConfig is JObject jObj)\\n            {\\n                foreach (var token in jObj.DescendantsAndSelf().OfType<JObject>())\\n                {\\n                    var table = token[\\\"table\\\"]?.ToString();\\n                    var property = token[\\\"column\\\"]?.ToString() ?? token[\\\"measure\\\"]?.ToString();\\n\\n                    if (!string.IsNullOrEmpty(table) && !string.IsNullOrEmpty(property))\\n                    {\\n                        var field = new VisualDto.Field();\\n\\n                        if (token[\\\"measure\\\"] != null)\\n                        {\\n                            field.Measure = new VisualDto.MeasureObject\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n                        else if (token[\\\"column\\\"] != null)\\n                        {\\n                            field.Column = new VisualDto.ColumnField\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n\\n                        fields.Add(field);\\n                    }\\n                }\\n            }\\n\\n            return fields;\\n        }\\n\\n\\n        public IEnumerable<string> GetAllReferencedMeasures()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Measure)\\n                .Where(m => m?.Expression?.SourceRef?.Entity != null && m.Property != null)\\n                .Select(m => $\\\"'{m.Expression.SourceRef.Entity}'[{m.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public IEnumerable<string> GetAllReferencedColumns()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Column)\\n                .Where(c => c?.Expression?.SourceRef?.Entity != null && c.Property != null)\\n                .Select(c => $\\\"'{c.Expression.SourceRef.Entity}'[{c.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public void ReplaceMeasure(string oldFieldKey, Measure newMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Measure = new VisualDto.MeasureObject\\n                {\\n                    Property = newMeasure.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newMeasure.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: true, modifiedSet);\\n        }\\n\\n        public void ReplaceColumn(string oldFieldKey, Column newColumn, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Column = new VisualDto.ColumnField\\n                {\\n                    Property = newColumn.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newColumn.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: false, modifiedSet);\\n        }\\n\\n        private string ToFieldKey(VisualDto.Field f)\\n        {\\n            if (f?.Measure?.Expression?.SourceRef?.Entity is string mEntity && f.Measure.Property is string mProp)\\n                return $\\\"'{mEntity}'[{mProp}]\\\";\\n\\n            if (f?.Column?.Expression?.SourceRef?.Entity is string cEntity && f.Column.Property is string cProp)\\n                return $\\\"'{cEntity}'[{cProp}]\\\";\\n\\n            return null;\\n        }\\n\\n        private void ReplaceField(string oldFieldKey, VisualDto.Field newField, bool isMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var query = Content?.Visual?.Query;\\n            var objects = Content?.Visual?.Objects;\\n            bool wasModified = false;\\n\\n            void Replace(VisualDto.Field f)\\n            {\\n                if (f == null) return;\\n\\n                if (isMeasure)\\n                {\\n                    f.Measure = newField.Measure;\\n                    f.Column = null;\\n                    wasModified = true;\\n                }\\n                else\\n                {\\n                    f.Column = newField.Column;\\n                    f.Measure = null;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            void UpdateProjection(VisualDto.Projection proj)\\n            {\\n                if (proj == null) return;\\n\\n                if (ToFieldKey(proj.Field) == oldFieldKey)\\n                {\\n                    Replace(proj.Field);\\n\\n                    string entity = isMeasure\\n                        ? newField.Measure.Expression?.SourceRef?.Entity\\n                        : newField.Column.Expression?.SourceRef?.Entity;\\n\\n                    string prop = isMeasure\\n                        ? newField.Measure.Property\\n                        : newField.Column.Property;\\n\\n                    if (!string.IsNullOrEmpty(entity) && !string.IsNullOrEmpty(prop))\\n                    {\\n                        proj.QueryRef = $\\\"{entity}.{prop}\\\";\\n                        //proj.NativeQueryRef = prop;\\n                    }\\n\\n                    wasModified = true;\\n                }\\n            }\\n\\n            foreach (var proj in query?.QueryState?.Values?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Y?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n            \\n            foreach (var proj in query?.QueryState?.Y2?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Category?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Series?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Data?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Rows?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var sort in query?.SortDefinition?.Sort ?? Enumerable.Empty<VisualDto.Sort>())\\n                if (ToFieldKey(sort.Field) == oldFieldKey) Replace(sort.Field);\\n\\n            string oldMetadata = oldFieldKey.Replace(\\\"'\\\", \\\"\\\").Replace(\\\"[\\\", \\\".\\\").Replace(\\\"]\\\", \\\"\\\");\\n            string newMetadata = isMeasure\\n                ? $\\\"{newField.Measure.Expression.SourceRef.Entity}.{newField.Measure.Property}\\\"\\n                : $\\\"{newField.Column.Expression.SourceRef.Entity}.{newField.Column.Property}\\\";\\n\\n            IEnumerable<VisualDto.ObjectProperties> AllObjectProperties() =>\\n                (objects?.DataPoint ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Data ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Labels ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Title ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Legend ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.General ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ValueAxis ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabel ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelDetail ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelValue ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Values ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Y1AxisReferenceLine ?? Enumerable.Empty<VisualDto.ObjectProperties>());\\n\\n            foreach (var obj in AllObjectProperties())\\n            {\\n                foreach (var prop in obj.Properties.Values.OfType<VisualDto.VisualObjectProperty>())\\n                {\\n                    var field = isMeasure ? new VisualDto.Field { Measure = prop.Expr?.Measure } : new VisualDto.Field { Column = prop.Expr?.Column };\\n                    if (ToFieldKey(field) == oldFieldKey)\\n                    {\\n                        if (prop.Expr != null)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                prop.Expr.Measure = newField.Measure;\\n                                prop.Expr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                prop.Expr.Column = newField.Column;\\n                                prop.Expr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n\\n                    var fillInput = prop.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(fillInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            fillInput.Measure = newField.Measure;\\n                            fillInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            fillInput.Column = newField.Column;\\n                            fillInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    var solidInput = prop.Solid?.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(solidInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            solidInput.Measure = newField.Measure;\\n                            solidInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            solidInput.Column = newField.Column;\\n                            solidInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    // ✅ NEW: handle direct measure/column under solid.color.expr\\n                    var solidExpr = prop.Solid?.Color?.Expr;\\n                    if (solidExpr != null)\\n                    {\\n                        var solidField = isMeasure\\n                            ? new VisualDto.Field { Measure = solidExpr.Measure }\\n                            : new VisualDto.Field { Column = solidExpr.Column };\\n\\n                        if (ToFieldKey(solidField) == oldFieldKey)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                solidExpr.Measure = newField.Measure;\\n                                solidExpr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                solidExpr.Column = newField.Column;\\n                                solidExpr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (obj.Selector?.Metadata == oldMetadata)\\n                {\\n                    obj.Selector.Metadata = newMetadata;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            if (Content.FilterConfig != null)\\n            {\\n                var filterConfigString = Content.FilterConfig.ToString();\\n                string table = isMeasure ? newField.Measure.Expression.SourceRef.Entity : newField.Column.Expression.SourceRef.Entity;\\n                string prop = isMeasure ? newField.Measure.Property : newField.Column.Property;\\n\\n                string oldPattern = oldFieldKey;\\n                string newPattern = $\\\"'{table}'[{prop}]\\\";\\n\\n                if (filterConfigString.Contains(oldPattern))\\n                {\\n                    Content.FilterConfig = filterConfigString.Replace(oldPattern, newPattern);\\n                    wasModified = true;\\n                }\\n            }\\n            if (wasModified && modifiedSet != null)\\n                modifiedSet.Add(this);\\n\\n        }\\n\\n        public void ReplaceInFilterConfigRaw(\\n            Dictionary<string, string> tableMap,\\n            Dictionary<string, string> fieldMap,\\n            HashSet<VisualExtended> modifiedVisuals = null)\\n        {\\n            if (Content.FilterConfig == null) return;\\n\\n            string originalJson = JsonConvert.SerializeObject(Content.FilterConfig);\\n            string updatedJson = originalJson;\\n\\n            foreach (var kv in tableMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            foreach (var kv in fieldMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            // Only update and track if something actually changed\\n            if (updatedJson != originalJson)\\n            {\\n                Content.FilterConfig = JsonConvert.DeserializeObject(updatedJson);\\n                modifiedVisuals?.Add(this);\\n            }\\n        }\\n\\n    }\\n\\n\\n\\n    public class PageExtended\\n    {\\n        public PageDto Page { get; set; }\\n\\n        public ReportExtended ParentReport { get; set; }\\n\\n        public int PageIndex\\n        {\\n            get\\n            {\\n                if (ParentReport == null || ParentReport.PagesConfig == null || ParentReport.PagesConfig.PageOrder == null)\\n                    return -1;\\n                return ParentReport.PagesConfig.PageOrder.IndexOf(Page.Name);\\n            }\\n        }\\n\\n\\n        public IList<VisualExtended> Visuals { get; set; } = new List<VisualExtended>();\\n        public string PageFilePath { get; set; }\\n    }\\n\\n\\n    public class ReportExtended\\n    {\\n        public IList<PageExtended> Pages { get; set; } = new List<PageExtended>();\\n        public string PagesFilePath { get; set; }\\n        public PagesDto PagesConfig { get; set; }\\n    }\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\Report Layer Macros\\Repleace Field",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\n//2025-05-25/B.Agullo\\n//provided a definition.pbir file, this script allows the user to replace a measure in all visuals that use it with another measure.\\n//when executing the script you must be connected to the semantic model to which the report is connected to or one that is identical. \\n//see https://www.esbrina-ba.com/pbir-scripts-to-replace-field-and-open-visual-json-files/ for reference on how to use it\\nusing System.Windows.Forms;\\n\\n\\n\\nusing Microsoft.VisualBasic;\\nusing System.IO;\\nusing Newtonsoft.Json.Linq;\\nReportExtended report = Rx.InitReport();\\nif (report == null) return;\\nvar modifiedVisuals = new HashSet<VisualExtended>();\\nvar allVisuals = report.Pages\\n .SelectMany(p => p.Visuals.Select(v => new { Page = p.Page, Visual = v }))\\n .ToList();\\nIList<string> allReportMeasures = allVisuals\\n    .SelectMany(x => x.Visual.GetAllReferencedMeasures())\\n    .Distinct()\\n    .ToList();\\nstring measureToReplace = Fx.ChooseString(\\n    OptionList: allReportMeasures,\\n    \\\"Select a measure to replace\\\"\\n);\\nif (string.IsNullOrEmpty(measureToReplace))\\n{\\n    Error(\\\"No measure selected.\\\");\\n    return;\\n}\\nMeasure replacementMeasure = SelectMeasure(\\n    label: $\\\"Select a replacement for '{measureToReplace}'\\\"\\n);\\nif (replacementMeasure == null)\\n{\\n    Error(\\\"No replacement measure selected.\\\");\\n    return;\\n}\\nvar visualsUsingMeasure = allVisuals\\n    .Where(x => x.Visual.GetAllReferencedMeasures().Contains(measureToReplace))\\n    .Select(x => new\\n    {\\n        Display = $\\\"{x.Page.DisplayName} - {x.Visual.Content.Visual.VisualType} ({(int)x.Visual.Content.Position.X}, {(int)x.Visual.Content.Position.Y})\\\",\\n        Visual = x.Visual\\n    })\\n    .ToList();\\nif (visualsUsingMeasure.Count == 0)\\n{\\n    Info($\\\"No visuals use the measure '{measureToReplace}'.\\\");\\n    return;\\n}\\n// Step 2: Let the user choose one or more visuals\\nvar options = visualsUsingMeasure.Select(v => v.Display).ToList();\\nList<string> selected = Fx.ChooseStringMultiple(options, \\\"Select visuals to update\\\");\\nif (selected == null || selected.Count == 0)\\n{\\n    Info(\\\"No visuals selected.\\\");\\n    return;\\n}\\n// Step 3: Apply replacement only to selected visuals\\nforeach (var visualEntry in visualsUsingMeasure)\\n{\\n    if (selected.Contains(visualEntry.Display))\\n    {\\n        visualEntry.Visual.ReplaceMeasure(measureToReplace, replacementMeasure);\\n        modifiedVisuals.Add(visualEntry.Visual);\\n    }\\n}\\n// Save modified visuals\\nforeach (var visual in modifiedVisuals)\\n{\\n    Rx.SaveVisual(visual);\\n}\\nOutput($\\\"{modifiedVisuals.Count} visuals were modified.\\\");\\n\\npublic static class Fx\\n{\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        return model.Tables.FirstOrDefault(t =>\\n                            string.Equals(t.Name, tableName, StringComparison.OrdinalIgnoreCase)) //case insensitive search\\n                            ?? model.AddCalculatedTable(tableName, tableExpression);\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {\\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList, string Label = \\\"Choose item\\\")\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect: false, Label:Label) as string;\\n    }\\n    public static List<string> ChooseStringMultiple(IList<string> OptionList, string Label = \\\"Choose item(s)\\\")\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect:true, Label:Label) as List<string>;\\n    }\\n    private static object ChooseStringInternal(IList<string> OptionList, bool MultiSelect, string Label = \\\"Choose item(s)\\\")\\n    {\\n        Form form = new Form\\n        {\\n            Text =Label,\\n            Width = 400,\\n            Height = 500,\\n            StartPosition = FormStartPosition.CenterScreen,\\n            Padding = new Padding(20)\\n        };\\n        ListBox listbox = new ListBox\\n        {\\n            Dock = DockStyle.Fill,\\n            SelectionMode = MultiSelect ? SelectionMode.MultiExtended : SelectionMode.One\\n        };\\n        listbox.Items.AddRange(OptionList.ToArray());\\n        if (!MultiSelect && OptionList.Count > 0)\\n            listbox.SelectedItem = OptionList[0];\\n        FlowLayoutPanel buttonPanel = new FlowLayoutPanel\\n        {\\n            Dock = DockStyle.Bottom,\\n            Height = 40,\\n            FlowDirection = FlowDirection.LeftToRight,\\n            Padding = new Padding(10)\\n        };\\n        Button selectAllButton = new Button { Text = \\\"Select All\\\", Visible = MultiSelect };\\n        Button selectNoneButton = new Button { Text = \\\"Select None\\\", Visible = MultiSelect };\\n        Button okButton = new Button { Text = \\\"OK\\\", DialogResult = DialogResult.OK };\\n        Button cancelButton = new Button { Text = \\\"Cancel\\\", DialogResult = DialogResult.Cancel };\\n        selectAllButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, true);\\n        };\\n        selectNoneButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, false);\\n        };\\n        buttonPanel.Controls.Add(selectAllButton);\\n        buttonPanel.Controls.Add(selectNoneButton);\\n        buttonPanel.Controls.Add(okButton);\\n        buttonPanel.Controls.Add(cancelButton);\\n        form.Controls.Add(listbox);\\n        form.Controls.Add(buttonPanel);\\n        DialogResult result = form.ShowDialog();\\n        if (result == DialogResult.Cancel)\\n        {\\n            Info(\\\"You Cancelled!\\\");\\n            return null;\\n        }\\n        if (MultiSelect)\\n        {\\n            List<string> selectedItems = new List<string>();\\n            foreach (object item in listbox.SelectedItems)\\n                selectedItems.Add(item.ToString());\\n            return selectedItems;\\n        }\\n        else\\n        {\\n            return listbox.SelectedItem != null ? listbox.SelectedItem.ToString() : null;\\n        }\\n    }\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        var dateTables = model.Tables\\n            .Where(t => t.DataCategory == \\\"Time\\\" &&\\n                   t.Columns.Any(c => c.IsKey && c.DataType == DataType.DateTime))\\n            .ToList();\\n        if (!dateTables.Any())\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n            return null;\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        return GetFilteredTables(tables, lambda).FirstOrDefault();\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table, bool> lambda)\\n    {\\n        var filteredTables = tables.Where(t => lambda(t));\\n        return filteredTables.Any() ? filteredTables : null;\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column, bool> lambda, bool returnAllIfNoneFound = true)\\n    {\\n        var filteredColumns = columns.Where(c => lambda(c));\\n        return filteredColumns.Any() || returnAllIfNoneFound ? filteredColumns : null;\\n    }\\n}\\n\\npublic static class Rx\\n\\n{\\n\\n    \\n\\n\\n\\n\\n\\n    public static ReportExtended InitReport()\\n\\n    {\\n\\n        // Get the base path from the user  \\n\\n        string basePath = Rx.GetPbirFilePath();\\n\\n        if (basePath == null)\\n\\n        {\\n\\n            Error(\\\"Operation canceled by the user.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Define the target path  \\n\\n        string baseDirectory = Path.GetDirectoryName(basePath);\\n\\n        string targetPath = Path.Combine(baseDirectory, \\\"definition\\\", \\\"pages\\\");\\n\\n\\n\\n        // Check if the target path exists  \\n\\n        if (!Directory.Exists(targetPath))\\n\\n        {\\n\\n            Error(String.Format(\\\"The path '{0}' does not exist.\\\", targetPath));\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Get all subfolders in the target path  \\n\\n        List<string> subfolders = Directory.GetDirectories(targetPath).ToList();\\n\\n\\n\\n        ReportExtended report = new ReportExtended();\\n\\n        report.PagesFilePath = Path.Combine(targetPath, \\\"pages.json\\\");\\n\\n\\n\\n        // Process each folder  \\n\\n        foreach (string folder in subfolders)\\n\\n        {\\n\\n            string pageJsonPath = Path.Combine(folder, \\\"page.json\\\");\\n\\n            if (File.Exists(pageJsonPath))\\n\\n            {\\n\\n                try\\n\\n                {\\n\\n                    string jsonContent = File.ReadAllText(pageJsonPath);\\n\\n                    PageDto page = JsonConvert.DeserializeObject<PageDto>(jsonContent);\\n\\n\\n\\n                    PageExtended pageExtended = new PageExtended();\\n\\n                    pageExtended.Page = page;\\n\\n                    pageExtended.PageFilePath = pageJsonPath;\\n\\n\\n\\n                    string visualsPath = Path.Combine(folder, \\\"visuals\\\");\\n\\n\\n\\n                    if (!Directory.Exists(visualsPath))\\n\\n                    {\\n\\n                        report.Pages.Add(pageExtended); // still add the page\\n\\n                        continue; // skip visual loading\\n\\n                    }\\n\\n\\n\\n                    List<string> visualSubfolders = Directory.GetDirectories(visualsPath).ToList();\\n\\n\\n\\n                    foreach (string visualFolder in visualSubfolders)\\n\\n                    {\\n\\n                        string visualJsonPath = Path.Combine(visualFolder, \\\"visual.json\\\");\\n\\n                        if (File.Exists(visualJsonPath))\\n\\n                        {\\n\\n                            try\\n\\n                            {\\n\\n                                string visualJsonContent = File.ReadAllText(visualJsonPath);\\n\\n                                VisualDto.Root visual = JsonConvert.DeserializeObject<VisualDto.Root>(visualJsonContent);\\n\\n\\n\\n                                VisualExtended visualExtended = new VisualExtended();\\n\\n                                visualExtended.Content = visual;\\n\\n                                visualExtended.VisualFilePath = visualJsonPath;\\n\\n\\n\\n                                pageExtended.Visuals.Add(visualExtended);\\n\\n                            }\\n\\n                            catch (Exception ex2)\\n\\n                            {\\n\\n                                Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", visualJsonPath, ex2.Message));\\n\\n                                return null;\\n\\n                            }\\n\\n\\n\\n                        }\\n\\n                    }\\n\\n\\n\\n                    report.Pages.Add(pageExtended);\\n\\n\\n\\n                }\\n\\n                catch (Exception ex)\\n\\n                {\\n\\n                    Output(String.Format(\\\"Error reading or deserializing '{0}': {1}\\\", pageJsonPath, ex.Message));\\n\\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        return report;\\n\\n    }\\n\\n\\n\\n    public static VisualExtended SelectVisual(ReportExtended report)\\n\\n    {\\n\\n        // Step 1: Build selection list\\n\\n        var visualSelectionList = report.Pages\\n\\n            .SelectMany(p => p.Visuals.Select(v => new\\n\\n            {\\n\\n                Display = string.Format(\\\"{0} - {1} ({2}, {3})\\\", p.Page.DisplayName, v.Content.Visual.VisualType, (int)v.Content.Position.X, (int)v.Content.Position.Y),\\n\\n                Page = p,\\n\\n                Visual = v\\n\\n            }))\\n\\n            .ToList();\\n\\n\\n\\n        // Step 2: Let user choose a visual\\n\\n        var options = visualSelectionList.Select(v => v.Display).ToList();\\n\\n        string selected = Fx.ChooseString(options);\\n\\n\\n\\n        if (string.IsNullOrEmpty(selected))\\n\\n        {\\n\\n            Info(\\\"You cancelled.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        // Step 3: Find the selected visual\\n\\n        var selectedVisual = visualSelectionList.FirstOrDefault(v => v.Display == selected);\\n\\n\\n\\n        if (selectedVisual == null)\\n\\n        {\\n\\n            Error(\\\"Selected visual not found.\\\");\\n\\n            return null;\\n\\n        }\\n\\n\\n\\n        return selectedVisual.Visual;\\n\\n    }\\n\\n\\n\\n    public static void SaveVisual(VisualExtended visual)\\n\\n    {\\n\\n\\n\\n        // Save new JSON, ignoring nulls\\n\\n        string newJson = JsonConvert.SerializeObject(\\n\\n            visual.Content,\\n\\n            Newtonsoft.Json.Formatting.Indented,\\n\\n            new JsonSerializerSettings\\n\\n            {\\n\\n                DefaultValueHandling = DefaultValueHandling.Ignore,\\n\\n                NullValueHandling = NullValueHandling.Ignore\\n\\n\\n\\n            }\\n\\n        );\\n\\n        File.WriteAllText(visual.VisualFilePath, newJson);\\n\\n    }\\n\\n\\n\\n\\n\\n    public static string ReplacePlaceholders(string pageContents, Dictionary<string, string> placeholders)\\n\\n    {\\n\\n        if (placeholders != null)\\n\\n        {\\n\\n            foreach (string placeholder in placeholders.Keys)\\n\\n            {\\n\\n                string valueToReplace = placeholders[placeholder];\\n\\n\\n\\n                pageContents = pageContents.Replace(placeholder, valueToReplace);\\n\\n\\n\\n            }\\n\\n        }\\n\\n\\n\\n\\n\\n        return pageContents;\\n\\n    }\\n\\n\\n\\n\\n\\n    public static String GetPbirFilePath()\\n\\n    {\\n\\n\\n\\n        // Create an instance of the OpenFileDialog\\n\\n        OpenFileDialog openFileDialog = new OpenFileDialog\\n\\n        {\\n\\n            Title = \\\"Please select definition.pbir file of the target report\\\",\\n\\n            // Set filter options and filter index.\\n\\n            Filter = \\\"PBIR Files (*.pbir)|*.pbir\\\",\\n\\n            FilterIndex = 1\\n\\n        };\\n\\n        // Call the ShowDialog method to show the dialog box.\\n\\n        DialogResult result = openFileDialog.ShowDialog();\\n\\n        // Process input if the user clicked OK.\\n\\n        if (result != DialogResult.OK)\\n\\n        {\\n\\n            Error(\\\"You cancelled\\\");\\n\\n            return null;\\n\\n        }\\n\\n        return openFileDialog.FileName;\\n\\n\\n\\n    }\\n\\n\\n\\n\\n\\n}\\n\\n\\n\\n   \\n\\n    public class PagesDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"pageOrder\\\")]\\n        public List<string> PageOrder { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"activePageName\\\")]\\n        public string ActivePageName { get; set; }\\n    }\\n\\n\\n    public class PageDto\\n    {\\n        [Newtonsoft.Json.JsonProperty(\\\"$schema\\\")]\\n        public string Schema { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"name\\\")]\\n        public string Name { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayName\\\")]\\n        public string DisplayName { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"displayOption\\\")]\\n        public string DisplayOption { get; set; } // Could create enum if you want stricter typing\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"height\\\")]\\n        public double? Height { get; set; }\\n\\n        [Newtonsoft.Json.JsonProperty(\\\"width\\\")]\\n        public double? Width { get; set; }\\n    }\\n\\n\\n\\n    public partial class VisualDto\\n    {\\n        public class Root\\n        {\\n            [JsonProperty(\\\"$schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"name\\\")] public string Name { get; set; }\\n            [JsonProperty(\\\"position\\\")] public Position Position { get; set; }\\n            [JsonProperty(\\\"visual\\\")] public Visual Visual { get; set; }\\n            [JsonProperty(\\\"visualContainerObjects\\\")] public object VisualContainerObjects { get; set; }\\n            [JsonProperty(\\\"filterConfig\\\")] public object FilterConfig { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Position\\n        {\\n            [JsonProperty(\\\"x\\\")] public double X { get; set; }\\n            [JsonProperty(\\\"y\\\")] public double Y { get; set; }\\n            [JsonProperty(\\\"z\\\")] public int Z { get; set; }\\n            [JsonProperty(\\\"height\\\")] public double Height { get; set; }\\n            [JsonProperty(\\\"width\\\")] public double Width { get; set; }\\n            [JsonProperty(\\\"tabOrder\\\")] public int TabOrder { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Visual\\n        {\\n            [JsonProperty(\\\"visualType\\\", Order = 1)] public string VisualType { get; set; }\\n            [JsonProperty(\\\"query\\\", Order = 2)] public Query Query { get; set; }\\n            [JsonProperty(\\\"objects\\\", Order = 3)] public Objects Objects { get; set; }\\n            [JsonProperty(\\\"drillFilterOtherVisuals\\\", Order = 4)] public bool DrillFilterOtherVisuals { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Query\\n        {\\n            [JsonProperty(\\\"queryState\\\")] public QueryState QueryState { get; set; }\\n            [JsonProperty(\\\"sortDefinition\\\")] public SortDefinition SortDefinition { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class QueryState\\n        {\\n            [JsonProperty(\\\"Rows\\\", Order = 1)] public VisualDto.ProjectionsSet Rows { get; set; }\\n            [JsonProperty(\\\"Category\\\", Order = 2)] public VisualDto.ProjectionsSet Category { get; set; }\\n            [JsonProperty(\\\"Y\\\", Order = 3)] public VisualDto.ProjectionsSet Y { get; set; }\\n            [JsonProperty(\\\"Y2\\\", Order = 4)] public VisualDto.ProjectionsSet Y2 { get; set; }\\n            [JsonProperty(\\\"Values\\\", Order = 5)] public VisualDto.ProjectionsSet Values { get; set; }\\n            \\n            [JsonProperty(\\\"Series\\\", Order = 6)] public VisualDto.ProjectionsSet Series { get; set; }\\n            [JsonProperty(\\\"Data\\\", Order = 7)] public VisualDto.ProjectionsSet Data { get; set; }\\n\\n            \\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ProjectionsSet\\n        {\\n            [JsonProperty(\\\"projections\\\")] public List<VisualDto.Projection> Projections { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Projection\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"queryRef\\\")] public string QueryRef { get; set; }\\n            [JsonProperty(\\\"nativeQueryRef\\\")] public string NativeQueryRef { get; set; }\\n            [JsonProperty(\\\"active\\\")] public bool? Active { get; set; }\\n            [JsonProperty(\\\"hidden\\\")] public bool? Hidden { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Field\\n        {\\n            [JsonProperty(\\\"Aggregation\\\")] public VisualDto.Aggregation Aggregation { get; set; }\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")] public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n            [JsonProperty(\\\"Measure\\\")] public VisualDto.MeasureObject Measure { get; set; }\\n            [JsonProperty(\\\"Column\\\")] public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Aggregation\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Function\\\")] public int Function { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class NativeVisualCalculation\\n        {\\n            [JsonProperty(\\\"Language\\\")] public string Language { get; set; }\\n            [JsonProperty(\\\"Expression\\\")] public string Expression { get; set; }\\n            [JsonProperty(\\\"Name\\\")] public string Name { get; set; }\\n\\n            [JsonProperty(\\\"DataType\\\")] public string DataType { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class MeasureObject\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnField\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.Expression Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Expression\\n        {\\n            [JsonProperty(\\\"Column\\\")] public ColumnExpression Column { get; set; }\\n            [JsonProperty(\\\"SourceRef\\\")] public VisualDto.SourceRef SourceRef { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColumnExpression\\n        {\\n            [JsonProperty(\\\"Expression\\\")] public VisualDto.SourceRef Expression { get; set; }\\n            [JsonProperty(\\\"Property\\\")] public string Property { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SourceRef\\n        {\\n            [JsonProperty(\\\"Schema\\\")] public string Schema { get; set; }\\n            [JsonProperty(\\\"Entity\\\")] public string Entity { get; set; }\\n            [JsonProperty(\\\"Source\\\")] public string Source { get; set; }\\n\\n            \\n        }\\n\\n        public class SortDefinition\\n        {\\n            [JsonProperty(\\\"sort\\\")] public List<VisualDto.Sort> Sort { get; set; }\\n            [JsonProperty(\\\"isDefaultSort\\\")] public bool IsDefaultSort { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Sort\\n        {\\n            [JsonProperty(\\\"field\\\")] public VisualDto.Field Field { get; set; }\\n            [JsonProperty(\\\"direction\\\")] public string Direction { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Objects\\n        {\\n            [JsonProperty(\\\"valueAxis\\\")] public List<VisualDto.ObjectProperties> ValueAxis { get; set; }\\n            [JsonProperty(\\\"general\\\")] public List<VisualDto.ObjectProperties> General { get; set; }\\n            [JsonProperty(\\\"data\\\")] public List<VisualDto.ObjectProperties> Data { get; set; }\\n            [JsonProperty(\\\"title\\\")] public List<VisualDto.ObjectProperties> Title { get; set; }\\n            [JsonProperty(\\\"legend\\\")] public List<VisualDto.ObjectProperties> Legend { get; set; }\\n            [JsonProperty(\\\"labels\\\")] public List<VisualDto.ObjectProperties> Labels { get; set; }\\n            [JsonProperty(\\\"dataPoint\\\")] public List<VisualDto.ObjectProperties> DataPoint { get; set; }\\n\\n\\n            [JsonProperty(\\\"referenceLabel\\\")] public List<VisualDto.ObjectProperties> ReferenceLabel { get; set; }\\n            [JsonProperty(\\\"referenceLabelDetail\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelDetail { get; set; }\\n            [JsonProperty(\\\"referenceLabelValue\\\")] public List<VisualDto.ObjectProperties> ReferenceLabelValue { get; set; }\\n\\n            [JsonProperty(\\\"values\\\")] public List<VisualDto.ObjectProperties> Values { get; set; }\\n\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ObjectProperties\\n        {\\n            [JsonProperty(\\\"properties\\\")]\\n            [JsonConverter(typeof(PropertiesConverter))]\\n            public Dictionary<string, object> Properties { get; set; }\\n\\n            [JsonProperty(\\\"selector\\\")]\\n            public Selector Selector { get; set; }\\n\\n\\n            [JsonExtensionData] public IDictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n\\n\\n        public class VisualObjectProperty\\n        {\\n            [JsonProperty(\\\"expr\\\")] public Field Expr { get; set; }\\n            [JsonProperty(\\\"solid\\\")] public SolidColor Solid { get; set; }\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n\\n            [JsonProperty(\\\"paragraphs\\\")]\\n            public List<Paragraph> Paragraphs { get; set; }\\n\\n            [JsonExtensionData] public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class Paragraph\\n        {\\n            [JsonProperty(\\\"textRuns\\\")]\\n            public List<TextRun> TextRuns { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class TextRun\\n        {\\n            [JsonProperty(\\\"value\\\")]\\n            public string Value { get; set; }\\n\\n            [JsonProperty(\\\"url\\\")]\\n            public string Url { get; set; }\\n\\n            [JsonProperty(\\\"textStyle\\\")]\\n            public Dictionary<string, object> TextStyle { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class SolidColor\\n        {\\n            [JsonProperty(\\\"color\\\")] public ColorExpression Color { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class ColorExpression\\n        {\\n            [JsonProperty(\\\"expr\\\")]\\n            public VisualColorExprWrapper Expr { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExprWrapper\\n        {\\n            [JsonProperty(\\\"FillRule\\\")] public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class FillRuleExpression\\n        {\\n            [JsonProperty(\\\"Input\\\")] public VisualDto.Field Input { get; set; }\\n            [JsonProperty(\\\"FillRule\\\")] public Dictionary<string, object> FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class VisualColorExprWrapper\\n        {\\n            [JsonProperty(\\\"Measure\\\")]\\n            public VisualDto.MeasureObject Measure { get; set; }\\n\\n            [JsonProperty(\\\"Column\\\")]\\n            public VisualDto.ColumnField Column { get; set; }\\n\\n            [JsonProperty(\\\"Aggregation\\\")]\\n            public VisualDto.Aggregation Aggregation { get; set; }\\n\\n            [JsonProperty(\\\"NativeVisualCalculation\\\")]\\n            public NativeVisualCalculation NativeVisualCalculation { get; set; }\\n\\n            [JsonProperty(\\\"FillRule\\\")]\\n            public FillRuleExpression FillRule { get; set; }\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n\\n        \\n\\n        public class Selector\\n        {\\n            \\n\\n            [JsonProperty(\\\"id\\\")]\\n            public string Id { get; set; }\\n\\n            [JsonProperty(\\\"order\\\")]\\n            public int? Order { get; set; }\\n\\n            [JsonProperty(\\\"data\\\")]\\n            public List<object> Data { get; set; }\\n\\n            [JsonProperty(\\\"metadata\\\")]\\n            public string Metadata { get; set; }\\n\\n            [JsonProperty(\\\"scopeId\\\")]\\n            public string ScopeId { get; set; }\\n\\n            [JsonExtensionData]\\n            public Dictionary<string, JToken> ExtensionData { get; set; }\\n        }\\n\\n        public class PropertiesConverter : JsonConverter\\n        {\\n            public override bool CanConvert(Type objectType) => objectType == typeof(Dictionary<string, object>);\\n\\n            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)\\n            {\\n                var result = new Dictionary<string, object>();\\n                var jObj = JObject.Load(reader);\\n\\n                foreach (var prop in jObj.Properties())\\n                {\\n                    if (prop.Name == \\\"paragraphs\\\")\\n                    {\\n                        var paragraphs = prop.Value.ToObject<List<Paragraph>>(serializer);\\n                        result[prop.Name] = paragraphs;\\n                    }\\n                    else\\n                    {\\n                        var visualProp = prop.Value.ToObject<VisualObjectProperty>(serializer);\\n                        result[prop.Name] = visualProp;\\n                    }\\n                }\\n\\n                return result;\\n            }\\n\\n            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\\n            {\\n                var dict = (Dictionary<string, object>)value;\\n                writer.WriteStartObject();\\n\\n                foreach (var kvp in dict)\\n                {\\n                    writer.WritePropertyName(kvp.Key);\\n\\n                    if (kvp.Value is VisualObjectProperty vo)\\n                        serializer.Serialize(writer, vo);\\n                    else if (kvp.Value is List<Paragraph> ps)\\n                        serializer.Serialize(writer, ps);\\n                    else\\n                        serializer.Serialize(writer, kvp.Value);\\n                }\\n\\n                writer.WriteEndObject();\\n            }\\n        }\\n    }\\n\\n\\n    public class VisualExtended\\n    {\\n        public VisualDto.Root Content { get; set; }\\n\\n        public string VisualFilePath { get; set; }\\n\\n        private IEnumerable<VisualDto.Field> GetAllFields()\\n        {\\n            var fields = new List<VisualDto.Field>();\\n            var queryState = Content?.Visual?.Query?.QueryState;\\n\\n            if (queryState != null)\\n            {\\n                fields.AddRange(GetFieldsFromProjections(queryState.Values));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Y2));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Category));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Series));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Data));\\n                fields.AddRange(GetFieldsFromProjections(queryState.Rows));\\n            }\\n\\n            var sortList = Content?.Visual?.Query?.SortDefinition?.Sort;\\n            if (sortList != null)\\n                fields.AddRange(sortList.Select(s => s.Field));\\n\\n            var objects = Content?.Visual?.Objects;\\n            if (objects != null)\\n            {\\n                fields.AddRange(GetFieldsFromObjectList(objects.DataPoint));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Data));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Labels));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Title));\\n                fields.AddRange(GetFieldsFromObjectList(objects.Legend));\\n                fields.AddRange(GetFieldsFromObjectList(objects.General));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ValueAxis));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabel));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelDetail));\\n                fields.AddRange(GetFieldsFromObjectList(objects.ReferenceLabelValue));\\n\\n            }\\n\\n            fields.AddRange(GetFieldsFromFilterConfig(Content?.FilterConfig));\\n\\n            return fields.Where(f => f != null);\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromProjections(VisualDto.ProjectionsSet set)\\n        {\\n            return set?.Projections?.Select(p => p.Field) ?? Enumerable.Empty<VisualDto.Field>();\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromObjectList(List<VisualDto.ObjectProperties> objectList)\\n        {\\n            if (objectList == null) yield break;\\n\\n            foreach (var obj in objectList)\\n            {\\n                if (obj.Properties == null) continue;\\n\\n                foreach (var val in obj.Properties.Values)\\n                {\\n                    var prop = val as VisualDto.VisualObjectProperty;\\n                    if (prop == null) continue;\\n\\n                    if (prop.Expr != null)\\n                    {\\n                        if (prop.Expr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = prop.Expr.Measure };\\n\\n                        if (prop.Expr.Column != null)\\n                            yield return new VisualDto.Field { Column = prop.Expr.Column };\\n                    }\\n\\n                    if (prop.Color != null &&\\n                        prop.Color.Expr != null &&\\n                        prop.Color.Expr.FillRule != null &&\\n                        prop.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    if (prop.Solid != null &&\\n                        prop.Solid.Color != null &&\\n                        prop.Solid.Color.Expr != null &&\\n                        prop.Solid.Color.Expr.FillRule != null &&\\n                        prop.Solid.Color.Expr.FillRule.Input != null)\\n                    {\\n                        yield return prop.Solid.Color.Expr.FillRule.Input;\\n                    }\\n\\n                    var solidExpr = prop.Solid != null &&\\n                                    prop.Solid.Color != null\\n                                    ? prop.Solid.Color.Expr\\n                                    : null;\\n\\n                    if (solidExpr != null)\\n                    {\\n                        if (solidExpr.Measure != null)\\n                            yield return new VisualDto.Field { Measure = solidExpr.Measure };\\n\\n                        if (solidExpr.Column != null)\\n                            yield return new VisualDto.Field { Column = solidExpr.Column };\\n                    }\\n                }\\n            }\\n        }\\n\\n        private IEnumerable<VisualDto.Field> GetFieldsFromFilterConfig(object filterConfig)\\n        {\\n            var fields = new List<VisualDto.Field>();\\n\\n            if (filterConfig is JObject jObj)\\n            {\\n                foreach (var token in jObj.DescendantsAndSelf().OfType<JObject>())\\n                {\\n                    var table = token[\\\"table\\\"]?.ToString();\\n                    var property = token[\\\"column\\\"]?.ToString() ?? token[\\\"measure\\\"]?.ToString();\\n\\n                    if (!string.IsNullOrEmpty(table) && !string.IsNullOrEmpty(property))\\n                    {\\n                        var field = new VisualDto.Field();\\n\\n                        if (token[\\\"measure\\\"] != null)\\n                        {\\n                            field.Measure = new VisualDto.MeasureObject\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n                        else if (token[\\\"column\\\"] != null)\\n                        {\\n                            field.Column = new VisualDto.ColumnField\\n                            {\\n                                Property = property,\\n                                Expression = new VisualDto.Expression\\n                                {\\n                                    SourceRef = new VisualDto.SourceRef { Entity = table }\\n                                }\\n                            };\\n                        }\\n\\n                        fields.Add(field);\\n                    }\\n                }\\n            }\\n\\n            return fields;\\n        }\\n\\n\\n        public IEnumerable<string> GetAllReferencedMeasures()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Measure)\\n                .Where(m => m?.Expression?.SourceRef?.Entity != null && m.Property != null)\\n                .Select(m => $\\\"'{m.Expression.SourceRef.Entity}'[{m.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public IEnumerable<string> GetAllReferencedColumns()\\n        {\\n            return GetAllFields()\\n                .Select(f => f.Column)\\n                .Where(c => c?.Expression?.SourceRef?.Entity != null && c.Property != null)\\n                .Select(c => $\\\"'{c.Expression.SourceRef.Entity}'[{c.Property}]\\\")\\n                .Distinct();\\n        }\\n\\n        public void ReplaceMeasure(string oldFieldKey, Measure newMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Measure = new VisualDto.MeasureObject\\n                {\\n                    Property = newMeasure.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newMeasure.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: true, modifiedSet);\\n        }\\n\\n        public void ReplaceColumn(string oldFieldKey, Column newColumn, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var newField = new VisualDto.Field\\n            {\\n                Column = new VisualDto.ColumnField\\n                {\\n                    Property = newColumn.Name,\\n                    Expression = new VisualDto.Expression\\n                    {\\n                        SourceRef = new VisualDto.SourceRef { Entity = newColumn.Table.Name }\\n                    }\\n                }\\n            };\\n            ReplaceField(oldFieldKey, newField, isMeasure: false, modifiedSet);\\n        }\\n\\n        private string ToFieldKey(VisualDto.Field f)\\n        {\\n            if (f?.Measure?.Expression?.SourceRef?.Entity is string mEntity && f.Measure.Property is string mProp)\\n                return $\\\"'{mEntity}'[{mProp}]\\\";\\n\\n            if (f?.Column?.Expression?.SourceRef?.Entity is string cEntity && f.Column.Property is string cProp)\\n                return $\\\"'{cEntity}'[{cProp}]\\\";\\n\\n            return null;\\n        }\\n\\n        private void ReplaceField(string oldFieldKey, VisualDto.Field newField, bool isMeasure, HashSet<VisualExtended> modifiedSet = null)\\n        {\\n            var query = Content?.Visual?.Query;\\n            var objects = Content?.Visual?.Objects;\\n            bool wasModified = false;\\n\\n            void Replace(VisualDto.Field f)\\n            {\\n                if (f == null) return;\\n\\n                if (isMeasure)\\n                {\\n                    f.Measure = newField.Measure;\\n                    f.Column = null;\\n                    wasModified = true;\\n                }\\n                else\\n                {\\n                    f.Column = newField.Column;\\n                    f.Measure = null;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            void UpdateProjection(VisualDto.Projection proj)\\n            {\\n                if (proj == null) return;\\n\\n                if (ToFieldKey(proj.Field) == oldFieldKey)\\n                {\\n                    Replace(proj.Field);\\n\\n                    string entity = isMeasure\\n                        ? newField.Measure.Expression?.SourceRef?.Entity\\n                        : newField.Column.Expression?.SourceRef?.Entity;\\n\\n                    string prop = isMeasure\\n                        ? newField.Measure.Property\\n                        : newField.Column.Property;\\n\\n                    if (!string.IsNullOrEmpty(entity) && !string.IsNullOrEmpty(prop))\\n                    {\\n                        proj.QueryRef = $\\\"{entity}.{prop}\\\";\\n                        //proj.NativeQueryRef = prop;\\n                    }\\n\\n                    wasModified = true;\\n                }\\n            }\\n\\n            foreach (var proj in query?.QueryState?.Values?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Y?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n            \\n            foreach (var proj in query?.QueryState?.Y2?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Category?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Series?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Data?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var proj in query?.QueryState?.Rows?.Projections ?? Enumerable.Empty<VisualDto.Projection>())\\n                UpdateProjection(proj);\\n\\n            foreach (var sort in query?.SortDefinition?.Sort ?? Enumerable.Empty<VisualDto.Sort>())\\n                if (ToFieldKey(sort.Field) == oldFieldKey) Replace(sort.Field);\\n\\n            string oldMetadata = oldFieldKey.Replace(\\\"'\\\", \\\"\\\").Replace(\\\"[\\\", \\\".\\\").Replace(\\\"]\\\", \\\"\\\");\\n            string newMetadata = isMeasure\\n                ? $\\\"{newField.Measure.Expression.SourceRef.Entity}.{newField.Measure.Property}\\\"\\n                : $\\\"{newField.Column.Expression.SourceRef.Entity}.{newField.Column.Property}\\\";\\n\\n            IEnumerable<VisualDto.ObjectProperties> AllObjectProperties() =>\\n                (objects?.DataPoint ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Data ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Labels ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Title ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Legend ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.General ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ValueAxis ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabel ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelDetail ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.ReferenceLabelValue ?? Enumerable.Empty<VisualDto.ObjectProperties>())\\n                .Concat(objects?.Values ?? Enumerable.Empty<VisualDto.ObjectProperties>());\\n\\n            foreach (var obj in AllObjectProperties())\\n            {\\n                foreach (var prop in obj.Properties.Values.OfType<VisualDto.VisualObjectProperty>())\\n                {\\n                    var field = isMeasure ? new VisualDto.Field { Measure = prop.Expr?.Measure } : new VisualDto.Field { Column = prop.Expr?.Column };\\n                    if (ToFieldKey(field) == oldFieldKey)\\n                    {\\n                        if (prop.Expr != null)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                prop.Expr.Measure = newField.Measure;\\n                                prop.Expr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                prop.Expr.Column = newField.Column;\\n                                prop.Expr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n\\n                    var fillInput = prop.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(fillInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            fillInput.Measure = newField.Measure;\\n                            fillInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            fillInput.Column = newField.Column;\\n                            fillInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    var solidInput = prop.Solid?.Color?.Expr?.FillRule?.Input;\\n                    if (ToFieldKey(solidInput) == oldFieldKey)\\n                    {\\n                        if (isMeasure)\\n                        {\\n                            solidInput.Measure = newField.Measure;\\n                            solidInput.Column = null;\\n                            wasModified = true;\\n                        }\\n                        else\\n                        {\\n                            solidInput.Column = newField.Column;\\n                            solidInput.Measure = null;\\n                            wasModified = true;\\n                        }\\n                    }\\n\\n                    // ✅ NEW: handle direct measure/column under solid.color.expr\\n                    var solidExpr = prop.Solid?.Color?.Expr;\\n                    if (solidExpr != null)\\n                    {\\n                        var solidField = isMeasure\\n                            ? new VisualDto.Field { Measure = solidExpr.Measure }\\n                            : new VisualDto.Field { Column = solidExpr.Column };\\n\\n                        if (ToFieldKey(solidField) == oldFieldKey)\\n                        {\\n                            if (isMeasure)\\n                            {\\n                                solidExpr.Measure = newField.Measure;\\n                                solidExpr.Column = null;\\n                                wasModified = true;\\n                            }\\n                            else\\n                            {\\n                                solidExpr.Column = newField.Column;\\n                                solidExpr.Measure = null;\\n                                wasModified = true;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (obj.Selector?.Metadata == oldMetadata)\\n                {\\n                    obj.Selector.Metadata = newMetadata;\\n                    wasModified = true;\\n                }\\n            }\\n\\n            if (Content.FilterConfig != null)\\n            {\\n                var filterConfigString = Content.FilterConfig.ToString();\\n                string table = isMeasure ? newField.Measure.Expression.SourceRef.Entity : newField.Column.Expression.SourceRef.Entity;\\n                string prop = isMeasure ? newField.Measure.Property : newField.Column.Property;\\n\\n                string oldPattern = oldFieldKey;\\n                string newPattern = $\\\"'{table}'[{prop}]\\\";\\n\\n                if (filterConfigString.Contains(oldPattern))\\n                {\\n                    Content.FilterConfig = filterConfigString.Replace(oldPattern, newPattern);\\n                    wasModified = true;\\n                }\\n            }\\n            if (wasModified && modifiedSet != null)\\n                modifiedSet.Add(this);\\n\\n        }\\n\\n        public void ReplaceInFilterConfigRaw(\\n            Dictionary<string, string> tableMap,\\n            Dictionary<string, string> fieldMap,\\n            HashSet<VisualExtended> modifiedVisuals = null)\\n        {\\n            if (Content.FilterConfig == null) return;\\n\\n            string originalJson = JsonConvert.SerializeObject(Content.FilterConfig);\\n            string updatedJson = originalJson;\\n\\n            foreach (var kv in tableMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            foreach (var kv in fieldMap)\\n                updatedJson = updatedJson.Replace($\\\"\\\\\"{kv.Key}\\\\\"\\\", $\\\"\\\\\"{kv.Value}\\\\\"\\\");\\n\\n            // Only update and track if something actually changed\\n            if (updatedJson != originalJson)\\n            {\\n                Content.FilterConfig = JsonConvert.DeserializeObject(updatedJson);\\n                modifiedVisuals?.Add(this);\\n            }\\n        }\\n\\n    }\\n\\n\\n\\n    public class PageExtended\\n    {\\n        public PageDto Page { get; set; }\\n        public IList<VisualExtended> Visuals { get; set; } = new List<VisualExtended>();\\n        public string PageFilePath { get; set; }\\n    }\\n\\n\\n    public class ReportExtended\\n    {\\n        public IList<PageExtended> Pages { get; set; } = new List<PageExtended>();\\n        public string PagesFilePath { get; set; }\\n        public PagesDto PagesConfig { get; set; }\\n    }\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Advanced\\TopN_PlusOthers",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.AnalysisServices.Core.dll\\\"\\n#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n\\n/*\\n * Title: TopN + Others from SQL BI\\n * \\n * Author: George\\n * \\n * This script was inspired by the article from SQLBI https://sql.bi/695263\\n * Code example for checking connection to Power BI Desktop was provided by Daniel Otykier\\n * \\n * For more detail see the this link: https://github.com/TabularEditor/TabularEditor/issues/1010\\n *\\n * Requirements: Create What-If Parameter before running this code!\\n */\\n \\n\\nvar ListOfTableAnnotations = new List<string>();\\nstring RexExpPattern = \\\"TopNScript_(.+?)_ShiyanovG\\\";\\nforeach (Table t in Model.Tables)\\n{\\n    foreach (var a in t.GetAnnotations())\\n    {\\n        // a.Output();\\n        bool IsMatched =\\n        a.IndexOf(\\\"TopNScript_\\\", StringComparison.OrdinalIgnoreCase) >= 0\\n        && a.IndexOf(\\\"_ShiyanovG\\\", StringComparison.OrdinalIgnoreCase) >= 0\\n        ;\\n        if (IsMatched)\\n        {\\n            ListOfTableAnnotations.Add(a);\\n        }\\n    }\\n}\\n\\nbool HasScriptAnnotations = ListOfTableAnnotations.Count() > 0;\\n\\nif (HasScriptAnnotations == true)\\n{\\n    Info(\\\"TopN Script already implemented\\\");\\n    return;\\n}\\n\\n\\nvar server = Model.Database.TOMDatabase.Server as Microsoft.AnalysisServices.Tabular.Server;\\nvar isLoadedFromFile = server == null;\\nvar isPbiDesktop = server != null \\n    && server.ServerLocation == Microsoft.AnalysisServices.ServerLocation.OnPremise\\n    && server.CompatibilityMode == Microsoft.AnalysisServices.CompatibilityMode.PowerBI;\\n\\nif (isLoadedFromFile)\\n{\\n    Info(\\\"Metadata loaded from file\\\");\\n}\\nelse if (isPbiDesktop)\\n{\\n    // Info(\\\"Connected to PBI Desktop\\\");\\n    //Info(\\\"Select TopN What-If Parameter\\\");\\n\\n\\n\\n    string ConfigInpuBoxText =\\n        \\\"1 - Measures\\\"\\n        + \\\"\\n\\\"\\n        + \\\"2 - Calculation Group\\\"\\n        ;\\n    int ConfigDefaultInput = 1;\\n    var ConfigAnswer = Interaction.InputBox(\\n            ConfigInpuBoxText,\\n            \\\"Choose configuration of execution\\\",\\n            ConfigDefaultInput.ToString(),\\n            740,\\n            400);\\n\\n    bool RunCode = \\n                ConfigAnswer == '1'.ToString()\\n                || ConfigAnswer == '2'.ToString();\\n    string ConfigErrorMessage =  @\\\"Please choose correct configuration!\\\";\\n    if (RunCode == false)\\n    {\\n        // Force an Error if configuration is wrong\\n        Error(ConfigErrorMessage);\\n        // Do nothing\\n        return;\\n    }\\n\\n    Table StartTableTopN = Model.SelectTable(null, \\\"Select TopN What-If Parameter\\\");\\n    bool CheckForTopN = StartTableTopN == null;\\n    if (CheckForTopN)\\n    {\\n        Error(\\\"No TopN What-If\\\");\\n        return;\\n    }\\n    else\\n    {\\n        Info(\\\"OK\\\");\\n\\n        var ListOfFactTables = new List<Table>();\\n        var ListOfDimentionTables = new List<Table>();\\n\\n        foreach (var r in Model.Relationships)\\n        {\\n            Table ManyColTable = r.FromColumn.Table;\\n            // Table ManyColTable = r.FromColumn.Table;\\n            bool notInListFact = ListOfFactTables.Contains(ManyColTable);\\n            if (notInListFact == false)\\n            {\\n                ListOfFactTables.Add(ManyColTable);\\n            }\\n        }\\n\\n        foreach (var r in Model.Relationships)\\n        {\\n            Table OneColTable = r.ToColumn.Table;\\n            bool NotDate = r.ToColumn.DataType == DataType.DateTime;\\n            bool notInListDim = ListOfDimentionTables.Contains(OneColTable);\\n            if (notInListDim == false && NotDate == false)\\n            {\\n                ListOfDimentionTables.Add(OneColTable);\\n            }\\n        }\\n\\n        // Set Annotation for object StartTable\\n        StartTableTopN.SetAnnotation(\\n            \\\"TopNScript_StartTableTopN_ShiyanovG\\\"\\n            , \\\"TopNScript_StartTableTopN_ShiyanovG\\\"\\n            );\\n        Measure MeasureTopN = StartTableTopN.SelectMeasure(null, \\\"Select TopN measure\\\");\\n        var MeasureTopNReference = MeasureTopN.DaxObjectName;\\n        Table StartTable = ListOfDimentionTables.SelectTable(null, \\\"Select the table to implement TopN + Others for\\\");\\n        string StartTableName = StartTable.DaxObjectFullName;\\n        // Set Annotation for object StartTable\\n        StartTable.SetAnnotation(\\n            \\\"TopNScript_StartTable_ShiyanovG\\\"\\n            , \\\"TopNScript_StartTable_ShiyanovG\\\"\\n            );\\n\\n        Column StartColumn =\\n        StartTable.Columns\\n        .Where(c => c.UsedInRelationships.Any() == false)\\n        .SelectColumn(null, \\\"Select the column to use for TopN + Others\\\");\\n\\n\\n        Table FactTable = ListOfFactTables.SelectTable(null, \\\"Where is your main Fact Table\\\");\\n        Measure RankingMeasureReference = FactTable.SelectMeasure(null, \\\"What is you base measure for the pattern\\\");\\n        string RankingMeasureReferenceName = RankingMeasureReference.DaxObjectFullName;\\n\\n        string TopNTableExpression =\\n        \\\"UNION( \\\"\\n        + \\\"ALLNOBLANKROW( \\\" + StartColumn.DaxObjectFullName + \\\"),\\\"\\n        + \\\"\\n\\\"\\n        + \\\"{ \\\\\"Others\\\\\" }\\\"\\n        + \\\"\\n )\\\";\\n\\n        string TopNTableName = StartTable.Name + \\\" Names\\\";\\n        string FullPowerBITableExpression =\\n        TopNTableName + \\\" = \\\"\\n        + \\\"\\n\\\"\\n        + TopNTableExpression;\\n\\n        Info(\\\"Copy to Clipboard the following code and create new Calucated Table\\\");\\n        FullPowerBITableExpression.Output();\\n\\n        Table ReferenceTable = Model.Tables[TopNTableName];\\n        ReferenceTable.SetAnnotation(\\n            \\\"TopNScript_ReferenceTable_ShiyanovG\\\"\\n            , \\\"TopNScript_ReferenceTable_ShiyanovG\\\"\\n            );\\n\\n        string ReferenceTableName = ReferenceTable.DaxObjectFullName;\\n        string ReferenceColumnName = ReferenceTable.Columns.First().DaxObjectFullName;\\n        string RankingMeasureName = \\\"Ranking\\\";\\n        string Others = \\\" \\\\\"Others\\\\\" \\\";\\n        string RankingMeasureDax =\\n          @\\\"\\nIF (\\n    ISINSCOPE ( {1} ),\\n    VAR ProductsToRank = [TopN Value] \\n    VAR SalesAmount = {3} \\n    VAR IsOtherSelected =\\n        SELECTEDVALUE ( {1} ) = {0}  \\n    RETURN\\n        IF(\\n            IsOtherSelected,\\n            -- Rank for Others\\n            ProductsToRank + 1,\\n            -- Rank for regular products\\n            IF (\\n                SalesAmount > 0,\\n                VAR VisibleProducts =\\n                    CALCULATETABLE(VALUES({1}), ALLSELECTED({2}))\\n                VAR Ranking =\\n                    RANKX(VisibleProducts, {3}, SalesAmount)\\n                RETURN\\n                    IF (Ranking > 0 && Ranking <= ProductsToRank, Ranking )\\n            )\\n        ) \\n ) \\n \\\";\\n        string RankingMeasureDaxFormatted = string.Format(\\n         RankingMeasureDax, Others, ReferenceColumnName,\\n         ReferenceTableName, RankingMeasureReferenceName\\n         );\\n        string VisibleRowMeasureDax =\\n           @\\\"\\nVAR Ranking = [Ranking] \\nVAR TopNValue = [TopN Value]\\nVAR Result =  \\n    IF( \\n        NOT ISBLANK(Ranking), \\n        (Ranking <= TopNValue) - (Ranking = TopNValue + 1) \\n    ) \\nRETURN  Result \\\";\\n\\n       // Generate code for desired measure (for example Sales Amount)\\n        string AddColsColumn = \\\"@SalesAmount\\\";\\n        string q = \\\"\\\\\"\\\";\\n        string AmountNAMeasureDax = @\\\"\\n VAR SalesOfAll =\\n CALCULATE ( {6}, REMOVEFILTERS ( {5} ) )\\nRETURN\\n    IF (\\n        NOT ISINSCOPE ( {3} ),\\n        -- Calculation for a group of products \\n        SalesOfAll,\\n        -- Calculation for one product name\\n        VAR ProductsToRank = [TopN Value]\\n        VAR SalesOfCurrentProduct = {6}\\n        VAR IsOtherSelected =\\n            SELECTEDVALUE ( {3} ) = {0}\\n        RETURN\\n            IF(\\n                NOT IsOtherSelected,\\n                -- Calculation for a regular product\\n                SalesOfCurrentProduct,\\n                -- Calculation for Others\\n                VAR VisibleProducts =\\n                    CALCULATETABLE(\\n                        VALUES({4}),\\n                        REMOVEFILTERS({3})\\n                    )\\n                VAR ProductsWithSales =\\n                    ADDCOLUMNS(VisibleProducts, {1}{2}{1} , [Sales Amount])\\n                VAR FilterTopProducts =\\n                TOPN(ProductsToRank, ProductsWithSales, [{2}])\\n                VAR FilterOthers =\\n                    EXCEPT(ProductsWithSales, FilterTopProducts)\\n                VAR SalesOthers =\\n                    CALCULATE(\\n                        {6},\\n                        FilterOthers,\\n                        REMOVEFILTERS ( {3} )\\n                    )\\n                RETURN\\n                    SalesOthers\\n            )\\n            )\\\"\\n                    ;\\n        string AmountNAMeasureDaxFormatted =\\n            string.Format(\\n                AmountNAMeasureDax\\n                , Others  // 0\\n                , q // 1\\n                , AddColsColumn // 2\\n                , ReferenceColumnName // 3\\n                , StartTableName // 4\\n                , ReferenceTableName // 5\\n                , RankingMeasureReferenceName // 6\\n                );\\n        string AmountNAMeasureName = RankingMeasureReference.Name + \\\" NA\\\";\\n\\n        if (ConfigAnswer == \\\"1\\\")\\n        {\\n            // Add Ranking measure to the table with Formatted code\\n            ReferenceTable.AddMeasure(RankingMeasureName, RankingMeasureDaxFormatted, null);\\n            // Add Visible Row measure to the table \\n            ReferenceTable.AddMeasure(\\\"Visible Row\\\", VisibleRowMeasureDax, null);\\n            // Add AmountNA measure to the table \\n            ReferenceTable.AddMeasure(\\n                AmountNAMeasureName\\n                , AmountNAMeasureDaxFormatted\\n                , null\\n                );\\n            // Format all created measures\\n            ReferenceTable.Measures.FormatDax();\\n        }\\n        else if (ConfigAnswer==\\\"2\\\")\\n        {\\n            string Config2Text = @\\\"\\n            Corrently code doesn't support Calc Group implementation.\\n            Press OK to create measures.\\\";\\n            Info(Config2Text);\\n\\n            // Add Ranking measure to the table with Formatted code\\n            ReferenceTable.AddMeasure(RankingMeasureName, RankingMeasureDaxFormatted, null);\\n            // Add Visible Row measure to the table \\n            ReferenceTable.AddMeasure(\\\"Visible Row\\\", VisibleRowMeasureDax, null);\\n            // Add AmountNA measure to the table \\n            ReferenceTable.AddMeasure(\\n                AmountNAMeasureName\\n                , AmountNAMeasureDaxFormatted\\n                , null\\n                );\\n            // Format all created measures\\n            ReferenceTable.Measures.FormatDax();\\n        }\\n    }\\n\\n}\\nelse\\n{\\n    Info(\\\"Not connected to PBI Desktop\\\");\\n}\\n\\n\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Add Prefix to Selected Measure Names",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Add Prefix to Selected Measures\\n *\\n * Author: Mike Carlo, https://PowerBI.tips\\n *\\n * This script loops through all the selected measures and adds a Prefix String to the name.\\n * Only Selected measures will be modified.\\n *\\n */\\n\\n/* Cycle over all Selected measures in model */\\nforeach (var m in Selected.Measures)\\n    {\\n        /* Grab the current name as a variable, prepend some text */\\n        m.Name = \\\"Test \\\" + m.Name;\\n    }",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Add or Update DAX Epression to Description",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Update/Replace the DAX Expression in a Measure's Description\\n *\\n * Author: Dan Meissner\\n *\\n * This script, when executed, will loop through all the measures in the model and\\n * Either (1) add the DAX expression into the field's description for documentation purposes if it is missing\\n * or (2) remove the existing description DAX expression and updated it with the current DAX expression.\\n *\\n * This script assumes the DAX expression is the last text in the description and is preceded with a single line of text \\\"Expression:\\\"\\n */\\n\\nforeach (var m in Selected.Measures)\\n{\\n    int index = m.Description.IndexOf(\\\"Expression:\\\");\\n    if (index >= 0)\\n    {\\n        m.Description = m.Description.Substring(0, index+11) + System.Environment.NewLine + m.Expression;\\n    }\\n    else\\n    {\\n        m.Description = m.Description + System.Environment.NewLine + System.Environment.NewLine + \\\"Expression:\\\" + System.Environment.NewLine + m.Expression;\\n    };\\n}; ",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Autogenerate DISTINCTCOUNT Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Auto-generate DISTINCTCOUNT measures from columns\\n * \\n * B.Agullo adapting code from Daniel Otykier\\n * \\n * This script, when executed, will loop through the currently selected columns,\\n * creating one DISTINCTCOUNT measure for each column\\n */\\n \\n// Loop through all currently selected columns:\\nforeach(var c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"Distinct Count of \\\" + c.Name,                    // Name\\n        \\\"DISTINCTCOUNT(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"0\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the distinct count of column \\\" + c.DaxObjectFullName;\\n\\n    // Hide the base column:\\n    //c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Autogenerate MAX Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Auto-generate MAX measures from columns\\n * \\n * Author: B.Agullo (Adapted from Daniel Otykier, twitter.com/DOtykier)\\n * \\n * This script, when executed, will loop through the currently selected columns,\\n * creating one MAX measure for each column and also hiding the column itself.\\n */\\n \\n// Loop through all currently selected columns:\\nforeach(Column c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"Max  \\\" + c.Name,                    // Name\\n        \\\"MAX(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = c.FormatString;\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the MAX of column \\\" + c.DaxObjectFullName;\\n\\n    // Hide the base column:\\n    //c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Autogenerate MIN Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Auto-generate MIN measures from columns\\n * \\n * Author: B.Agullo (Adapted from Daniel Otykier, twitter.com/DOtykier)\\n * \\n * This script, when executed, will loop through the currently selected columns,\\n * creating one MIN measure for each column and also hiding the column itself.\\n */\\n \\n// Loop through all currently selected columns:\\nforeach(Column c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"MIN  \\\" + c.Name,                    // Name\\n        \\\"MIN(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = c.FormatString;\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the MIN of column \\\" + c.DaxObjectFullName;\\n\\n    // Hide the base column:\\n    //c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Autogenerate ROWS measures",
      "Enabled": "true",
      "Execute": "//'2022-07-10 / B.Agullo /  \\n// creates \\\"Rows of ... \\\" measures to return the numer of visible rows in each selected table\\n// adapted from Daniel Otykier's code \\n\\n// Loop through all currently selected columns:\\nforeach(Table t in Selected.Tables)\\n{\\n    Measure newMeasure = t.AddMeasure(\\n        \\\"Rows of \\\" + t.Name,                    // Name\\n        \\\"COUNTROWS(\\\" + t.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        \\\"Other Measures\\\"          // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"#,##0\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is number of rows of \\\" + t.Name;\\n\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Autogenerate SELECTEDVALUE Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Auto-generate SELECTEDVALUE measures from columns\\n * \\n * Author: B.Agullo (Adapted from Daniel Otykier, twitter.com/DOtykier)\\n * \\n * This script, when executed, will loop through the currently selected columns,\\n * creating one SELECTEDVALUE measure for each column and also hiding the column itself.\\n */\\n \\n// Loop through all currently selected columns:\\nforeach(var c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"Selected  \\\" + c.Name,                    // Name\\n        \\\"SELECTEDVALUE(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"0.00\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the SELECTEDVALUE of column \\\" + c.DaxObjectFullName;\\n\\n    // Hide the base column:\\n    //c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Autogenerate SUM Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Auto-generate SUM measures from columns\\n * \\n * Author: Daniel Otykier, twitter.com/DOtykier\\n * \\n * This script, when executed, will loop through the currently selected columns,\\n * creating one SUM measure for each column and also hiding the column itself.\\n */\\n \\n// Loop through all currently selected columns:\\nforeach(var c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"Sum of \\\" + c.Name,                    // Name\\n        \\\"SUM(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"0.00\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the sum of column \\\" + c.DaxObjectFullName;\\n\\n    // Hide the base column:\\n    c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Change String in Selected Measures Names",
      "Enabled": "true",
      "Execute": "//\\n//  Title: Replace Text Strings in name of the selected measures \\n//  \\n//  Author: Artur Nawrocki\\n//  \\n//  This script, when executed, will loop through the currently selected measures\\n//  and replace the FromString with the ToString.\\n// \\n\\n// Replace Text Strings that appear in name of selected measures\\n\\n// String of text that is desired to be found\\n// Update the value of the text for your desired usecase\\n// This replacement example shows the replacement of a DAX expression and replaces the Target with a text of Forecast\\n\\nvar FromString = \\\"Target\\\";\\n\\n// String of text that is the replaced value\\n// Update the value of the text for your desired usecase\\nvar ToString = \\\"Forecast\\\";\\n\\nforeach (var m in Selected.Measures)\\n    {\\n        m.Name = m.Name.Replace(FromString,ToString);\\n    }\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Configure Table as Field Parameter",
      "Enabled": "true",
      "Execute": "//'2024-08-09 / B.Agullo /\\n// Configure a field parameter table\\nif(Selected.Tables.Count() != 1)\\n{\\n    Error(\\\"Select a single table and try again\\\");\\n    return;\\n}\\nTable fieldParameterTable = Selected.Table;\\nif (fieldParameterTable.Columns.Count() < 3)\\n{\\n    Error(\\\"This script expects at least 3 columns in the table\\\");\\n    return;\\n}\\nColumn displayNameColumn = SelectColumn(fieldParameterTable, fieldParameterTable.Columns[0], \\\"Select display name column\\\");           \\nif(displayNameColumn == null) { Error(\\\"You cancelled\\\");return; }; \\nColumn fieldColumn = SelectColumn(fieldParameterTable, fieldParameterTable.Columns[1], \\\"Select field table\\\");\\nif(fieldColumn == null) { Error(\\\"You cancelled\\\"); return; };\\nColumn orderColumn = SelectColumn(fieldParameterTable, fieldParameterTable.Columns[2], \\\"Select order column\\\");\\nif(orderColumn == null) { Error(\\\"You cancelled\\\"); return; };\\nfieldColumn.SetExtendedProperty(name: \\\"ParameterMetadata\\\", value: @\\\"{\\\"\\\"version\\\"\\\":3,\\\"\\\"kind\\\"\\\":2}\\\", type: ExtendedPropertyType.Json);\\ndisplayNameColumn.GroupByColumns.Add(fieldColumn);\\ndisplayNameColumn.SortByColumn = orderColumn;\\nfieldColumn.SortByColumn = orderColumn;\\nfieldColumn.IsHidden = true;\\norderColumn.IsHidden = true; \\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Build direct or indirect dependency tree of selected or all measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Build direct or indirect dependency tree of selected or all measures\\n * Author: Daniel Otykier, twitter.com/DOtykier\\n * Co-Author: nexus150, https://github.com/nexus150\\n * \\n * This script, when executed, will loop through the currently selected measures (or all measures),\\n * exporting all measures that depends on it, both direct or indirect way.\\n *\\n * This script was created in response to:\\n * https://github.com/TabularEditor/TabularEditor/issues/897\\n *\\n */\\n\\nstring tsv = \\\"Measure\\tDependsOnMeasure\\\"; // TSV file header row\\n\\n// Loop through all measures: (Change to Model.AllMeasures to Selected.Measures if only want Loop through selected measures)\\nforeach(var m in Model.AllMeasures /**/) {\\n\\n    // Get a list of all measures referenced directly by the current measure:\\n    var allReferences = m.DependsOn.Measures;\\n\\n    // Get a list of ALL measures referenced by this measure (both directly and indirectly through other measures):\\n    //var allReferences = m.DependsOn.Deep().OfType<Measure>().Distinct();\\n\\n    // Output TSV rows - one for each measure reference:\\n    foreach(var m2 in allReferences)\\n        tsv += string.Format(\\\"\\r\\n{0}\\t{1}\\\", m.Name, m2.Name);\\n}\\n\\ntsv.Output();   \\n// SaveFile(\\\"c:\\\\MyProjects\\\\SSAS\\\\MeasureDependencies.tsv\\\", tsv); // Uncomment this line to save output to a file",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Drill Through Help Text",
      "Enabled": "true",
      "Execute": "\\n/*\\n * Title: Create a Drill Through Help Text for a Button\\n *\\n * Author: Tommy Puglia, https://powerbi.tips/explicit-measures-power-bi-podcast/\\n *\\n * This script will loop through selected columns to create the text for a button to drill through\\n * \\n */\\n\\nforeach(var c in Selected.Columns)\\n{\\nvar newMeasure = c.Table.AddMeasure(\\n  \\n  // Appends a prefix to the name of the column\\n  \\\"dr_text_\\\" + c.Name ,\\n\\n  // Generate full measure\\n  \\\"IF(HASONEVALUE(\\\" + c.DaxObjectFullName  + \\\"), \\\\\"See details for \\\\\" & SELECTEDVALUE(\\\" + c.DaxObjectFullName + \\\"), \\\\\"Click a Company to See Details\\\\\" )\\\"\\n\\n  // Display Folder;\\n  newMeasure.DisplayFolder = \\\"_Sel\\\";  \\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Has Data Measure",
      "Enabled": "true",
      "Execute": "// '2023-06-08 / B.Agullo / Creates a measure to show only relevant items in slicers for a fact table.\\n\\n\\nif(Selected.Tables.Count() == 0)\\n{\\n    Error(\\\"Select at least one table and try again\\\");\\n    return;\\n}\\nforeach(Table table in Selected.Tables)\\n{\\n    string measureExpression = String.Format(@\\\"INT(NOT ISEMPTY({0}))\\\",table.DaxObjectFullName);\\n    string measureName = table.Name + \\\" has data\\\";\\n    string measureDescription = String.Format(@\\\"Returns 1 if {0} has visible rows in filter context, 0 otherwise. Can be used to show only relevant slicer items.\\\", table.DaxObjectFullName);\\n    Measure measure = table.AddMeasure(measureName, measureExpression);\\n    measure.Description = measureDescription;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Selected Measure",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Create a Selected Value for a Drill Through Page\\n *\\n * Author: Tommy Puglia, https://powerbi.tips/explicit-measures-power-bi-podcast/\\n *\\n * This script will loop through selected columns to create a text measure that shows what was selected for a Drill Through Page\\n * \\n */\\nforeach(var c in Selected.Columns)\\n{\\nvar newMeasure = c.Table.AddMeasure(\\n\\n  // Create name of measure using a prefix\\n  \\\"Sel. \\\" + c.Name,\\n\\n  // Create full measure\\n  \\\"IF(ISFILTERED(\\\" + c.DaxObjectFullName  + \\\"), SELECTEDVALUE(\\\" + c.DaxObjectFullName + \\\", \\\\\" Multiple Selected \\\\\"  ),  \\\\\"None Selected \\\\\" )\\\"\\n  );\\n  \\n  // Display Folder\\n  newMeasure.DisplayFolder = \\\"_Sel\\\";  \\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Sum Measure for Selected Cols with Folder",
      "Enabled": "true",
      "Execute": "/* Creates a SUM measure for every currently selected column(s)\\n *\\n * Author: Mike Carlo, https://powerbi.tips\\n *\\n * Select Columns using Control + Left Click\\n * Script will create one measure for each column selected\\n * Then Change the formatting of the column, adds a description,\\n * and places measures in a named folder.\\n *\\n */\\n\\n// Loop through the list of selected columns\\nforeach(var c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"Sum of \\\" + c.Name,                    // Name\\n        \\\"SUM(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"0\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the sum of column \\\" + c.DaxObjectFullName;\\n\\n    // Create all measures within a Named Folder\\n    newMeasure.DisplayFolder = \\\"_Model\\\";\\n\\n    // Hide the base column:\\n    c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Sum Measures for All Selected Columns",
      "Enabled": "true",
      "Execute": "// Creates a SUM measure for every currently selected column and hide the column.\\nforeach(var c in Selected.Columns)\\n{\\n    var newMeasure = c.Table.AddMeasure(\\n        \\\"Sum of \\\" + c.Name,                    // Name\\n        \\\"SUM(\\\" + c.DaxObjectFullName + \\\")\\\",    // DAX expression\\n        c.DisplayFolder                        // Display Folder\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"0.00\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the sum of column \\\" + c.DaxObjectFullName;\\n\\n    // Hide the base column:\\n    c.IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create Text Versions of Numeric Measures with prefix and sufix",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing System.Windows.Forms;\\n\\nusing Microsoft.VisualBasic;\\n\\n//2025-07-28/B.Agullo\\n//This script creates text measures based on the selected measures in the model.\\n//It prompts the user for a prefix and suffix to be added to the text measures.\\n//It also allows the user to specify a suffix for the names of the new text measures.\\nif (Selected.Measures.Count() == 0)\\n{\\n    Error(\\\"No measures selected. Please select at least one measure.\\\");\\n    return;\\n}\\n// Ask user for prefix\\nstring prefix = Fx.GetNameFromUser(\\n    Prompt: \\\"Enter a prefix for the new text measures (use ### for current measure name):\\\",\\n    Title: \\\"Text Measure Prefix\\\",\\n    DefaultResponse: \\\"\\\"\\n);\\nif (prefix == null) return;\\n// Ask user for suffix\\nstring suffix = Fx.GetNameFromUser(\\n    Prompt: \\\"Enter a suffix for the new text measures (use ### for current measure name):\\\",\\n    Title: \\\"Text Measure Suffix\\\",\\n    DefaultResponse: \\\"\\\"\\n);\\nif (suffix == null) return;\\n// Ask user for measure name suffix\\nstring measureNameSuffix = Fx.GetNameFromUser(\\n    Prompt: \\\"Enter a suffix for the Name of the new text measures:\\\",\\n    Title: \\\"Suffix for names!\\\",\\n    DefaultResponse: \\\" Text\\\"\\n);\\nif (measureNameSuffix == null) return;\\nforeach (Measure m in Selected.Measures)\\n{\\n    string newMeasureName = m.Name + measureNameSuffix;\\n    string newMeasureDisplayFolder = (m.DisplayFolder + measureNameSuffix).Trim();\\n    string newMeasureExpression = \\n        String.Format(\\n            @\\\"\\\"\\\"{2}\\\"\\\" & FORMAT([{0}], \\\"\\\"{1}\\\"\\\") & \\\"\\\"{3}\\\"\\\"\\\", \\n            m.Name, \\n            m.FormatString, \\n            prefix.Replace(\\\"###\\\", m.Name), \\n            suffix.Replace(\\\"###\\\",m.Name));\\n    Measure newMeasure = m.Table.AddMeasure(newMeasureName, newMeasureExpression,newMeasureDisplayFolder);\\n    newMeasure.FormatDax();\\n}\\n\\npublic static class Fx\\n{\\n    public static Table CreateCalcTable(Model model, string tableName, string tableExpression)\\n    {\\n        return model.Tables.FirstOrDefault(t =>\\n                            string.Equals(t.Name, tableName, StringComparison.OrdinalIgnoreCase)) //case insensitive search\\n                            ?? model.AddCalculatedTable(tableName, tableExpression);\\n    }\\n    public static string GetNameFromUser(string Prompt, string Title, string DefaultResponse)\\n    {\\n        string response = Interaction.InputBox(Prompt, Title, DefaultResponse, 740, 400);\\n        return response;\\n    }\\n    public static string ChooseString(IList<string> OptionList, string label = \\\"Choose item\\\", int customWidth = 400, int customHeight = 500)\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect: false, label: label, customWidth: customWidth, customHeight:customHeight) as string;\\n    }\\n    public static List<string> ChooseStringMultiple(IList<string> OptionList, string label = \\\"Choose item(s)\\\", int customWidth = 400, int customHeight = 500)\\n    {\\n        return ChooseStringInternal(OptionList, MultiSelect:true, label:label, customWidth: customWidth, customHeight: customHeight) as List<string>;\\n    }\\n    private static object ChooseStringInternal(IList<string> OptionList, bool MultiSelect, string label = \\\"Choose item(s)\\\", int customWidth = 400, int customHeight = 500)\\n    {\\n        Form form = new Form\\n        {\\n            Text =label,\\n            Width = customWidth,\\n            Height = customHeight,\\n            StartPosition = FormStartPosition.CenterScreen,\\n            Padding = new Padding(20)\\n        };\\n        ListBox listbox = new ListBox\\n        {\\n            Dock = DockStyle.Fill,\\n            SelectionMode = MultiSelect ? SelectionMode.MultiExtended : SelectionMode.One\\n        };\\n        listbox.Items.AddRange(OptionList.ToArray());\\n        if (!MultiSelect && OptionList.Count > 0)\\n            listbox.SelectedItem = OptionList[0];\\n        FlowLayoutPanel buttonPanel = new FlowLayoutPanel\\n        {\\n            Dock = DockStyle.Bottom,\\n            Height = 40,\\n            FlowDirection = FlowDirection.LeftToRight,\\n            Padding = new Padding(10)\\n        };\\n        Button selectAllButton = new Button { Text = \\\"Select All\\\", Visible = MultiSelect };\\n        Button selectNoneButton = new Button { Text = \\\"Select None\\\", Visible = MultiSelect };\\n        Button okButton = new Button { Text = \\\"OK\\\", DialogResult = DialogResult.OK };\\n        Button cancelButton = new Button { Text = \\\"Cancel\\\", DialogResult = DialogResult.Cancel };\\n        selectAllButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, true);\\n        };\\n        selectNoneButton.Click += delegate\\n        {\\n            for (int i = 0; i < listbox.Items.Count; i++)\\n                listbox.SetSelected(i, false);\\n        };\\n        buttonPanel.Controls.Add(selectAllButton);\\n        buttonPanel.Controls.Add(selectNoneButton);\\n        buttonPanel.Controls.Add(okButton);\\n        buttonPanel.Controls.Add(cancelButton);\\n        form.Controls.Add(listbox);\\n        form.Controls.Add(buttonPanel);\\n        DialogResult result = form.ShowDialog();\\n        if (result == DialogResult.Cancel)\\n        {\\n            Info(\\\"You Cancelled!\\\");\\n            return null;\\n        }\\n        if (MultiSelect)\\n        {\\n            List<string> selectedItems = new List<string>();\\n            foreach (object item in listbox.SelectedItems)\\n                selectedItems.Add(item.ToString());\\n            return selectedItems;\\n        }\\n        else\\n        {\\n            return listbox.SelectedItem != null ? listbox.SelectedItem.ToString() : null;\\n        }\\n    }\\n    public static IEnumerable<Table> GetDateTables(Model model)\\n    {\\n        var dateTables = model.Tables\\n            .Where(t => t.DataCategory == \\\"Time\\\" &&\\n                   t.Columns.Any(c => c.IsKey && c.DataType == DataType.DateTime))\\n            .ToList();\\n        if (!dateTables.Any())\\n        {\\n            Error(\\\"No date table detected in the model. Please mark your date table(s) as date table\\\");\\n            return null;\\n        }\\n        return dateTables;\\n    }\\n    public static Table GetTablesWithAnnotation(IEnumerable<Table> tables, string annotationLabel, string annotationValue)\\n    {\\n        Func<Table, bool> lambda = t => t.GetAnnotation(annotationLabel) == annotationValue;\\n        IEnumerable<Table> matchTables = GetFilteredTables(tables, lambda);\\n        return GetFilteredTables(tables, lambda).FirstOrDefault();\\n    }\\n    public static IEnumerable<Table> GetFilteredTables(IEnumerable<Table> tables, Func<Table, bool> lambda)\\n    {\\n        var filteredTables = tables.Where(t => lambda(t));\\n        return filteredTables.Any() ? filteredTables : null;\\n    }\\n    public static IEnumerable<Column> GetFilteredColumns(IEnumerable<Column> columns, Func<Column, bool> lambda, bool returnAllIfNoneFound = true)\\n    {\\n        var filteredColumns = columns.Where(c => lambda(c));\\n        return filteredColumns.Any() || returnAllIfNoneFound ? filteredColumns : null;\\n    }\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Create countrows measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Auto-generate COUNTROWS measures from tables\\n * \\n * Author: Edgar Walther, twitter.com/edgarwalther\\n * \\n * This script, when executed, will loop through the currently selected tables,\\n * creating one COUNTROWS measure for each table.\\n */\\n \\n // Loop through all currently selected tables:\\nforeach(var table in Selected.Tables) {\\n    \\n    var newMeasure = table.AddMeasure(\\n    \\\"# Rows in \\\" + table.Name,                         // Name\\n    \\\"COUNTROWS(\\\" + table.DaxObjectFullName + \\\")\\\"       // DAX expression\\n    );\\n    \\n    // Set the format string on the new measure:\\n    newMeasure.FormatString = \\\"0\\\";\\n\\n    // Provide some documentation:\\n    newMeasure.Description = \\\"This measure is the number of rows in table \\\" + table.DaxObjectFullName;\\n    \\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\DAX Comment to Measure Description",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Copy DAX Comment into the measure's description field.\\n * \\n * Author: Dan Meissner, twitter.com/danmeissner \\n * \\n * This script, when executed, will loop through all the measures in the model and\\n * look for the first comment (aka. green text :) ) as designated by \\\"//\\\". It will copy the entire comment\\n * until the next line break and put that into the measure's description.\\n * \\n * If no comment of this type exists within the DAX Expression, then it copies the entire \\n * DAX expression into the measure's description.\\n * \\n * At this point it only works on the first comment and for comments using slashes \\\"//\\\" but \\n * hope someone (or myself) can improve it to collect all comments with slashes \\n * or slash star formats.\\n */\\n\\nforeach(var m in Model.AllMeasures) {\\n  // Find the first comment using the two forward slashes\\n      string DAXCode = m.Expression;\\n      string separator1 = \\\"//\\\";\\n      string result1 = \\\"\\\";\\n\\n      // Part A: get index of separator.\\n      int separatorIndex1 = DAXCode.IndexOf(separator1);\\n\\n      // Part B: if separator exists, get substring.\\n      if (separatorIndex1 >= 0) {\\n        result1 = DAXCode.Substring(separatorIndex1 + separator1.Length);\\n      }\\n  // Repeat to find the first line break after the first comment.\\n      string separator2 = \\\"\\n\\\";\\n      string result2 = \\\"\\\";\\n\\n      // Part A: get index of separator.\\n      int separatorIndex2 = result1.IndexOf(separator2);\\n\\n      // Part B: if separator exists, get substring.\\n      if (separatorIndex2 >= 0) {\\n        result2 = result1.Substring(0,separatorIndex2);\\n      }\\n  // If there is a comment, then add it to the description, \\n  // otherwise add the entire expression\\n  if (m.Expression.Contains(\\\"//\\\")) {\\n    m.Description = result2;\\n  } else {\\n    m.Description = m.Expression;\\n  };\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\DAX Expression to Description",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Copy DAX Expression into the measure's description field.\\n * \\n * Author: Reid Havens, https://www.havensconsulting.net/ \\n * \\n * This script, when executed, will loop through all the measures in the model and\\n * copy the DAX epression into the field's description for documentation purposes.\\n */\\n\\nforeach (var m in Model.AllMeasures) {\\n  m.Description = m.Expression;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Default Measure Description",
      "Enabled": "true",
      "Execute": "//Name: Default Measure Description\\n//Tooltip: Adds expression to the description\\n//Enable: Model\\n//Created by Mihaly Kavasi (updated by Ed Hansberry's idea)\\n//Tabular Editor version 2.16.0\\n\\n//It is better to format DAX before adding it into the descriptions\\nforeach(var m in Model.AllMeasures)\\n{\\n    if(m.Description == \\\"\\\")\\n    {    \\n        m.Description =  \\\"Expression:\\\" + \\\"\\n\\\" + m.Expression;\\n    }\\n    else if (!m.Description.Contains(\\\"Expression\\\"))\\n    {\\n        m.Description = m.Description + \\\"\\n\\\" + \\\"Expression:\\\" + \\\"\\n\\\" + m.Expression;\\n    }\\n    else\\n    {\\n        // '2021-07-05 / B.Agullo / reset expressions already added\\n        int pos = m.Description.IndexOf(\\\"Expression\\\",0); \\n        bool onlyExpression = (pos == 0);\\n        \\n        if (onlyExpression) {\\n            m.Description = \\\"Expression:\\\" + \\\"\\n\\\" + m.Expression;\\n        } else {\\n            m.Description = m.Description.Substring(0,pos-1)  + \\\"\\n\\\" + \\\"Expression:\\\" + \\\"\\n\\\" + m.Expression;\\n        }\\n    }\\n}\\n\\nModel.AllMeasures.FormatDax();",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Delete Relationships by Column Name",
      "Enabled": "true",
      "Execute": "// Title: Delete Relationships by Column Name.csx\\n// Author: @JamesDBartlett3\\n// Description: Deletes all relationships where the column name \\n// on at least one side of the relationship matches the declared\\n// ColumnName variable. Automatically accounts for spaces.\\n\\nvar ColumnName = \\\"\\\";\\n\\nList<Relationship> relationshipsToDelete = new List<Relationship>();\\n\\nforeach(var r in Model.Relationships) {\\n  string[] c = {\\n    r.FromColumn.Name.ToString().Replace(\\\" \\\",\\\"\\\"), \\n    r.ToColumn.Name.ToString().Replace(\\\" \\\",\\\"\\\"),\\n    r.FromColumn.Name.ToString(),\\n    r.ToColumn.Name.ToString()\\n  };\\n  if(c.Contains(ColumnName.Replace(\\\" \\\",\\\"\\\"))) {\\n    relationshipsToDelete.Add(r);\\n  }\\n}\\n\\nforeach(var r in relationshipsToDelete) {\\n  r.Delete();\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Enable Single Value Slider (convert to what-if parameter)",
      "Enabled": "true",
      "Execute": "// 2021-11-18 / B.Agullo /\\n// by Bernat Agulló\\n// twitter: @AgulloBernat\\n// www.esbrina-ba.com/blog\\n//\\n\\nSelected.Column.SetExtendedProperty(\\\"ParameterMetadata\\\", \\\"{\\\\\"version\\\\\":0}\\\", ExtendedPropertyType.Json);",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Exclude Selected Tables From Model Refresh",
      "Enabled": "true",
      "Execute": "// Title: ExcludeSelectedTablesFromModelRefresh.csx\\n// Author: @JamesDBartlett3@techhub.social\\n// Description: Exclude selected tables from model refresh\\n\\nforeach(var table in Selected.Tables) {\\n    table.ExcludeFromModelRefresh = true;\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Export All Partition Expressions",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Export All Partition Expressions\\n *\\n * Author: Dan Meissner\\n * Last Modified: 2023JAN09\\n *\\n * This script exports the partition expressions for all table partitions to the screen or a tab separated file of your choice.  \\n * The output has one row per table partition.\\n *\\n * Change the filename and filepath as necessary below.\\n *\\n * Thanks to Kurt Buhler (Data Goblins) for most of the work and the inspiration.\\n */\\n\\n/* Assign variables */\\nvar filename = \\\"TableExpressionOutput.tsv\\\";\\nvar filepath = @\\\"C:\\Sandbox\\\\\";\\nvar tsv = \\\" \\\";\\n\\n// Export Properties\\ntsv = tsv + ExportProperties(Model.AllPartitions, \\\"Expression\\\");\\n\\n// Output the results to a dialog box pop up on the screen (can copy to clipboard from the dialog box)\\ntsv.Output();\\n\\n// Output the results to a tab separated file at filepath/filename\\n//SaveFile( filepath + filename, tsv);",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Extended Properties Preview\\Preview Distinct Values of Selected Columns",
      "Enabled": "true",
      "Execute": "// Author: Tommy Puglia\\n// Website: https://pugliabi.com\\n// Check out the Explicit Measures Podcast on Apple, spotify, & YouTube! \\n// https://www.youtube.com/playlist?list=PLn1m_aBmgsbHr83c1P6uqaWF5PLdFzOjj\\n//\\n//\\n// An incredibly simple script to easily show the distinct values based on selected columns. This is a great way to peak quickly over multiple columns when you are dealing with a new data model.\\n//\\n//\\n// Pre-Req:\\n// Save this Macro with the following:\\n// Name: Preview\\Distinct Values\\n// Marco Context: Column\\n// (Hint, you can organize your macros in TE3 by grouping based on a \\\"\\\\\" separator!\\\")\\n//\\n// Instructions:\\n// 1. Select the columns you want to see the distinct values for\\n// 2. Run the script (Right Click, on the selected columns, and choose the Preview --> Distinct Values macro)\\n// 3. For every column chosen, a pop-up will appear\\n\\n\\nforeach(var c in Selected.Columns)\\n{\\nstring cName = c.Name;\\nvar cDAX = c.DaxObjectFullName;\\nstring ev = \\\"Evaluate \\n\\\";\\nstring newli = \\\"\\n\\\";\\nstring DistinctN = \\\"Distinct(\\\";\\nvar cResult = EvaluateDax(DistinctN + cDAX + \\\")\\\");\\ncResult.Output();\\n}\\n\\n\\n\\n\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Extended Properties Preview\\ep_Create Dynamic Rolling Avg Measures",
      "Enabled": "true",
      "Execute": "//\\n// Author: Tommy Puglia\\n// Website: https://pugliabi.com\\n// Check out the Explicit Measures Podcast on Apple, spotify, & YouTube!\\n// https://www.youtube.com/playlist?list=PLn1m_aBmgsbHr83c1P6uqaWF5PLdFzOjj\\n// TITLE!!\\n// Create Dynamic Rolling Days Measures based on Extended Properties\\n\\n// !!!! NOTE\\n// This script should only be run after you have set up your Global Extended Properties (see the Global Model Extended Properties Template Generator  script)\\n// !!! NOTE\\n\\n// This script will create 3 measures per selected measure in your model. The 3 measures are:\\n// 1. Rolling Days current period \\n//  This is based on your date config (extended properties) and what the default rolling days are (also extended properties)\\n\\n// 2. Rolling Days previous period\\n//  This is based on your date config (extended properties) and what the default rolling days are (also extended properties)   \\\\n\\n// 3. Rolling Days period over period\\n//  This is based on your date config (extended properties) and what the default rolling days are (also extended properties)   \\n\\n\\n// Instructions\\n// pre-requisites: ensure your model extended properties are part of the model and saved back (see top)\\n// 1. Select measures in your model\\n// 2. Run the script\\n// 3. Done!\\n\\n\\nvar dateExtended = Model.GetExtendedProperty(\\\"DateColumn\\\");\\nvar factDateColumn = Model.GetExtendedProperty(\\\"FactDateColumn\\\");\\nstring newline = Environment.NewLine;\\nvar displayfolder = \\\"__RollingDays\\\";\\nvar DefaultDays = Model.GetExtendedProperty(\\\"DefaultRollingDays\\\");\\nvar defaultDaysNumber = Int16.Parse(DefaultDays);\\n\\nforeach (var m in Selected.Measures)\\n{\\n    // Rolling Days\\n    var RollingFirst = m.Table.AddMeasure(\\n        m.Name + \\\" Rolling Days\\\",\\n        \\\"VAR DatesWOFirst =    CALCULATE(        LASTNONBLANK( \\\"\\n            + dateExtended\\n            + \\\" , \\\"\\n            + m.DaxObjectName\\n            + \\\" ), ALL( \\\"\\n            + factDateColumn\\n            + \\\"   ))\\\"\\n            + newline\\n            + \\\" VAR firstDay = ( DatesWOFirst -\\\"\\n            + defaultDaysNumber\\n            + \\\" )\\\"\\n            + newline\\n            + \\\"VAR FirstType =    DATESBETWEEN(\\\"\\n            + dateExtended\\n            + \\\" , firstDay, DatesWOFirst )\\\"\\n            + newline\\n            + \\\"VAR LastPrev =    FIRSTDATE( FirstType ) - 1 \\\"\\n            + newline\\n            + \\\" VAR FirstPrev = LastPrev - DatesWOFirst \\\"\\n            + newline\\n            + \\\"RETURN \\\"\\n            + newline\\n            + \\\" CALCULATE( \\\"\\n            + m.DaxObjectName\\n            + \\\" , DATESBETWEEN( \\\"\\n            + dateExtended\\n            + \\\", firstDay, DatesWOFirst - 1 )    ) \\\",\\n        displayfolder\\n    );\\n\\n\\n    // Previous Rolling\\n  var RollingPrevious =   m.Table.AddMeasure(\\n        m.Name + \\\" Rolling Days Prev\\\",\\n        \\\"VAR DaysRolling = \\\"\\n            + defaultDaysNumber\\n            + newline\\n            + \\\"VAR DatesWOFirst =    CALCULATE(        LASTNONBLANK( \\\"\\n            + dateExtended\\n            + \\\" , \\\"\\n            + m.DaxObjectName\\n            + \\\" ), ALL( \\\"\\n            + factDateColumn\\n            + \\\"   ) )\\\"\\n            + newline\\n            + \\\" VAR firstDay = ( DatesWOFirst - DaysRolling )\\\"\\n            + newline\\n            + \\\"VAR FirstType =    DATESBETWEEN(\\\"\\n            + dateExtended\\n            + \\\" , firstDay, DatesWOFirst )\\\"\\n            + newline\\n            + \\\"VAR LastPrev =    FIRSTDATE( FirstType ) - 1 \\\"\\n            + newline\\n            + \\\" VAR FirstPrev = LastPrev - DaysRolling \\\"\\n            + newline\\n            + \\\"RETURN \\\"\\n            + newline\\n            + \\\" CALCULATE( \\\"\\n            + m.DaxObjectName\\n            + \\\" , DATESBETWEEN( \\\"\\n            + dateExtended\\n            + \\\", FirstPrev, LastPrev - 1 )    ) \\\",\\n        displayfolder\\n    );\\n\\n    // Pop\\n  var RollingPercent =   m.Table\\n        .AddMeasure(\\n            m.Name + \\\" PoP\\\",\\n            \\\"Divide((\\\"\\n                + m.DaxObjectName\\n                + \\\" - [\\\"\\n                + m.Name\\n                + \\\" Rolling Days Prev]), + [\\\"\\n                + m.Name\\n                + \\\" Rolling Days Prev],Blank())\\\",\\n            displayfolder\\n        );\\nRollingFirst.FormatDax();\\nRollingPrevious.FormatDax();\\nRollingPercent.FormatDax();\\n\\n}\\n\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Extended Properties Preview\\ep_Model Extended Properties Generator",
      "Enabled": "true",
      "Execute": "\\n//\\n// Author: Tommy Puglia\\n// Website: https://pugliabi.com\\n// Check out the Explicit Measures Podcast on Apple, spotify, & YouTube!\\n// https://www.youtube.com/playlist?list=PLn1m_aBmgsbHr83c1P6uqaWF5PLdFzOjj\\n//\\n// Global Model Extended Properties Template Generator\\n//\\n// Tied to an example of the Group by Global Measure Script in this same repo\\n\\n// This Script is a preview of how  easy it can be to create standard Extended Properties based on a model (such as a Date Table, referencing the fact table's date column, etc.)\\n//\\n// Why?\\n// Creating Global Extended Properties with the same keys across Models would open up endless possibilities for utilizing scripts in Tabular Editor to automate tasks based on the Extended Properties.\\n//\\n// Take the example this script does. It looks at the current model if the standard Extended Properties are available, if not will prompt you to choose the columns and it auto-create the Extended Properties.\\n// Then, any other macro can simply call the key value and use it for Time Intelligence, Rolling Calcs, Calculation Groups, or any other use case.\\n// Rather than having to always select the objects per model, or worse hard-coding the value in a macro script that changes per model, having global Extended Properties would allow for a more dynamic approach.\\n\\n// Instructions\\n// Simply run the script on the model, and it will prompt you to choose the following:\\n// Date Table, Date column, and Date Year Column (exp 2022)\\n// Fact Table, and the date column in the fact table\\n// A Global Measure (for default calculations)\\n\\n// More can be added!\\n\\n#r \\\"C:\\Program Files\\Tabular Editor 3\\TabularEditor3.exe\\\" // *** Needed for C# scripting, remove in TE3 ***\\n#r \\\"C:\\Program Files (x86)\\Tabular Editor 3\\TabularEditor3.exe\\\" // *** Needed for C# scripting, remove in TE3 ***\\n#r \\\"System.IO\\\"\\n#r \\\"Microsoft.VisualBasic\\\"\\n\\nusing TabularEditor.TOMWrapper; // *** Needed for C# scripting, remove in TE3 ***\\nusing TabularEditor.Scripting; // *** Needed for C# scripting, remove in TE3 ***\\nusing System.IO;\\nusing Microsoft.VisualBasic;\\nusing Newtonsoft.Json;\\nusing Newtonsoft.Json.Linq;\\nusing System.Windows.Forms;\\n\\nModel Model; // *** Needed for C# scripting, remove in TE3 ***\\nTabularEditor.Shared.Interaction.Selection Selected; // *** Needed for C# scripting, remove in TE3 ***\\n\\n#r \\\"C:\\Program Files\\Tabular Editor 3\\TabularEditor3.exe\\\" // *** Needed for C# scripting, remove in TE3 ***\\n#r \\\"C:\\Program Files (x86)\\Tabular Editor 3\\TabularEditor3.exe\\\" // *** Needed for C# scripting, remove in TE3 ***\\n#r \\\"System.IO\\\"\\n#r \\\"Microsoft.VisualBasic\\\"\\n\\nusing TabularEditor.TOMWrapper; // *** Needed for C# scripting, remove in TE3 ***\\nusing TabularEditor.Scripting; // *** Needed for C# scripting, remove in TE3 ***\\nusing System.IO;\\nusing Microsoft.VisualBasic;\\nusing Newtonsoft.Json;\\nusing Newtonsoft.Json.Linq;\\nusing System.Windows.Forms;\\n\\n\\nFunc<IList<string>, string, string> SelectString = (IList<string> listText, string titleText) =>\\n{\\n\\n    var listboxText = new ListBox()\\n    {\\n        Dock = DockStyle.Fill\\n    };\\n\\n    var panelButtons = new Panel()\\n    {\\n        Height = 22,\\n        Dock = DockStyle.Bottom\\n    };\\n    \\n    var buttonOK = new Button()\\n    {\\n        Text = \\\"OK\\\",\\n        DialogResult = DialogResult.OK,\\n        Left = 120\\n    };\\n\\n    var buttonCancel = new Button()\\n    {\\n        Text = \\\"Cancel\\\",\\n        DialogResult = DialogResult.Cancel,\\n        Left = 204\\n    };\\n\\n    var formInputBox = new Form()\\n    {\\n        Text = titleText,\\n        Padding = new System.Windows.Forms.Padding(8),\\n        FormBorderStyle = FormBorderStyle.FixedDialog,\\n        MinimizeBox = false,\\n        MaximizeBox = false,\\n        StartPosition = FormStartPosition.CenterScreen,\\n        AcceptButton = buttonOK,\\n        CancelButton = buttonCancel\\n    };\\n    listboxText.Items.AddRange(listText.ToArray());\\n    listboxText.SelectedItem = listText[0];\\n    formInputBox.Controls.AddRange(new Control[] { listboxText, panelButtons });\\n    panelButtons.Controls.AddRange(new Control[] { buttonOK, buttonCancel });\\n    return formInputBox.ShowDialog() == DialogResult.OK ? listboxText.SelectedItem.ToString() : null;\\n\\n};\\n// Get Extended Properties & Template\\nvar mExtProp = Model.GetExtendedProperties();\\nvar TemplateExtendedProperties = new string[] {\\n    \\\"DateTable\\\",\\n    \\\"DateColumn\\\",\\n    \\\"DateYearColumn\\\",\\n    \\\"FactTable\\\",\\n    \\\"FactDateColumn\\\",\\n    \\\"GlobalMeasure\\\",\\n    \\\"DefaultRollingDays\\\"\\n};\\nvar ChooseInput = (new string[] {\\\"Yes\\\",\\\"No\\\"});\\n\\n\\n// If Copying\\nvar  stepDateTable = \\\"DateTable\\\";\\nvar stepDateColumn = \\\"DateColumn\\\";\\nvar stepDateYearColumn = \\\"DateYearColumn\\\";\\nvar stepFactTable = \\\"FactTable\\\";\\nvar stepFactDateColumn = \\\"FactDateColumn\\\";\\nvar stepGlobalMeasure = \\\"GlobalMeasure\\\";\\nvar stepDefaultDays =  \\\"DefaultRollingDays\\\";\\n\\nvar sb = new System.Text.StringBuilder();\\nvar createdb = new System.Text.StringBuilder();\\nstring newline = Environment.NewLine;\\nsb.Append(\\\"ExtenPropertyName\\\" + '\\t' + \\\"ExtenPropertyValue\\\" + '\\t' + \\\"Exisits\\\" + newline);\\ncreatedb.Append(\\\"{\\\" + newline );\\n\\n\\n// Add DateTable Extended Property\\nvar epDateTable = \\\"\\\";\\nvar epDateColumn = \\\"\\\";\\nvar epDateYearColumn = \\\"\\\";\\nvar quotes = \\\"_\\\";\\nif(Model.GetExtendedProperty(stepDateTable) == null)\\n{\\n    \\n   var DateTable = SelectTable(label: \\\"Select your Date Table\\\");\\n    var DateColumn = SelectColumn(DateTable.Columns, label: \\\"Select your Date Column\\\");\\n    var DateYearColumn = SelectColumn(DateTable.Columns, label: \\\"Select your Date Year Column\\\");\\n   string epName = DateTable.Name;\\n    Model.SetExtendedProperty(stepDateTable, epName, ExtendedPropertyType.String);\\n    Model.SetExtendedProperty(stepDateColumn, DateColumn.DaxObjectFullName, ExtendedPropertyType.String);\\n    Model.SetExtendedProperty(stepDateYearColumn, DateYearColumn.DaxObjectFullName, ExtendedPropertyType.String);\\n}\\nelse\\n{\\n    var UpdateDates = SelectString(new string[] {\\\"Yes\\\", \\\"No\\\"}, \\\"Update Date Extended Properties?\\\");\\n    if (UpdateDates == \\\"Yes\\\")\\n    {\\n        var DateTable = SelectTable(label: \\\"Select your Date Table\\\");\\n        var DateColumn = SelectColumn(DateTable.Columns, label: \\\"Select your Date Column\\\");\\n        var DateYearColumn = SelectColumn(DateTable.Columns, label: \\\"Select your Date Year Column\\\");\\n        string epName = DateTable.Name;\\n        Model.SetExtendedProperty(stepDateTable, epName, ExtendedPropertyType.String);\\n        Model.SetExtendedProperty(stepDateColumn, DateColumn.DaxObjectFullName, ExtendedPropertyType.String);\\n        Model.SetExtendedProperty(stepDateYearColumn, DateYearColumn.DaxObjectFullName, ExtendedPropertyType.String);\\n    }\\n}\\nif(Model.GetExtendedProperty(stepFactTable) == null)\\n{\\nvar FactTable = SelectTable(label: \\\"Select your fact Table\\\");\\nvar FactDateColumn = SelectColumn(FactTable.Columns, label: \\\"Select your Fact Date Column\\\");\\nModel.SetExtendedProperty(stepFactTable, FactTable.Name, ExtendedPropertyType.String);\\nModel.SetExtendedProperty(stepFactDateColumn, FactDateColumn.DaxObjectFullName, ExtendedPropertyType.String);\\n}\\nelse\\n{\\n    var UpdateFact = SelectString(new string[] {\\\"Yes\\\", \\\"No\\\"}, \\\"Update Fact Extended Properties?\\\");\\n    if (UpdateFact == \\\"Yes\\\")\\n    {\\n        var FactTable = SelectTable(label: \\\"Select your fact Table\\\");\\n        var FactDateColumn = SelectColumn(FactTable.Columns, label: \\\"Select your Fact Date Column\\\");\\n        Model.SetExtendedProperty(stepFactTable, FactTable.Name, ExtendedPropertyType.String);\\n        Model.SetExtendedProperty(stepFactDateColumn, FactDateColumn.DaxObjectFullName, ExtendedPropertyType.String);\\n    }\\n}\\nif (Model.GetExtendedProperty(stepGlobalMeasure) == null)\\n{\\nvar GlobalMeasures = SelectMeasure(label: \\\"Select your Global Measure\\\");   \\nModel.SetExtendedProperty(stepGlobalMeasure, GlobalMeasures.DaxObjectFullName, ExtendedPropertyType.String);\\n}\\nelse\\n{\\n    var UpdateGlobal = SelectString(new string[] {\\\"Yes\\\", \\\"No\\\"}, \\\"Update Global Measure?\\\");\\n    if (UpdateGlobal == \\\"Yes\\\")\\n    {\\n        var GlobalMeasures = SelectMeasure(label: \\\"Select your Global Measure\\\");   \\n        Model.SetExtendedProperty(stepGlobalMeasure, GlobalMeasures.DaxObjectFullName, ExtendedPropertyType.String);\\n    }\\n}\\nif (Model.GetExtendedProperty(stepDefaultDays) == null)\\n{\\nvar DefaultDays = Interaction.InputBox(\\\"How many Default Days for Rolling?\\\",\\\"Rolling Days\\\", \\\"Labels\\\", 740, 400);\\nModel.SetExtendedProperty(stepDefaultDays, DefaultDays, ExtendedPropertyType.String);\\n}\\nelse\\n{\\nvar DefaultDays = Interaction.InputBox(\\\"How many Default Days for Rolling?\\\",\\\"Rolling Days\\\", Model.GetExtendedProperty(stepDefaultDays), 740, 400);\\nModel.SetExtendedProperty(stepDefaultDays, DefaultDays, ExtendedPropertyType.String);\\n}\\n\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Extended Properties Preview\\ep_Peak Sel Column by Global Measure",
      "Enabled": "true",
      "Execute": "// Author: Tommy Puglia\\n// Website: https://pugliabi.com\\n// Check out the Explicit Measures Podcast on Apple, spotify, & YouTube! \\n// https://www.youtube.com/playlist?list=PLn1m_aBmgsbHr83c1P6uqaWF5PLdFzOjj\\n//\\n//\\n// A simple test that may change how we develop and share scripts and easily create tests, new measures, and sharing content.\\n\\n// An all too column problem with sharing macros is usually we need to configure some of the variables (measure name, date table name, etc). This becomes especially tedious as this has to occur per data model, rather than for a given script. This greatly reduces the ability of utilizing macros in a more productive way.\\n\\n// Enter Extended Properties. Tied to the model is the ability to create a key and value pair, which can is defined in the model properties. Further, we can use Tabular Editor 3's scripts to actually return the value of these properties. \\n\\n// This can solve and open up solutions such as:\\n\\n// - Creating a macro that when multiple columns are chosen, will default to always summarize / group by a given measure\\n// - define the Date Table / Date Column in a model for Calculated Groups or time intelligence\\n// - define the date column in the fact table once for time intelligence\\n// - set other variables that are used in multiple macros\\n\\n// This is simply a test to see what is returned. It will group a column and return a Summarize based on the \\\"Global Measure\\\" From the Extended Properties. \\n\\n// Instructions:\\n// 1. Open the model in Tabular Editor 3\\n// 2. Go to the properties of the model, and choose the Extended Properties field (under Annotations)\\n// 3. Add a new property with the the DAX Object Name of a measure in the model (such as [Total Sales])\\n// 4. Choose the Column in the object explorer, and run the script!\\n\\n\\n\\nvar s = Model.GetExtendedProperties();\\nvar tt = Model.GetExtendedProperty(0);\\nstring ev = \\\"Evaluate \\n\\\";\\nstring newli = \\\"\\n\\\";\\nstring Summa = \\\"SUMMARIZE(\\\";\\nstring TableFromColumn = Selected.Column.Table.Name;\\nstring newlinecomma = \\\", \\n \\n\\\";\\nstring ColumnChosen = Selected.Column.DaxObjectFullName;\\nstring MeasureNameSummarize = \\\", \\n \\n \\\\\"YourMeasure!\\\\\" , \\\";\\nstring MeasureFromProperty = tt;\\nstring closeit = \\\")\\\";\\nstring orby = \\\"Order By \\\" + tt + \\\" DESC\\\";\\nstring stringallTogether = newli + Summa + TableFromColumn + newlinecomma + ColumnChosen + MeasureNameSummarize \\n+ MeasureFromProperty;\\nvar result = EvaluateDax(stringallTogether + \\\")\\\" + \\\" \\n\\\" + orby);\\nresult.Output();\\n\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Format All Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Format All Measures  \\n *\\n * Author: Matt Allington, https://exceleratorbi.com.au  \\n *\\n * This script loops through all the measures in your model and calls out to daxformatter.com\\n * in order to format them.\\n *\\n * CAUTION: If your model has many measures (> 100) please use with care, as this will perform\\n * many requests against the www.daxformatter.com web service. It will take some time to run,\\n * and also, we don't want to DDoS attack daxformatter.com :-)\\n */\\n\\n//Format All Measures\\nforeach (var m in Model.AllMeasures)\\n{\\n    m.Expression = FormatDax(m.Expression);\\n    /* Cycle over all measures in model and format \\n    them all using DAX Formatter */\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Format All Power Query Tables",
      "Enabled": "true",
      "Execute": "\\n//\\n// Author: Tommy Puglia\\n// Original Author: Kurt Buhler \\n// Much Thanks goes to Kurt based on this article on a selected partition, only updated I made was all m partitions in the model.\\n\\n// Please see Kurt's original article:\\n// https://data-goblins.com/power-bi/format-power-query-automatically\\n\\n\\n// Check out the Explicit Measures Podcast on Apple, spotify, & YouTube!\\n// https://www.youtube.com/playlist?list=PLn1m_aBmgsbHr83c1P6uqaWF5PLdFzOjj\\n//\\n// Format all Power Query tables in the model\\n//\\n// Simply run this on on the model, and done!\\n\\n#r \\\"C:\\Program Files\\Tabular Editor 3\\TabularEditor3.exe\\\" // *** Needed for C# scripting, remove in TE3 ***\\n#r \\\"C:\\Program Files (x86)\\Tabular Editor 3\\TabularEditor3.exe\\\" // *** Needed for C# scripting, remove in TE3 ***\\n\\nusing TabularEditor.TOMWrapper; // *** Needed for C# scripting, remove in TE3 ***\\nusing TabularEditor.Scripting; // *** Needed for C# scripting, remove in TE3 ***\\nusing System.Net.Http;\\nusing System.Net.Http.Headers;\\nusing System.Text;\\nusing Newtonsoft.Json;\\nusing Newtonsoft.Json.Linq;\\n\\nModel Model; // *** Needed for C# scripting, remove in TE3 ***\\nTabularEditor.Shared.Interaction.Selection Selected; // *** Needed for C# scripting, remove in TE3 ***\\n\\n\\n// URL of the powerqueryformatter.com API\\nstring powerqueryformatterAPI = \\\"https://m-formatter.azurewebsites.net/api/v2\\\";\\n\\n// HttpClient method to initiate the API call POST method for the URL\\nHttpClient client = new HttpClient();\\nHttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, powerqueryformatterAPI);\\n\\nint _partitions = 0;\\nint _whatifparameters = 0;\\nint _fieldparameters = 0;\\nforeach (  var _table  in Model.Tables )\\n{\\n    foreach (  var _partition  in _table.Partitions )\\n    {\\n        string _type = Convert.ToString(_partition.SourceType);\\n        string _exp = Convert.ToString(_partition.Expression);\\n        if ( _type == \\\"M\\\" )\\n        {\\n            _partitions = _partitions + 1;\\n            string partitionExpression = _partition.Expression;\\n\\n\\n          var requestBody = JsonConvert.SerializeObject(\\n    new { \\n        code = partitionExpression,             // Mandatory config\\n        resultType = \\\"text\\\",                    // Mandatory config\\n        lineWidth = 40                          // Optional config\\n        // alignLineCommentsToPosition = true,  // Optional config\\n        // includeComments = true               // Optional config\\n    });\\n\\n// Set the \\\"Content-Type\\\" header of the request to \\\"application/json\\\" and the encoding to UTF-8\\nvar content = new StringContent(requestBody, Encoding.UTF8, \\\"application/json\\\");\\ncontent.Headers.ContentType = new MediaTypeHeaderValue(\\\"application/json\\\");\\n\\n// Retrieve the response\\nvar response = client.PostAsync(powerqueryformatterAPI, content).Result;\\n\\n// If the response is successful\\nif (response.IsSuccessStatusCode)\\n{\\n    // Get the result of the response\\n    var result = response.Content.ReadAsStringAsync().Result;\\n\\n    // Parse the response JSON object from the string\\n    JObject data = JObject.Parse(result.ToString());\\n\\n    // Get the formatted Power Query response\\n    string formattedPowerQuery = (string)data[\\\"result\\\"];\\n\\n    ////////////////////////////////////////////////////////////////////////// Can remove everything in this section\\n    // OPTIONAL MANUAL FORMATTING                                           // Additional formatting on top of API config\\n    // Manually add a new line and comment to each step                     //\\n    var replace = new Dictionary<string, string>                            //\\n    {                                                                       //\\n        { \\\"\\n//\\\", \\\"\\n\\n//\\\" },                                               // New line at comment\\n        { \\\"\\n  #\\\", \\\"\\n\\n  // Step\\n  #\\\" },                                  // New line & comment at new standard step\\n        { \\\"\\n  Source\\\", \\\"\\n\\n  // Data Source\\n  Source\\\" },                 // New line & comment at Source step\\n        { \\\"\\n  Dataflow\\\", \\\"\\n\\n  // Dataflow Connection Info\\n  Dataflow\\\" },// New line & comment at Dataflow step\\n        {\\\"\\n  Data =\\\", \\\"\\n\\n  // Step\\n  Data =\\\"},                          // New line & comment at Data step\\n        {\\\"\\n  Navigation =\\\", \\\"\\n\\n  // Step\\n  Navigation =\\\"},              // New line & comment at Navigation step\\n        {\\\"in\\n\\n  // Step\\n  #\\\", \\\"in\\n  #\\\"},                                // \\n        {\\\"\\nin\\\", \\\"\\n\\n// Result\\nin\\\"}                                       // Format final step as result\\n    };                                                                      //\\n                                                                            //\\n    // Replace the first string in the dictionary with the second           //\\n    var manuallyformattedPowerQuery = replace.Aggregate(                    //\\n        formattedPowerQuery,                                                //\\n        (before, after) => before.Replace(after.Key, after.Value));         //\\n                                                                            //\\n    // Replace the auto-formatted code with the manually formatted version  //\\n    formattedPowerQuery = manuallyformattedPowerQuery;                      //\\n    //////////////////////////////////////////////////////////////////////////\\n\\n    // Replace the unformatted M expression with the formatted expression\\n    _partition.Expression = formattedPowerQuery;\\n\\n    // Pop-up to inform of completion\\n  \\n}\\n\\n// Otherwise return an error message\\nelse\\n{\\nInfo(\\n    \\\"API call unsuccessful.\\\" +\\n    \\\"\\nCheck that you are selecting a partition with a valid M Expression.\\\"\\n    );\\n}\\n\\n\\n\\n\\n\\n        }\\n        else if ( _type == \\\"Calculated\\\" && _exp.Contains(\\\"NAMEOF\\\") )\\n        {\\n            _fieldparameters = _fieldparameters + 1;\\n        }\\n        else if ( _type == \\\"Calculated\\\" && _exp.Contains(\\\"GENERATESERIES\\\") )\\n        {\\n            _whatifparameters = _whatifparameters + 1;\\n        }\\n            \\n    }\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Format Column To Short Date",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Format All Columns to Short Date\\n *\\n * Author: Tommy Puglia, https://powerbi.tips/explicit-measures-power-bi-podcast/\\n *\\n * This script simply formats selected columns in a table to the Short Date format.\\n * \\n */\\n\\n\\nforeach(var c in Selected.Columns) {\\nc.FormatString = \\\"Short Date\\\";\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Format DAX Calculated Columns",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Formats all the calculated columns\\n * \\n * Author: Ricardo Rincón, twitter.com/nexus150 , www.bitodata.com\\n * \\n * This script, when executed, formats all the calculated columns of the model\\n * using the SQLBI.COM service https://www.daxformatter.com/.\\n * please use the version with Selected.Columns as long as you can\\n * to minimize the load on the service so that we can all enjoy it.\\n */\\n\\n// Format (Only Selected) Calculated Columns (if you don't need to format ALL calculated columns, please use this version)\\nforeach(var m in Selected.Columns)\\n{\\n    if(m.Type.ToString() == \\\"Calculated\\\"){   \\n      var y = m  as CalculatedColumn;   \\n      y.FormatDax();\\n    }\\n}   \\n\\n// Format All Calculated Columns\\n//foreach(var m in Model.AllColumns)\\n//{\\n//    if(m.Type.ToString() == \\\"Calculated\\\"){   \\n//      var y = m  as CalculatedColumn;   \\n//      y.FormatDax();\\n//    }\\n//}   ",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Generate Last Updated Table",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Generate Last Updated table\\n * \\n * Author: Irfan Charania\\n * \\n * There are times when you want to know when your model was last processed at the table level.\\n * SSAS Tabular does not provide an easy built-in way to do this.\\n * \\n * This script, when executed, will loop through all the tables in the model, and \\n * 1. create (or update) a hidden \\\"Last Processed\\\" calculated column, and\\n * 2. create (or update) a \\\"Last Updated Tabular\\\" calculated table containing data from the above calculated column\\n * \\n * Ref: https://www.sqlbi.com/articles/last-process-date-in-ssas-tabular/\\n */\\n\\n// Edit these values as desired \\nvar columnName = \\\"Last Processed\\\";\\nvar tableName = \\\"Last Updated Tabular\\\";\\nvar dateFormatString = \\\"yyyy-MMM-dd h:mm AM/PM\\\";\\n\\n// ---------------------------\\n// 1. create (or update) a hidden \\\"Last Processed\\\" calculated column\\n// ---------------------------\\n\\n// Loop through all tables in model\\nforeach(var table in Model.Tables) {\\n\\n    // for all non-calculated tables\\n    if (table.SourceType.ToString() != \\\"Calculated\\\" ){\\n\\n        CalculatedColumn column;\\n\\n        // if calculated column does not exist, create one\\n        if (!table.Columns.Contains(columnName))\\n        {\\n            column = table.AddCalculatedColumn(\\n                \\\"Last Processed\\\",  // Name\\n                \\\"NOW()\\\",           // DAX Expression\\n                \\\"_Debug\\\"           // Display Folder\\n            );\\n        }\\n        // else retreive the calculated column\\n        else{\\n            column = (CalculatedColumn)table.Columns[columnName];\\n        }\\n\\n        // and update it's properties\\n        column.DataType = DataType.DateTime;\\n        column.IsHidden = true;\\n        column.FormatString = dateFormatString;\\n        column.Description = \\\"Shows when SSAS table was last processed\\\";\\n    }\\n}\\n\\n// ---------------------------\\n// 2. create (or update) a \\\"Last Updated Tabular\\\" calculated table \\n//    containing data from the above calculated column\\n// ---------------------------\\n\\nList<string> rowsList = new List<string>();\\n\\n\\n// Loop through all tables in model\\nforeach(var table in Model.Tables) {\\n\\n    // if calculated column exists\\n    if (table.Columns.Contains(columnName))\\n    {\\n        // create DAX row expression to create row data\\n        var s = String.Format(@\\\"\\n    ROW (\\n        \\\"\\\"Last Processed\\\"\\\", FORMAT ( MAX ( {0} ), \\\"\\\"{1}\\\"\\\"),\\n        \\\"\\\"Table Name\\\"\\\", \\\"\\\"{2}\\\"\\\"\\n    )\\\"\\n                , table.Columns[columnName].DaxObjectFullName\\n                , dateFormatString\\n                , table.Name);\\n\\n        // add row expression to list\\n        rowsList.Add(s);\\n    }\\n}\\n\\n// Combine all row statements into a single DAX expression\\nvar rows = String.Join(\\\", \\\", rowsList);\\nvar expression = String.Format(\\\"UNION ( {0} )\\\", rows);\\n\\nCalculatedTable tbl;\\n\\n// If calculated table already exists, retreive it\\nif (Model.Tables.Contains(tableName)){\\n    tbl = (CalculatedTable)Model.Tables[tableName];\\n}\\n// else add new calculated table to the model\\nelse{\\n    tbl = Model.AddCalculatedTable(tableName);\\n}\\n\\n// update calculated table's expression to earlier-built DAX expression\\ntbl.Expression = expression;",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Hide Columns Ending with 'Key' in Selected Tables",
      "Enabled": "true",
      "Execute": "// Hide all columns ending with \\\"Key\\\" in selected tables from report\\n\\nvar keySuffix = \\\"Key\\\";\\n\\n// Loop through all currently selected tables:\\nforeach(var t in Selected.Tables)\\n{\\n    // Loop through all columns ending with \\\"Key\\\" on the current table:\\n    foreach(var k in t.Columns.Where(c => c.Name.EndsWith(keySuffix)))\\n    {\\n        k.IsHidden = true;\\n    }\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Hide columns on the many side of a relationship",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Hide columns on the many side of a relationship  \\n *\\n * Author: Matt Allington, https://exceleratorbi.com.au  \\n *\\n * it is dangerous to use columns on the many side of a relationship as it can \\n * produce unexpected results, so it is a best practice to hide these columns\\n * to discourage their use in reports.\\n */\\n\\n// Hide all columns on many side of a join\\n\\nforeach (var r in Model.Relationships)\\n{ // hide all columns on the many side of a join\\n    var c = r.FromColumn.Name;\\n    var t = r.FromTable.Name;\\n    Model.Tables[t].Columns[c].IsHidden = true;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Import Best Practice Analyer Rules",
      "Enabled": "true",
      "Execute": "/*\\n    Best Practice Analyzer enables options in Tools to check best practices in models and apply fixes \\n    to items in the model which may hinder performance. Past code in advanced editor and run, \\n    then close tabular editor, re-open and click Tools at the top.\\n*/\\n\\n \\n\\nSystem.Net.WebClient w = new System.Net.WebClient();  \\n \\nstring path = System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData); \\nstring url = \\\"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\\\"; \\nstring downloadLoc = path+@\\\"\\TabularEditor\\BPARules.json\\\"; \\nw.DownloadFile(url, downloadLoc); ",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Move All Columns to a DisplayFolder",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Move All Columns to a DisplayFolder  \\n *\\n * Author: Matt Allington, https://exceleratorbi.com.au  \\n *\\n *  move all columns into a display folder.  \\n *  read why at https://exceleratorbi.com.au/column-sub-folders-better-than-measure-sub-folders/\\n */\\n\\n\\n//Move all columns to display folder\\nforeach (var c in Model.AllColumns)\\n{\\n    c.DisplayFolder = \\\"_Columns\\\";\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Nuke All Implicit Measures",
      "Enabled": "true",
      "Execute": "// Title: Nuke All Implicit Measures.csx\\n// Author: @JamesDBartlett3@techhub.social\\n// Description: Uses two methods to disable all Implicit Measures in the model\\n\\n// 1. Set \\\"Discourage Implicit Measures\\\" option in Model = true\\nModel.DiscourageImplicitMeasures = true;\\n    \\n// 2. Set \\\"Summarize By\\\" property on all columns = AggregateFunction.None\\nforeach(var column in Model.Tables.SelectMany(t => t.Columns)) {\\n    column.SummarizeBy = AggregateFunction.None;\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Preview top50 values of selected columns by number of rows",
      "Enabled": "true",
      "Execute": "// Author: Martin de la Herran, expanded from original work from Tommy Puglia ( https://pugliabi.com )\\n// Script to show the top 50 distinct values based on selected columns. \\n// It shows the top 50 values of the selected columns and number and % of rows, \\n// The [@SPECIAL] column indicates clearly blank vs empty string, and also shows the total remainig (after the top50) (in this case, disregard the individual value, it is a placeholder)\\n\\n// Pre-Req:\\n// Save this Macro with the following:\\n// Name: Preview\\Top50\\n// Marco Context: Column\\n// (Hint, you can organize your macros in TE3 by grouping based on a \\\"\\\\\" separator!\\\")\\n\\n// Instructions:\\n// 1. Select the columns you want to see the distinct values for\\n// 2. Run the script (Right Click, on the selected columns, and choose the Preview --> Top50 macro)\\n// 3. For every column chosen, a pop-up will appear\\n\\n\\nforeach(var c in Selected.Columns)\\n{\\nstring cName = c.Name;\\nstring cTable = c.Table.DaxObjectFullName;\\nvar cColumn = c.DaxObjectFullName;\\nvar cColumnName = c.DaxObjectName;\\nstring daxQuery =\\n \\\" VAR _TotalRows = COUNTROWS( \\\" + cTable + \\\" ) \\\"\\n+\\\" VAR _TOP = \\\"\\n+\\\" TOPN(50 ,                                                        \\\"\\n+\\\"    ADDCOLUMNS(                                                   \\\"\\n+\\\"        VALUES( \\\" + cColumn + \\\" )                                 \\\"\\n+\\\"        , \\\\\"@SPECIAL\\\\\" , IF(ISBLANK( \\\" + cColumn\t + \\\" ) , \\\\\"!!____ BLANK ____!!\\\\\"  \\\"  \\n+\\\"            ,  IF(FORMAT( \\\" + cColumn + \\\" , 0.0000 )==\\\\\"\\\\\", \\\\\"!!____ EMPTY STRING ____!!\\\\\" \\\"\\n+\\\"            , blank() )) \\\" \\n+\\\"        , \\\\\"@CR\\\\\" , CALCULATE(COUNTROWS(+ \\\" + cTable + \\\" ))       \\\"\\n+\\\"        , \\\\\"@%CR\\\\\" ,ROUND(100*CALCULATE(COUNTROWS(+ \\\" + cTable + \\\" ))/_TotalRows , 2)      \\\"\\n+\\\"    )                                                             \\\"\\n+\\\"    , [@CR] , DESC , \\\" + cColumnName + \\\" , ASC                                             \\\"\\n+\\\" ) \\\"\\n+\\\" VAR _REMAINING = _TotalRows - sumx(_TOP, [@CR])  \\\" \\n+\\\" var _DUMMY = MIN( \\\" + cColumn + \\\" )  \\\"\\n+\\\" VAR _ROWREMAIN = { ( _DUMMY , \\\\\"!!____ OTHER ____!!\\\\\" , _REMAINING , ROUND(100*_REMAINING/_TotalRows , 2) )}  \\\"\\n+\\\" VAR _FINAL = FILTER(UNION( _TOP , _ROWREMAIN), [@CR] > 0 ) \\\"\\n+ \\\"RETURN _FINAL \\\"\\n+ \\\"ORDER BY [@SPECIAL] DESC, [@CR] DESC \\\" ;\\n\\n//daxQuery.Output()\t; // uncomment this is you want to see the DAX query\\n\\nvar cResult = EvaluateDax(daxQuery);\\n\\ncResult.Output();\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Replace Dataset Source Dataflow IDs",
      "Enabled": "true",
      "Execute": "// Title: ReplaceDatasetSourceDataflowIDs.csx\\n// Author: @JamesDBartlett3@techhub.social\\n// Description: Replace the source DataflowID & WorkspaceID on all partitions in the model\\n\\nvar oldWorkspaceId = \\\"\\\";\\nvar newWorkspaceId = \\\"\\\";\\nvar oldDataflowId = \\\"\\\";\\nvar newDataflowId = \\\"\\\";\\n\\n// Loop through all partitions on the model, replacing the DataflowIDs & WorkspaceIDs\\nforeach(var p in Model.AllPartitions.OfType<MPartition>())\\n{\\n    p.Expression = p.Expression\\n                      .Replace(oldWorkspaceId, newWorkspaceId)\\n                      .Replace(oldDataflowId, newDataflowId);\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Replace String Across All Power Queries",
      "Enabled": "true",
      "Execute": "// Title: ReplaceStringAcrossAllPowerQueries.csx\\n// Author: @JamesDBartlett3@techhub.social\\n// Description: Replaces a string in PowerQuery on all partitions in the model\\n\\nvar oldPQString = \\\"\\\";\\nvar newPQString = \\\"\\\";\\n\\n// Loop through all partitions on the model, replacing oldPQString with newPQString\\nforeach(var p in Model.AllPartitions.OfType<MPartition>())\\n{\\n    p.Expression = p.Expression\\n                      .Replace(oldPQString, newPQString);\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Replace String In All Measure Descriptions",
      "Enabled": "true",
      "Execute": "// Title: Replace String In All Model Descriptions.csx\\n// Author: Dan Meissner \\n// Description: Replaces text in all descriptions for any measure in the model, replacing one string with another string.\\n\\nvar oldTableNameString = \\\"OldString\\\";\\nvar newTableNameString = \\\"NewString\\\";\\n\\n// Loop through all tables in the model, replacing oldTableNameString with newTableNameString\\nforeach(var m in Model.AllMeasures)\\n{\\n    m.Description = m.Description.Replace(oldTableNameString, newTableNameString);\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Replace String In All Table Names",
      "Enabled": "true",
      "Execute": "// Title: Replace String In All Table Names.csx\\n// Author: @JamesDBartlett3@techhub.social\\n// Description: Renames all tables in the model, replacing one string with another string\\n\\nvar oldTableNameString = \\\"\\\";\\nvar newTableNameString = \\\"\\\";\\n\\n// Loop through all tables in the model, replacing oldTableNameString with newTableNameString\\nforeach(var t in Model.Tables)\\n{\\n    t.Name = t.Name.Replace(oldTableNameString, newTableNameString);\\n\t// Loop through all partitions in the table, replacing oldTableNameString with newTableNameString\\n\tforeach(var p in t.Partitions)\\n\t{\\n\t\tp.Name = p.Name.Replace(oldTableNameString, newTableNameString);\\n\t}\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Select Columns Remove Auto Aggregations",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Set Summarize by to None on Selected Columns\\n *\\n * Author: Mike Carlo, https://PowerBI.tips\\n *\\n * User can select columns. From the selection each column will be set to Aggregate = None or Summarize by = None, as observed in Power BI Desktop.\\n * Only Selected columns will be modified.\\n *\\n */\\n\\n   \\n\\nforeach(var column in Selected.columns) {\\n\\n    column.SummarizeBy = AggregateFunction.None;\\n\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Select Measures and apply Whole Number Format",
      "Enabled": "true",
      "Execute": "/* For each selected measure change the formatting to a whole number\\n *\\n * Author: Mike Carlo, https://powerbi.tips\\n *\\n * Select measures using Control + Left Click\\n * Script change the measure formatting to a whole number\\n *\\n */\\n\\n// for each selected measure specifies a format.\\nforeach (var m in Selected.Measures)\\n{\\n\\n    // Set the format string on the new measure:\\n    m.FormatString = \\\"#,##0\\\";\\n\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Basic\\Wrap Measure in HASONEVALUE Check",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Add \\\"HASONEVALUE\\\" check to Selected Measures\\n *\\n * Author: Dan Meissner\\n * Last Modified: 2022DEC20\\n *\\n * This script loops through all the selected measures and adds an IF statement check to see if it \\\"HASONEVALUE\\\"\\n * relative to the single selected column.\\n\\n * Only selected measures will be modified. \\n * Must select only one column in addition to any number of measures for which you want to check for one value.\\n *\\n */\\n\\n/* Assign variables */\\nvar measures = Selected.Measures;\\nvar columns = Selected.Columns;\\n\\n/* Check for at least one measure and only one column selected */\\nif (measures.Count == 0)\\n{\\n    Error(\\\"Select one or more measures\\\");\\n    return;\\n};\\n\\nif (columns.Count != 1)\\n{\\n    Error(\\\"Select only one column along with any measures\\\");\\n    return;\\n};\\n\\n/* Cycle over all Selected measures in model */\\nforeach (var c in columns)\\n    {\\n    foreach (var m in measures)\\n        {\\n            /* Wrap the current measure in a HASONEVALUE(column) check */\\n            m.Expression = \\\"IF ( HASONEVALUE( \\\" + c.DaxObjectFullName + \\\" ), \\\" + m.Expression + \\\" )\\\";\\n        };\\n    }   ",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Clean Up Columns Measures",
      "Enabled": "true",
      "Execute": "//\\n//\\n// by Tommy Puglia\\n// twitter: @tommypuglia\\n// pugliabi.com\\n//\\n// Cleans up Columns & Measures, mainly\\n// Columns:\\n// ---- Changes Any Date Column to a better FormatString \\n// ---- Updates any Column that is number to not be summed\\n// ---- Adds All Columns to a __columns Display Folder\\n//\\n// Measures:\\n// ---- Updates Measures that have no format to Whole Number\\n// ---- Adds Description to measures (DAX)\\n// ---- Adds measures to a Display Folder (__KPI)\\n//\\n\\nvar sb = new System.Text.StringBuilder();\\nstring newline = Environment.NewLine;\\n\\nforeach(var c in Model.AllColumns.Where(a => a.DataType == DataType.DateTime)) {\\n\tc.FormatString = \\\"m/d/yyyy\\\";\\n\\n\\n}\\nforeach(var c in Model.AllColumns.Where(a => a.DataType == DataType.Int64 || a.DataType == DataType.Decimal || a.DataType == DataType.Double)) {\\n\tc.SummarizeBy = AggregateFunction.None;\\n\\n}\\nforeach(var c in Model.AllColumns) {\\nc.DisplayFolder = \\\"_columns\\\";\\n}\\n\\n\\n\\nforeach(var m in Model.AllMeasures) {\\n\tstring colFomratString = \\\"\\\";\\n\tif (m.FormatString == colFomratString) {\\n\t\tm.FormatString = \\\"#,0\\\";\\n\t}\\n     if(string.IsNullOrEmpty(m.Description))\\n    {\\n       m.Description =m.Expression;\\n\\n    }\\n    if(m.DisplayFolder == \\\"\\\")\\n    {\\nm.DisplayFolder = \\\"__KPI\\\";\\n\\n    }\\n\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Clean object names",
      "Enabled": "true",
      "Execute": "#r \\\"System.Text.RegularExpressions\\\"\\n\\n/*\\n * Title: Clean Object Names\\n * \\n * Author: Darren Gosbell, twitter.com/DarrenGosbell\\n * \\n * This script, when executed, will loop through your model and update the\\n * names of any tables and columns with CamelCaseNames and insert spaces before upper\\n * case characters so you end up with\\n * \\n * before: CalendarYearNum\\n * after:  Calendar Year Num\\n *\\n * This script ignores any columns that already have spaces in the names \\n * and any hidden columns. It also skips adjacent upper case characters\\n * so \\\"MyTXTColumn\\\"  becomes \\\"My TXT Column\\\"\\n */\\n\\n// this regular expression splits strings on underscores and changes from lower to upper case\\n// so \\\"my_column_name\\\" becomes an array like {\\\"my\\\", \\\"_\\\", \\\"column\\\", \\\"_\\\", \\\"name\\\"}\\n// and \\\"MyOtherColumnName\\\" becomes an array like {\\\"My\\\", \\\"Other\\\", \\\"Column\\\", \\\"Name\\\"}\\nvar rex = new System.Text.RegularExpressions.Regex( \\\"(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+|[^A-Z,a-z]+|[_]|[a-z]+)\\\");\\n\\n// if any of the following are the first word of a table name they will be stripped out\\nList<string> tablePrefixesToIgnore = new List<string>() {\\\"dim\\\",\\\"fact\\\", \\\"vw\\\",\\\"tbl\\\",\\\"vd\\\",\\\"td\\\",\\\"tf\\\",\\\"vf\\\"};\\n\\n// if any of the following are the last word of a table name they will be stripped out\\nList<string> tableSuffixesToIgnore = new List<string>() {\\\"dim\\\", \\\"fact\\\"};\\n\\nforeach (var tbl in Model.Tables) \\n{\\n    if (!tbl.IsHidden && !tbl.Name.Contains(\\\" \\\")) \\n    {\\n        string name = tbl.Name;\\n        var matches = rex.Matches(name);\\n        var firstWord = matches[0];\\n        var lastWord = matches[matches.Count-1];\\n        string[] words = matches\\n                        .OfType<System.Text.RegularExpressions.Match>()\\n                        .Where(m =>\\n                                // skip words that are just underscores so that they are replaced with spaces\\n                                m.Value != \\\"_\\\" \\n                                // skip the first word if it matches one of the prefixes to ignore\\n                                && !(m == firstWord && tablePrefixesToIgnore.Contains(m.Value,System.StringComparer.OrdinalIgnoreCase)) \\n                                // skip the last word if it matches one of the suffixes to ignore\\n                                && !(m == lastWord && tableSuffixesToIgnore.Contains(m.Value,System.StringComparer.OrdinalIgnoreCase )) \\n                                )\\n                        .Select(m => char.ToUpper(m.Value.First()) + m.Value.Substring(1))\\n                        .ToArray();                \\n        string result = string.Join(\\\" \\\", words);\\n        tbl.Name = result;\\n    }\\n\\n    foreach (var col in tbl.Columns)\\n    {\\n        if (!col.IsHidden && !col.Name.Contains(\\\" \\\")) \\n        {\\n            string name = col.Name;\\n            string[] words = rex.Matches(name)\\n                            .OfType<System.Text.RegularExpressions.Match>()\\n                            // skip underscores \\n                            .Where(m => m.Value != \\\"_\\\" )\\n                            .Select(m => char.ToUpper(m.Value.First()) + m.Value.Substring(1))\\n                            .ToArray();                \\n            string result = string.Join(\\\" \\\", words);\\n            col.Name = result;\\n        }\\n    }\\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Create Explicit Measures",
      "Enabled": "true",
      "Execute": "// Title: Auto-create explicit measures from all columns in all tables that have qualifying aggregation functions assigned \\n//  \\n// Author: Tom Martens, twitter.com/tommartens68\\n// \\n// This script, when executed, will loop through all the tables and creates explicit measure for all the columns with qualifying\\n// aggregation functions.\\n// The qualifying aggregation functions are SUM, COUNT, MIN, MAX, AVERAGE.\\n// This script can create a lot of measures, as by default the aggregation function for columns with a numeric data type is SUM.\\n// So, it is a good idea to check all columns for the proper aggregation type, e.g. the aggregation type of id columns \\n// should be set to None, as it does not make any sense to aggregate id columns.\\n// An annotation:CreatedThrough is created with a value:CreateExplicitMeasures this will help to identify the measures created\\n// using this script.\\n// What is missing, the list below shows what might be coming in subsequent iterations of the script:\\n// - the base column property hidden is not set to true\\n// - no black list is used to prevent the creation of unwanted measures\\n\\n// ***************************************************************************************************************\\n//the following variables are allowing controling the script\\nvar overwriteExistingMeasures = 0; // 1 overwrites existing measures, 0 preserves existing measures\\n\\nvar measureNameTemplate = \\\"{0} ({1}) - {2}\\\"; // String.Format is used to create the measure name. \\n//{0} will be replaced with the columnname (c.Name), {1} will be replaced with the aggregation function, and last but not least\\n//{2} will be replaced with the tablename (t.Name). Using t.Name is necessary to create a distinction between measure names if\\n//columns with the same name exist in different tables.\\n//Assuming the column name inside the table \\\"Fact Sale\\\" is \\\"Sales revenue\\\" and the aggregation function is SUM \\n//the measure name will be: \\\"Sales revenue (Sum) - Fact Sale\\\"\\n\\n//store aggregation function that qualify for measure creation to the hashset aggFunctions\\nvar aggFunctions = new HashSet<AggregateFunction>{\\n    AggregateFunction.Default, //remove this line, if you do not want to mess up your measures list by automatically created measures for all the columns that have the Default AggregateFunction assigned\\n    AggregateFunction.Sum,\\n    AggregateFunction.Count,\\n    AggregateFunction.Min,\\n    AggregateFunction.Max,\\n    AggregateFunction.Average\\n};\\n\\n//You have to be aware that by default this script will just create measures using the aggregate functions \\\"Sum\\\" or \\\"Count\\\" if\\n//the column has the aggregate function AggregateFunction.Default assigned, this is checked further down below.\\n//Also, if a column has the Default AggregateFunction assigned and is of the DataType\\n//DataType.Automatic, DataType.Unknown, or DataType.Variant, no measure is created automatically, this is checked further down below.\\n//dictDataTypeAggregateFunction = new Dictionary<DataType, string>();\\n//see this article for all the available data types: https://docs.microsoft.com/en-us/dotnet/api/microsoft.analysisservices.tabular.datatype?view=analysisservices-dotnet\\n//Of course you can change the aggregation function that will be used for different data types,\\n//as long as you are using \\\"Sum\\\" and \\\"Count\\\"\\n//Please be careful, if you change the aggregation function you might end up with multiplemeasures\\nvar dictDataTypeAggregateFunction = new Dictionary<DataType, AggregateFunction>();\\ndictDataTypeAggregateFunction.Add( DataType.Binary , AggregateFunction.Count ); //adding a key/value pair(s) to the dictionary using the Add() method\\ndictDataTypeAggregateFunction.Add( DataType.Boolean , AggregateFunction.Count );\\ndictDataTypeAggregateFunction.Add( DataType.DateTime , AggregateFunction.Count );\\ndictDataTypeAggregateFunction.Add( DataType.Decimal , AggregateFunction.Sum );\\ndictDataTypeAggregateFunction.Add( DataType.Double , AggregateFunction.Sum );\\ndictDataTypeAggregateFunction.Add( DataType.Int64 , AggregateFunction.Sum );\\ndictDataTypeAggregateFunction.Add( DataType.String , AggregateFunction.Count );\\n\\n// ***************************************************************************************************************\\n//all the stuff below this line should not be altered \\n//of course this is not valid if you have to fix my errors, make the code more efficient, \\n//or you have a thorough understanding of what you are doing\\n\\n//store all the existing measures to the list listOfMeasures\\nvar listOfMeasures = new List<string>();\\nforeach( var m in Model.AllMeasures ) {\\n    listOfMeasures.Add( m.Name );\\n}\\n\\n//loop across all tables\\nforeach( var t in Model.Tables ) {\\n    \\n    //loop across all columns of the current table t\\n    foreach( var c in t.Columns ) {\\n        \\n        var currAggFunction = c.SummarizeBy; //cache the aggregation function of the current column c\\n        var useAggFunction = AggregateFunction.Sum;\\n        var theMeasureName = \\\"\\\"; // Name of the new Measure\\n        var posInListOfMeasures = 0; //check if the new measure already exists <> -1\\n        \\n        if( aggFunctions.Contains(currAggFunction) ) //check if the current aggregation function qualifies for measure aggregation\\n        {\\n            //check if the current aggregation function is Default\\n            if( currAggFunction == AggregateFunction.Default )\\n            {\\n                // check if the datatype of the column is considered for measure creation\\n                if( dictDataTypeAggregateFunction.ContainsKey( c.DataType ) )\\n                {\\n                    \\n                    //some kind of sanity check\\n                    if( c.DataType == DataType.Automatic || c.DataType == DataType.Unknown || c.DataType == DataType.Variant )\\n                    {\\n                        Output(\\\"No measure will be created for columns with the data type: \\\" + c.DataType.ToString() + \\\" (\\\" + c.DaxObjectFullName + \\\")\\\");\\n                        continue; //moves to the next item in the foreach loop, the next colum in the current table\\n                    }\\n                  \\n                    //cache the aggregation function from the dictDataTypeAggregateFunction\\n                    useAggFunction = dictDataTypeAggregateFunction[ c.DataType ];\\n                    \\n                    //some kind of sanity check\\n                    if( useAggFunction != AggregateFunction.Count && useAggFunction != AggregateFunction.Sum ) \\n                    {    \\n                        Output(\\\"No measure will be created for the column: \\\" + c.DaxObjectFullName);\\n                        continue; //moves to the next item in the foreach loop, the next colum in the current table\\n                    }\\n                    theMeasureName = String.Format( measureNameTemplate , c.Name , useAggFunction.ToString() , t.Name ); // Name of the new Measure\\n                    posInListOfMeasures = listOfMeasures.IndexOf( theMeasureName ); //check if the new measure already exists <> -1\\n                    \\n                } else {\\n                   \\n                    continue; //moves to the next item in the foreach loop, the next colum in the current table\\n                }\\n                        \\n            } else {\\n                \\n                useAggFunction = currAggFunction;    \\n                theMeasureName = String.Format( measureNameTemplate , c.Name , useAggFunction.ToString() , t.Name ); // Name of the new Measure\\n                posInListOfMeasures = listOfMeasures.IndexOf( theMeasureName ); //check if the new measure already exists <> -1\\n                \\n            }\\n            \\n            //sanity check\\n            if(theMeasureName == \\\"\\\")\\n            {\\n                continue; //moves to the next item in the foreach loop, the next colum in the current table\\n            }\\n            \\n            // create the measure\\n            if( ( posInListOfMeasures == -1 || overwriteExistingMeasures == 1 )) \\n            {    \\n                if( overwriteExistingMeasures == 1 ) \\n                {\\n                    foreach( var m in Model.AllMeasures.Where( m => m.Name == theMeasureName ).ToList() ) \\n                    {\\n                        m.Delete();\\n                    }\\n                }\\n                \\n                var newMeasure = t.AddMeasure\\n                (\\n                    theMeasureName                                                                      // Name of the new Measure\\n                    , \\\"\\\" + useAggFunction.ToString().ToUpper() + \\\"(\\\" + c.DaxObjectFullName + \\\")\\\"        // DAX expression\\n                );\\n                \\n                newMeasure.SetAnnotation( \\\"CreatedThrough\\\" , \\\"CreateExplicitMeasures\\\" ); // flag the measures created through this script\\n                \\n            }\\n        }    \\n    }        \\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Create Measure for Each Item in Selected Columns",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Create Measure for Each Item in Selected Columns\\n * \\n * Author: Michael Mays, twitter.com/ItsAMaysin \\n *\\n * This script, when executed, will loop through the currently selected columns and\\n * create a measure for each item in the column. In the below, the newly\\n * created measure will be of the format \\n * CALCULATE ( [BaseMeasure], Table[SelectedColumn] = \\\"Item N in Selected Column\\\")\\n */\\n\\nforeach (var c in Selected.Columns)\\n{\\n    string MyColumn = c.DaxObjectFullName;\\n    string GetItems = \\\"EVALUATE VALUES (\\\" + MyColumn + \\\")\\\"; // List of items from column\\n\\n    using (var reader = Model.Database.ExecuteReader(GetItems))\\n    {\\n\\n        // Create a loop for every row in the resultset\\n        while(reader.Read())\\n        {\\n            string MyItem = reader.GetValue(0).ToString();\\n            string MyExpression;\\n            string MeasureName = \\\"***Your Measure Here****\\\";\\n            string NamePreFix = \\\"# of \\\";\\n            string NamePostFix = \\\"\\\";\\n    \\n            //Create measure for item\\n            MyExpression = \\n                \\\"CALCULATE ( [\\\" + MeasureName + \\\"], \\\" + MyColumn + \\\" = \\\\\"\\\" + MyItem + \\\"\\\\\" )\\\" ;\\n            c.Table.AddMeasure(\\n                NamePreFix + MyItem + NamePostFix, \\n                MyExpression\\n            );\\n\\n        }\\n    };\\n};\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Create Parent-Child Hierarchy",
      "Enabled": "true",
      "Execute": "// Title: Create Parent-Child Hierarchy.csx\\n//  \\n// Author: Sergio Murru, https://sergiomurru.com\\n// \\n//  Implementing Parent-Child hierarchies in DAX requires the usage of a special set of functions, PATH, PATHITEM and PATHLENGTH, specifically designed for this purpose. \\n//  These functions are used to flatten the hierarchy as as set of calculated columns. \\n//  This means that the depth of the hierarchy is fixed and limited to the number of calculated columns that was decided at design time.\\n//  This script to automatically generate these parent-child hierarchies.\\n\\n// ***************************************************************************************************************\\n//the following variables are allowing controling the script\\n\\n// configuration start\\n\\nint levels = 4;\\n\\nstring tableName = \\\"Entity\\\";\\nvar table = Model.Tables[tableName];\\n\\nstring pathName = \\\"EntityPath\\\";\\nstring keyName = \\\"EntityKey\\\";\\nstring nameName = \\\"EntityName\\\";\\nstring parentKeyName = \\\"ParentEntityKey\\\";\\nstring levelNameFormat = \\\"Level{0}\\\";\\nstring depthName = \\\"Depth\\\";\\nstring rowDepthMeasureName = \\\"EntityRowDepth\\\";\\nstring browseDepthMeasureName = \\\"EntityBrowseDepth\\\";\\nstring wrapperMeasuresTableName = \\\"StrategyPlan\\\";\\nstring hierarchyName = \\\"Entities\\\";\\nvar wrapperMeasuresTable = Model.Tables[wrapperMeasuresTableName];\\nSortedDictionary<string, string> measuresToWrap = \\n    new SortedDictionary<string, string> \\n{ \\n    { \\\"# Categories\\\", \\\"# Categories Base\\\"}, \\n    { \\\"Sum Amount\\\", \\\"Total Base\\\" } \\n};\\n// configuration end\\n\\n\\nstring daxPath = string.Format( \\\"PATH({0}[{1}], {0}[{2}])\\\", \\n    tableName, keyName, parentKeyName);\\n    \\n\\n// cleanup\\n\\nvar hierarchiesCollection = table.Hierarchies.Where( \\n    m => m.Name == hierarchyName );\\nif (hierarchiesCollection.Count() > 0)\\n{\\n    hierarchiesCollection.First().Delete();\\n}\\n\\nforeach (var wrapperMeasurePair in measuresToWrap)\\n{\\n    var wrapperMeasuresCollection = wrapperMeasuresTable.Measures.Where( \\n        m => m.Name == wrapperMeasurePair.Value ); \\n    if (wrapperMeasuresCollection.Count() > 0)\\n    {\\n        wrapperMeasuresCollection.First().Delete();\\n    }\\n} \\n\\nvar browseDepthMeasureCollection = table.Measures.Where( \\n    m => m.Name == browseDepthMeasureName );\\nif (browseDepthMeasureCollection.Count() > 0)\\n{\\n    browseDepthMeasureCollection.First().Delete();\\n}\\n\\nvar rowDepthMeasureCollection = table.Measures.Where( \\n    m => m.Name == rowDepthMeasureName );\\nif (rowDepthMeasureCollection.Count() > 0)\\n{\\n    rowDepthMeasureCollection.First().Delete();\\n}\\n\\nvar depthCollection = table.CalculatedColumns.Where( \\n    m => m.Name == depthName );\\nif (depthCollection.Count() > 0)\\n{   \\n    depthCollection.First().Delete();\\n}\\n\\nfor (int i = 1; i <= levels; ++i)\\n{\\n    string levelName = string.Format(levelNameFormat, i);\\n    var levelCalculatedColumnCollection = \\n        table.CalculatedColumns.Where( m => m.Name == levelName );\\n    if (levelCalculatedColumnCollection.Count() > 0)\\n    {    \\n        levelCalculatedColumnCollection.First().Delete();\\n    }\\n}\\n\\nvar pathCalculatedColumnCollection = table.CalculatedColumns.Where( \\n    m => m.Name == pathName );\\nif (pathCalculatedColumnCollection.Count() > 0)\\n{\\n    pathCalculatedColumnCollection.First().Delete();\\n}\\n\\n\\n// create calculated columns\\ntable.AddCalculatedColumn(pathName, daxPath);\\n\\nstring daxLevelFormat = \\n@\\\"VAR LevelNumber = {0}\\nVAR LevelKey = PATHITEM( {1}[{2}], LevelNumber, INTEGER )\\nVAR LevelName = LOOKUPVALUE( {1}[{3}], {1}[{4}], LevelKey )\\nVAR Result = LevelName\\nRETURN\\n    Result\\n\\\";\\n\\nfor (int i = 1; i <= levels; ++i)\\n{\\n    string levelName = string.Format(levelNameFormat, i);\\n    string daxLevel = string.Format(daxLevelFormat, i, \\n        tableName, pathName, nameName, keyName);\\n    table.AddCalculatedColumn(levelName, daxLevel);\\n}\\n\\nstring daxDepthFormat = \\\"PATHLENGTH( {0}[{1}] )\\\";\\nstring daxDepth = string.Format(\\n    daxDepthFormat, tableName, pathName); \\ntable.AddCalculatedColumn(depthName, daxDepth);\\n\\n\\n// Create Hierarchy\\n\\ntable.AddHierarchy(hierarchyName);\\nfor (int i = 1; i <= levels; ++i)\\n{\\n    string levelName = string.Format(levelNameFormat, i);\\n    string daxLevel = string.Format(daxLevelFormat, i, \\n        tableName, pathName, nameName, keyName);\\n    table.Hierarchies[hierarchyName].AddLevel(levelName);\\n}\\n\\n\\n// Create measures\\nstring daxRowDepthMeasureFormat = \\\"MAX( {0}[{1}])\\\";\\nstring daxRowDepthMeasure = string.Format(\\n    daxRowDepthMeasureFormat, tableName, depthName );\\ntable.AddMeasure(rowDepthMeasureName, daxRowDepthMeasure);\\n\\nstring daxBrowseDepthMeasure = \\\"\\\";\\nfor (int i = 1; i <= levels; ++i)\\n{\\n    string levelMeasureFormat = \\\"ISINSCOPE( {0}[{1}] )\\\";\\n    string levelName = string.Format(levelNameFormat, i);\\n    daxBrowseDepthMeasure += string.Format(\\n        levelMeasureFormat, tableName, levelName);\\n    if (i < levels)\\n    {\\n        daxBrowseDepthMeasure += \\\" + \\\";\\n    }\\n}\\ntable.AddMeasure(browseDepthMeasureName, daxBrowseDepthMeasure);\\n\\nstring daxWrapperMeasureFormat = \\n@\\\"VAR Val = [{0}]\\nVAR ShowRow = [{1}] <= [{2}]\\nVAR Result = IF( ShowRow, Val )\\nRETURN\\n    Result\\n\\\";\\n\\nforeach (var wrapperMeasurePair in measuresToWrap)\\n{\\n    string daxWrapperMeasure = string.Format(daxWrapperMeasureFormat,\\n        wrapperMeasurePair.Key, // measure to be wrapped\\n        browseDepthMeasureName,\\n        rowDepthMeasureName);\\n    wrapperMeasuresTable.AddMeasure(wrapperMeasurePair.Value, daxWrapperMeasure);\\n    \\n} \\n\\ntable.Measures.FormatDax(false);\\nwrapperMeasuresTable.Measures.FormatDax(false);\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Create Perspective From Fact Tables",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Create Perspective From Fact Tables\\n * \\n * Author: Curtis Stallings, https://www.linkedin.com/in/curtisrs/\\n * \\n * This script will take the selected tables and create a perspective that includes all the related tables, measures, & calc groups. \\n * It will take into consideration nested measures and tables. \\n * This script is useful for adding context to rather large models with multiple fact tables,\\n * Letting you narrow down the view for an end user, so they are not overwhelmed\\n *\\n */\\n\\n//You can select 1 or multiple tables, each table will get it's own perspective.\\nforeach(var table in Selected.Tables){\\n    \\n  //Check if Table Name already exists as a persp, Creates Perspective, Then Adds to Perspective\\n    if (!Model.Perspectives.Any(a => a.Name == table.Name))\\n        {\\n            Model.AddPerspective(table.Name);\\n        }\\n    Model.Tables[table.Name].InPerspective[table.Name] = true;\\n    \\n    //Gets and adds Related Tables to Perspective\\n    foreach(var related in table.RelatedTables){\\n        related.InPerspective[table.Name] = true;\\n    }\\n    \\n    //Gets and adds All Related Measures... Also includes Nested Measures.\\n    foreach(var measure in Model.AllMeasures){\\n        foreach(var measure_dependency in measure.DependsOn.Deep()){\\n            if(measure_dependency.ObjectType.ToString() == \\\"Table\\\" \\n            && Model.Tables[measure_dependency.Name].InPerspective[table.Name] == true\\n            && Model.Tables[measure_dependency.Name] == Model.Tables[table.Name]){\\n                measure.InPerspective[table.Name] = true;\\n            }\\n        }\\n    }\\n    \\n    //Gets and adds All Calculation Groups... And the Calculation Group Dependencies\\n    foreach(var calc_group in Model.CalculationGroups){\\n        foreach(var calc_item in calc_group.CalculationItems){\\n            foreach(var calc_dependency in calc_item.DependsOn.Deep()){\\n                if(calc_dependency.ObjectType.ToString() == \\\"Table\\\"\\n                && Model.Tables[calc_dependency.Name].InPerspective[table.Name]){\\n                    calc_group.InPerspective[table.Name] = true;\\n                }\\n            }\\n        }\\n    }\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Create Time Intelligence Measures Using Calculation Groups",
      "Enabled": "true",
      "Execute": "/*\\n * Generate time intelligence measures based on calculation group items already created\\n *\\n * Author: Benoit Fedit, https://datakuity.com/ \\n *\\n * You must have created the calculation group items beforehand (see link below)\\n * https://docs.microsoft.com/en-us/analysis-services/tabular-models/calculation-groups?view=asallproducts-allversions\\n * To add more measure simply copy/paste the YTD script and replace YTD by your calculation item name\\n */\\n\\n\\n// For each selected measure create YTY, PY, PY YTD, YOY, YOY% measures\\nforeach(var m in Selected.Measures) {\\n    \\n    // YTD\\n    m.Table.AddMeasure(\\n    m.Name + \\\" YTD\\\",                                       // Name\\n    \\\"Calculate(\\\" + m.DaxObjectName + \\\", 'Time Intelligence'[Time Calculation]=\\\\\"YTD\\\\\")\\\",    \\n    m.DisplayFolder                                        // Display Folder\\n    );\\n    \\n    // PY\\n    m.Table.AddMeasure(\\n    m.Name + \\\" YTD\\\",                                       // Name\\n    \\\"Calculate(\\\" + m.DaxObjectName + \\\", 'Time Intelligence'[Time Calculation]=\\\\\"PY\\\\\")\\\",    \\n    m.DisplayFolder                                        // Display Folder\\n    );\\n    \\n    // PY YTD\\n    m.Table.AddMeasure(\\n    m.Name + \\\" PY YTD\\\",                                       // Name\\n    \\\"Calculate(\\\" + m.DaxObjectName + \\\", 'Time Intelligence'[Time Calculation]=\\\\\"PY YTD\\\\\")\\\",    \\n    m.DisplayFolder                                        // Display Folder\\n    );\\n    \\n    // YOY\\n    m.Table.AddMeasure(\\n    m.Name + \\\" YOY\\\",                                       // Name\\n    \\\"Calculate(\\\" + m.DaxObjectName + \\\", 'Time Intelligence'[Time Calculation]=\\\\\"YOY\\\\\")\\\",    \\n    m.DisplayFolder                                        // Display Folder\\n    ).FormatString = \\\"0.0 %\\\";\\n        \\n    // YOY%\\n    m.Table.AddMeasure(\\n    m.Name + \\\" YOY%\\\",                                       // Name\\n    \\\"Calculate(\\\" + m.DaxObjectName + \\\", 'Time Intelligence'[Time Calculation]=\\\\\"YOY%\\\\\")\\\",    \\n    m.DisplayFolder                                        // Display Folder\\n    );\\n}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Create Visuals Translations Measures",
      "Enabled": "true",
      "Execute": "/* \\n * Create visuals translations measures \\n * Author: Didier Terrien      https://thebipower.fr\\n * This script generates measures to be used in visuals conditional formating in order to translate \\n * visuals labels (title, ...). It reads a tsv file which contains the measure list  \\n *\\n * More details here : https://thebipower.fr/index.php/2020/05/07/visuals-labels-translations-in-power-bi-reports\\n * Download the example tsv file in the blog post\\n * There are different methods which have their own advantages. Be sure to read the post above before to use in production.\\n */\\n\\n// Modify the path and name of the visuals labels file to load \\nvar Visuals_labels_file = @\\\"...\\TE visuals labels.tsv\\\";\\n\\n// Modify the name of the table that should hold the measures. It will be created automatically\\nvar Target_table_name = \\\"Visuals translations measures\\\";\\n\\n// Modify the prefix of new measures to avoid conflicts with existing measures\\nvar Measures_prefix = \\\"AT_\\\"; \\n\\n// Select a method between \\\"USERCULTURE\\\" and \\\"SLICER\\\"\\nvar Method = \\\"SLICER\\\";\\n\\n\\n// Optionally select the file manually (Comment code below to use)\\n\\n// using (var openFileDialog = new System.Windows.Forms.OpenFileDialog()) {\\n//    openFileDialog.Title = \\\"Select a visuals labels file to load\\\";\\n//    if (System.IO.File.Exists(Visuals_labels_file)){\\n//        openFileDialog.InitialDirectory = System.IO.Directory.GetParent(Visuals_labels_file).ToString();\\n//    }\\n//    openFileDialog.Filter = \\\"tsv files (*.tsv)|*.tsv|All files (*.*)|*.*\\\";\\n//    openFileDialog.FilterIndex = 1;\\n//    openFileDialog.RestoreDirectory = true;\\n//    if (openFileDialog.ShowDialog() == System.Windows.Forms.DialogResult.OK) {\\n//        //Get the path of specified file\\n//        Visuals_labels_file = openFileDialog.FileName;\\n//        //System.Windows.Forms.MessageBox.Show(\\\"Selected file: \\\" + Visuals_labels_file);\\n//    } else {\\n//        Visuals_labels_file = \\\"\\\";\\n//    }\\n// }\\n\\n\\n// If file exists\\nif (System.IO.File.Exists(Visuals_labels_file)) { \\n    // Load the file content\\n    var tsvFileContent = ReadFile(Visuals_labels_file); \\n    \\n    // Split it into rows\\n    var Rows = tsvFileContent.Split(new[] {'\\r','\\n'},StringSplitOptions.RemoveEmptyEntries);\\n\\n    // Delete the target table to build it again from scratch\\n    if (Model.Tables.Contains(Target_table_name)) {\\n        Model.Tables[Target_table_name].Delete();\\n    }\\n    var Target_table = Model.AddCalculatedTable(Target_table_name, \\\"{0}\\\");\\n    var Fake_column = Target_table.AddCalculatedTableColumn(\\\"Fake Column\\\", \\\"[Fake Column]\\\", \\\"\\\", DataType.Int64);\\n    Fake_column.IsHidden = true;\\n    Target_table.Description = \\\"This table is auto generated by a Tabular Editor script. Do not modify it manually\\\";\\n    Target_table.SetAnnotation(\\\"VTAUTOGEN\\\", \\\"1\\\");  // Set a special annotation on the table. It might be useful in the future//    Model.Tables.First().Columns(\\\"Fake column\\\").Is\\n\\n    // Iterate all rows\\n    for(int Index_row = 1; Index_row < Rows.Length; Index_row++) {\\n        var Columns = Rows[Index_row].Split(new[] {'\\t'},StringSplitOptions.None); // Split the current row into columns\\n        var Object_ID = Columns[0];\\n        var Page_name = Columns[1];\\n        var Object_type = Columns[2];\\n        var Visual_name = Columns[3];\\n        var Reference_text = Columns[4];\\n        \\n        // If Reference text is not empty\\n        if (Reference_text.Trim() != \\\"\\\") { \\n            \\n            // Create the measure\\n            var VT_measure = Target_table.AddMeasure(Measures_prefix + Visual_name);\\n            var sb = new System.Text.StringBuilder();\\n            if (Method == \\\"SLICER\\\"){\\n                sb.Append(\\\"\\r\\n\\\");\\n                sb.Append(\\\"VAR Reference_text = \\\" + '\\\"' + Visual_name + '\\\"' + \\\"\\r\\n\\\");\\n                sb.Append(\\\"VAR Filtered_translations = FILTER( 'Visuals translations' ,\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"'Visuals translations'[Reference text] = Reference_text )\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"RETURN COALESCE( CALCULATE(\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"FIRSTNONBLANK( 'Visuals translations'[Translated text] , TRUE()) ,\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"Filtered_translations )\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\" , Reference_text\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\")\\\");            \\n            } else if (Method == \\\"USERCULTURE\\\") {\\n                sb.Append(\\\"\\r\\n\\\");\\n                sb.Append(\\\"VAR Reference_text = \\\" + '\\\"' + Visual_name + '\\\"' + \\\"\\r\\n\\\");\\n                sb.Append(\\\"VAR Filtered_translations = FILTER( ALL( 'Visuals translations') ,\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"'Visuals translations'[Reference text] = Reference_text &&\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"'Visuals translations'[Language code] = USERCULTURE()\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\")\\\");\\n                sb.Append(\\\"RETURN COALESCE( CALCULATE(\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"FIRSTNONBLANK( 'Visuals translations'[Translated text] , TRUE()) ,\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"\\t\\\" + \\\"Filtered_translations )\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\"\\t\\\" + \\\" , Reference_text\\\" + \\\"\\r\\n\\\");\\n                sb.Append(\\\"\\t\\\" + \\\")\\\");\\n            }\\n            VT_measure.Expression =  sb.ToString();\\n            VT_measure.Description = \\\"This measure is auto generated by a Tabular Editor script. Do not modify it manually\\\";\\n            VT_measure.DisplayFolder = \\\"\\\";\\n            VT_measure.SetAnnotation(\\\"VTAUTOGEN\\\", \\\"1\\\");  // Set a special annotation on the measure. It might be useful in the future\\n        }\\n    }\\n} else {\\n    Output(\\\"Visuals labels file doesn't exist. Please modify it at the top of the script\\\"); \\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Dynamic YtD same period",
      "Enabled": "true",
      "Execute": "#r \\\"Microsoft.VisualBasic\\\"\\nusing Microsoft.VisualBasic;\\n//\\n//\\n// by Tommy Puglia\\n// twitter: @tommypuglia\\n// pugliabi.com\\n//\\n// REFERENCE: \\n// based on this article https://www.daxpatterns.com/standard-time-related-calculations/\\n// \\n// use this to create YtD, PY YtD, and YOY based on same period in the current year\\n\\n//AT LEAST ONE MEASURE HAS TO BE AFFECTED!, \\n//either by selecting it or typing its name in the preSelectedMeasures Variable\\n\\nstring DisplayFolderName = Interaction.InputBox(\\\"Provide the name of the Display Folder\\\", \\\"Display\\\", \\\"KPI\\\");\\nif (DisplayFolderName == \\\"\\\") return;\\n\\nstring[] preSelectedMeasures = {}; //include measure names in double quotes, like: {\\\"Profit\\\",\\\"Total Cost\\\"};\\nstring prefactTableName = \\\"afactKiboMerge\\\";\\nstring prefactTableDateColumnName = \\\"PaymentDate\\\";\\nstring predateTableName = \\\"DimDateDF\\\";\\nstring predateTableDateColumnName = \\\"FullDate\\\";\\nstring predateTableYearColumnName = \\\"Calendar Year\\\";\\nstring affectedMeasures = \\\"{\\\";\\nstring[] AllDATES = {\\n\tprefactTableName,\\n\tprefactTableDateColumnName,\\n\tpredateTableName,\\n\tpredateTableDateColumnName,\\n\tpredateTableYearColumnName\\n};\\nstring factTableName = prefactTableName;\\nstring dateTableName = predateTableName;\\nstring factTableDateColumnName = prefactTableDateColumnName;\\nstring dateTableDateColumnName = predateTableDateColumnName;\\nstring dateTableYearColumnName = predateTableYearColumnName;\\nstring ADYname = \\\"ADY\\\";\\nstring ShowValueForDatesMeasureName = \\\"ShowValueForDates\\\";\\nstring dateTableNameV = dateTableName;\\n\\n string ValueSelected = Interaction.InputBox(\\\"Choose if you want to Select\\\", \\\"Select Columns\\\", \\\"Y\\\");\\nstring ValueSelected = \\\"N\\\";\\nif (ValueSelected == \\\"N\\\") {\\n\tvar factTablea = Model.Tables[factTableName];\\n\tvar dateTablea = Model.Tables[dateTableName];\\n\\n\tvar  = Model.Tables[factTableName].Columns[factTableDateColumnName];\\n\\n\tvar dateTableDateColumn = Model.Tables[dateTableName].Columns[dateTableDateColumnName];\\n\tvar dateTableYearColumn = Model.Tables[dateTableName].Columns[dateTableYearColumnName];\\n} else {\\n\t// Select Tables\\n\tvar factTablen = SelectTable(label: \\\"Select your fact table\\\");\\n\tif (factTablen == null) return;\\n\tvar factTableDateColumn = SelectColumn(factTablen.Columns, label: \\\"Select the main date column\\\");\\n\tif (factTableDateColumn == null) return;\\n\\n\tvar dateTablen = SelectTable(label: \\\"Select your date table\\\");\\n\tif (dateTablen == null) {\\n\t\tError(\\\"You just aborted the script\\\");\\n\t\treturn;\\n\t};\\n\\n\tvar dateTableDateColumn = SelectColumn(dateTablen.Columns, label: \\\"Select the date column\\\");\\n\tif (dateTableDateColumn == null) {\\n\t\tError(\\\"You just aborted the script\\\");\\n\t\treturn;\\n\t};\\n\tvar dateTableYearColumn = SelectColumn(dateTablen.Columns, label: \\\"Select the year column\\\");\\n\tif (dateTableYearColumn == null) return;\\n\tfactTableName = factTablen.Name;\\n\tfactTableDateColumnName = factTableDateColumn.Name;\\n\tdateTableName = dateTablen.Name;\\n\tdateTableDateColumnName = dateTableDateColumn.Name;\\n\tdateTableYearColumnName = dateTableYearColumn.Name;\\n};\\n\\nvar factDateColumnWithTableNA = Model.Tables[factTableName].Columns[factTableDateColumnName];\\nvar dateTable = Model.Tables[dateTableName];\\nvar factTable = Model.Tables[factTableName];\\nvar dateColumnWithTableNA = Model.Tables[dateTableName].Columns[dateTableDateColumnName];\\nvar dateColumnWithTable = dateColumnWithTableNA.DaxObjectFullName;\\nvar factDateColumnWithTable = factDateColumnWithTableNA.DaxObjectFullName;\\n\\nstring dateWithSalesColumnName = \\\"DateWith\\\" + factTable.Name;\\nstring DateWithSalesCalculatedColumnExpression = dateColumnWithTable + \\\" <= MAX ( \\\" + factDateColumnWithTable + \\\")\\\";\\nstring ShowValueForDatesMeasureExpression = \\\"VAR LastDateWithData = \\\" + \\\"    CALCULATE ( \\\" + \\\"        MAX (  \\\" + factDateColumnWithTable + \\\" ), \\\" + \\\"        REMOVEFILTERS () \\\" + \\\"    )\\\" + \\\"VAR FirstDateVisible = \\\" + \\\"    MIN ( \\\" + dateColumnWithTable + \\\" ) \\\" + \\\"VAR Result = \\\" + \\\"    FirstDateVisible <= LastDateWithData \\\" + \\\"RETURN \\\" + \\\"    Result \\\";\\nstring ShowADY = \\\"VAR _LSD = \\\" + \\\"    MAX (  \\\" + factDateColumnWithTable + \\\" ) \\\" + \\\" VAR _LSDPY = \\\" + \\\"    EDATE( \\\" + \\\"        _LSD, \\\" + \\\"        - 12 \\\" + \\\"    )\\\" + \\\" RETURN \\\" + \\\"    \\\" + dateColumnWithTable + \\\"<= _LSDPY \\\";\\n\\nif (!Model.Tables[dateTableName].Columns.Contains(ADYname)) {\\n\tvar ShowValueForDatesADY = dateTable.AddCalculatedColumn(ADYname, ShowADY);\\n\\n\tShowValueForDatesADY.FormatDax();\\n};\\nif (!Model.Tables[dateTableName].Columns.Contains(dateWithSalesColumnName)) {\\n\\n\tvar AddDateSales = dateTable.AddCalculatedColumn(dateWithSalesColumnName, DateWithSalesCalculatedColumnExpression);\\n\tAddDateSales.FormatDax();\\n}\\nif (!Model.Tables[dateTableName].Measures.Contains(ShowValueForDatesMeasureName)) {\\n\tvar ShowValueForDatesMeasure = dateTable.AddMeasure(ShowValueForDatesMeasureName, ShowValueForDatesMeasureExpression);\\n\\n\tShowValueForDatesMeasure.FormatDax();\\n};\\n\\nstring YTDName = \\\" YtD\\\";\\nstring PYYTDName = \\\" PY YtD\\\";\\nstring YOYName = \\\" YoY\\\";\\n\\nstring YTDExpressionFirstPart = \\\"Calculate( \\\";\\nstring YTDEXPRENextPart = \\\" , DATESYTD(\\\" + dateColumnWithTable + \\\"))\\\";\\n\\nstring PYTEXPFirst = \\\" VAR LastDaySelection = \\\" + \\\"    LASTNONBLANK( \\\" + factDateColumnWithTable + \\\", \\\";\\nstring firstBracket = \\\"[\\\";\\nstring PYLMEA = \\\"]\\\";\\nstring FinishPY = \\\")\\\" + \\\" VAR CurrentRange = \\\" + \\\"    DATESBETWEEN( \\\" + dateColumnWithTable + \\\", \\\" + \\\"        MIN( \\\" + factDateColumnWithTable + \\\" ) , \\\" + \\\"        LastDaySelection )\\\" + \\\" VAR PreviousRange = \\\" + \\\"    SAMEPERIODLASTYEAR( CurrentRange ) \\\" + \\\"RETURN \\\" + \\\" IF(LastDaySelection \\\" + \\\"            >= MIN( \\\" + dateColumnWithTable + \\\" ),\\\" + \\\"        CALCULATE( \\\" + firstBracket;\\nstring FinalPiech = PYLMEA + \\\" , \\\" + \\\"            PreviousRange, \\\" + \\\"        \\\" + dateTableName + \\\"[ADY] = TRUE ))\\\";\\n\\nforeach(var mdd in Selected.Measures) {\\n\tstring df = \\\"__\\\" + DisplayFolderName;\\n\tvar MESN = mdd.Table.AddMeasure(\\n\tmdd.Name + YTDName, YTDExpressionFirstPart + mdd.DaxObjectName + YTDEXPRENextPart);\\n\tvar PYTN = mdd.Table.AddMeasure(\\n\tmdd.Name + PYYTDName, PYTEXPFirst + firstBracket + MESN.Name + PYLMEA + FinishPY + mdd.Name + FinalPiech);\\n\tvar YOYNNN = mdd.Table.AddMeasure(\\n\tmdd.Name + YOYName, \\\"Divide((\\\" + MESN.DaxObjectName + \\\" - \\\" + PYTN.DaxObjectName + \\\"), \\\" + PYTN.DaxObjectName + \\\")\\\");\\n\tMESN.DisplayFolder = df;\\n\tPYTN.DisplayFolder = df;\\n\tYOYNNN.DisplayFolder = df;\\n\tMESN.FormatDax();\\n\tPYTN.FormatDax();\\n\tYOYNNN.FormatDax();\\n};\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Dynamic measure selector",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Dynamic measure selector\\n * \\n * Author: Daniel Otykier, twitter.com/DOtykier\\n * \\n * Use this script to auto-generate a disconnected measure selector table\\n * along with a single SWITCH measure, for a selection of measures.\\n * More info: https://tabulareditor.com/2020/08/24/Generating-a-dynamic-measure-selector.html\\n */\\n\\n// (1) Name of disconnected selector table:\\nvar selectorTableName = \\\"Measure Selector\\\";\\n\\n// (2) Name of column on selector table:\\nvar selectorTableColumnName = \\\"Measure\\\";\\n\\n// (3) Name of dynamic switch measure:\\nvar dynamicMeasureName = \\\"Dynamic Measure\\\";\\n\\n// (4) Name of dynamic switch measure's parent table:\\nvar dynamicMeasureTableName = \\\"Measure Selector\\\";\\n\\n// (5) Fallback DAX expression:\\nvar fallbackDax = \\\"BLANK()\\\";\\n\\n// ----- Do not modify script below this line -----\\n\\nif(Selected.Measures.Count == 0) {\\n    Error(\\\"Select one or more measures\\\");\\n    return;\\n}\\n\\n// Get or create selector table:\\nCalculatedTable selectorTable;\\nif(!Model.Tables.Contains(selectorTableName)) Model.AddCalculatedTable(selectorTableName);\\nselectorTable = Model.Tables[selectorTableName] as CalculatedTable;\\n\\n// Get or create dynamic measure:\\nMeasure dynamicMeasure;\\nif(!Model.Tables[dynamicMeasureTableName].Measures.Contains(dynamicMeasureName))\\n    Model.Tables[dynamicMeasureTableName].AddMeasure(dynamicMeasureName);\\ndynamicMeasure = Model.Tables[dynamicMeasureTableName].Measures[dynamicMeasureName];\\n\\n// Generate DAX for disconnected table:\\n// SELECTCOLUMNS({\\\"Measure 1\\\", \\\"Measure 2\\\", ...}, \\\"Measure\\\", [Value])\\nvar selectorTableDax = \\\"SELECTCOLUMNS(\\n    {\\n        \\\" +\\n    string.Join(\\\",\\n        \\\", Selected.Measures.Select(m => \\\"\\\\\"\\\" + m.Name + \\\"\\\\\"\\\").ToArray()) +\\n    \\\"\\n    },\\n    \\\\\"\\\" + selectorTableColumnName + \\\"\\\\\", [Value]\\n)\\\";\\n\\n// Generate DAX for dynamic metric:\\n// VAR _s = SELECTEDVALUE('Metric Selection'[Value]) RETURN SWITCH(_s, ...)\\nvar dynamicMeasureDax = \\n    \\\"VAR _s =\\n    SELECTEDVALUE('\\\" + selectorTableName + \\\"'[\\\" + selectorTableColumnName + \\\"])\\n\\\" +\\n    \\\"RETURN\\n    SWITCH(\\n        _s,\\n        \\\" +\\n    string.Join(\\\",\\n        \\\", Selected.Measures.Select(m => \\\"\\\\\"\\\" + m.Name + \\\"\\\\\", \\\" + m.DaxObjectFullName).ToArray()) +\\n    \\\",\\n        \\\" + fallbackDax + \\\"\\n    )\\\";\\n\\n// Assign DAX expressions:\\nselectorTable.Expression = selectorTableDax;\\ndynamicMeasure.Expression = dynamicMeasureDax;",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\New Measure Choice Selector",
      "Enabled": "true",
      "Execute": "\\n// Create visuals translations measures \\n// Author: Tommy Puglia powerbi.tips/podcast\\n// This script creates a pop-up form that provides the calculation type and the format to apply to muliptple columns\\n// You can use this to create new measures with currency, or even percentage. Choose Sum, Average, or Count. \\n// Note that the form pop up is not pretty, but it works.\\n\\n\\n#r \\\"System.Drawing\\\"\\n\\nusing System.Drawing;\\nusing System.Windows.Forms;\\n\\nSystem.Windows.Forms.Form newForm = new System.Windows.Forms.Form();\\n\\nSystem.Windows.Forms.Panel midPanel = new System.Windows.Forms.Panel();\\nSystem.Windows.Forms.Panel topMidPanel = new System.Windows.Forms.Panel();\\nSystem.Windows.Forms.RadioButton newmodelButton = new System.Windows.Forms.RadioButton();\\nSystem.Windows.Forms.RadioButton Measure = new System.Windows.Forms.RadioButton();\\nSystem.Windows.Forms.Button goButton = new System.Windows.Forms.Button();\\nSystem.Windows.Forms.TextBox enterTextBox = new System.Windows.Forms.TextBox();\\nSystem.Windows.Forms.ComboBox enterComboBox = new System.Windows.Forms.ComboBox();\\nSystem.Windows.Forms.ComboBox enterCurrency = new System.Windows.Forms.ComboBox();\\nSystem.Windows.Forms.Button JustMeasuresButton = new System.Windows.Forms.Button();\\n\\n\\nint startScreenX = 230;\\nint startScreenY = 150;\\n//EnterCombo\\n// Enter Combo Box\\nenterComboBox.Visible = true;\\nenterComboBox.Size = new Size(100,40);\\nenterComboBox.Location = new Point(startScreenX+44,startScreenY+44);\\nenterComboBox.Items.Add(\\\"Average\\\");\\nenterComboBox.Items.Add(\\\"Sum\\\");\\nenterComboBox.Items.Add(\\\"CountRows\\\");\\nenterComboBox.Items.Add(\\\"CountDistinct\\\");\\n\\n// Enter Combo Box\\nenterCurrency.Visible = true;\\nenterCurrency.Size = new Size(100,40);\\nenterCurrency.Location = new Point(startScreenX+33,startScreenY+20);\\nenterCurrency.Items.Add(\\\"$\\\");\\nenterCurrency.Items.Add(\\\"Number\\\");\\nenterCurrency.Items.Add(\\\"%\\\");\\n\\n//Choice\\n\\n//NE\\nint formWidth = 1000;\\nint formHeight = 700;\\nnewForm.TopMost = true;\\nnewForm.Text = \\\"Create Measures Button\\\";\\nnewForm.Size = new Size(formWidth,formHeight);\\n\\n// New Model Button\\ngoButton.Size = new Size(100,25);\\ngoButton.Location = new Point(startScreenX+25,startScreenY+80);\\ngoButton.Text = \\\"Go\\\";\\ngoButton.Visible = true;\\ngoButton.Enabled = true; \\n\\n// New Model Button\\nJustMeasuresButton.Size = new Size(100,25);\\nJustMeasuresButton.Location = new Point(startScreenX+15,startScreenY+60);\\nJustMeasuresButton.Text = \\\"Just Measures\\\";\\nJustMeasuresButton.Visible = true;\\nJustMeasuresButton.Enabled = true; \\n\\nstring calType = string.Empty;\\nstring forType = string.Empty;\\nstring formatString = string.Empty;\\n\\ngoButton.Click += (sender2, e2) => {\\n\\n    calType = enterComboBox.Text;\\n    forType = enterCurrency.Text;\\n    if( forType == \\\"$\\\")\\n    {\\n        formatString = \\\"$ #,##0\\\";\\n    }\\n    else if (forType == \\\"%\\\")\\n    {\\n        formatString = \\\"0.0%\\\";\\n    }\\n    else \\n    {\\n        formatString = \\\"#,0\\\";\\n        \\n    }\\n    if(calType == \\\"Average\\\")\\n    {\\n\\n    foreach(var c in Selected.Columns)\\n    {\\n        var newMeasure = c.Table.AddMeasure(\\n        \\\"Avg. \\\" + c.Name,                    // Name\\n        \\\"Average(\\\" + c.DaxObjectFullName + \\\")\\\"   // DAX expression\\n                         // Display Folder\\n    );\\n    newMeasure.FormatString = formatString;\\n    c.IsHidden = true;\\n    newMeasure.DisplayFolder = \\\"_KPI\\\";\\n    }\\n    }\\n    else if (calType == \\\"Sum\\\")\\n    {\\n    foreach(var c in Selected.Columns)\\n    {\\n        var newMeasure = c.Table.AddMeasure(\\n        \\\"Total \\\" + c.Name,                    // Name\\n        \\\"SUM(\\\" + c.DaxObjectFullName + \\\")\\\"\\n        // DAX expression\\n                            // Display Folder\\n    );\\n\\n        newMeasure.FormatString = formatString;\\n        newMeasure.DisplayFolder = \\\"_KPI\\\";\\n\\n        c.IsHidden = true;\\n\\n    }   \\n    }\\n      else if (calType == \\\"CountRows\\\")\\n    {\\n    foreach(var c in Selected.Columns)\\n    {\\n        var newMeasure = c.Table.AddMeasure(\\n        \\\"Count of \\\" + c.Name,                    // Name\\n        \\\"COUNTROWS(\\\" + c.Table + \\\")\\\"\\n        // DAX expression\\n                            // Display Folder\\n    );\\n\\n        newMeasure.FormatString = formatString;\\n        newMeasure.DisplayFolder = \\\"_KPI\\\";\\n\\n        c.IsHidden = true;\\n\\n    }   \\n    }\\n    else \\n    {\\n    foreach(var c in Selected.Columns)\\n    {\\n        var newMeasure = c.Table.AddMeasure(\\n        \\\"Distinct \\\" + c.Name,                    // Name\\n        \\\"DISTINCTCOUNT(\\\" + c.DaxObjectFullName + \\\")\\\"\\n        // DAX expression\\n                            // Display Folder\\n    );\\n\\n        newMeasure.FormatString = formatString;\\n        newMeasure.DisplayFolder = \\\"_KPI\\\";\\n\\n        c.IsHidden = true;\\n\\n    }   \\n    }\\n};\\nJustMeasuresButton.Click += (sender3, e3) => {\\n\\n\\n    forType = enterCurrency.Text;\\n    if( forType == \\\"$\\\")\\n    {\\n        formatString = \\\"$ #,##0\\\";\\n    }\\n    else if (forType == \\\"%\\\")\\n    {\\n        formatString = \\\"0.0%\\\";\\n    }\\n    else \\n    {\\n        formatString = \\\"#,0\\\";\\n        \\n    }\\n\\n    foreach(var c in Selected.Measures)\\n    {\\n\\n    c.FormatString = formatString;\\n    }\\n    };\\n\\n\\n\\n\\nstring perspName = string.Empty;\\n\\nnewForm.Controls.Add(midPanel);\\nnewForm.Controls.Add(topMidPanel);\\nnewForm.Controls.Add(goButton);\\nnewForm.Controls.Add(enterTextBox);\\nnewForm.Controls.Add(Measure);\\nnewForm.Controls.Add(newmodelButton);\\nnewForm.Controls.Add(enterComboBox);\\nnewForm.Controls.Add(enterCurrency);\\nnewForm.Controls.Add(JustMeasuresButton);\\nnewForm.Show();",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Replace Text Strings that appear in any Measure Expression",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Replace Text Strings that appear in many measures\\n * \\n * Author: Matt Allington http://xbi.com.au\\n * \\n * This script, when executed, will loop through the currently selected measures\\n * and replace the FromString with the ToString.\\n */\\n\\n// Replace Text Strings that appear in many measures\\n\\n    // String of text that is desired to be found\\n    // Update the value of the text for your desired usecase\\n    // This replacement example shows the replacement of a DAX expression and replaces the SUM(table[ColumnName]) with a well defined measure of [Total Sales]\\n    // It is best practice to use a single measure for Sum of Extended Amount and reference this measure in other DAX formulas. \\n\tvar FromString = \\\"CALCULATE(SUM(Sales[ExtendedAmount])\\\";\\n\\n    // String of text that is the replaced value\\n    // Update the value of the text for your desired usecase\\n\tvar ToString = \\\"CALCULATE([Total Sales])\\\";\\n\\n\tforeach (var m in Model.AllMeasures)\\n    \t{\\n           m.Expression = m.Expression.Replace(FromString,ToString);\\n    \t}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Intermediate\\Search and Replace Matched Pairs of Strings in Selected Measures",
      "Enabled": "true",
      "Execute": "/*\\n * Title: Multi-string Search and Replace in any selected measure\\n * \\n * Author: Dan Meissner\\n * \\n * This script iterates through all currently-selected measures, using the matched pairs of strings\\n * in the 2-D array named \\\"ReplacementPair\\\" below as a template, replacing all instances of \\\"FromStringX\\\"\\n * in the current measure's DAX expression with the corresponding \\\"ToStringX\\\"\\n *\\n */\\n\\n// Replace Text Strings Pairs that appear in selected measures\\n\\n    // Update the value of the text arrays for your desired usecase. Make sure to structure the list as:\\n    // var ReplacementPair  = new string[,] {{\\\"FromString1\\\",\\\"ToString1\\\"},{\\\"FromString2\\\",\\\"ToString2\\\"},{\\\"FromString3\\\",\\\"ToString3\\\"}};\\n\t\\n\t// Add as many From and To pairs to the array as needed. \\n\t// (technically C# has a 2GB memory size and 4 Billion array item limit, but... really...)\\n\\n    // If the string you are either searching for or replacing with contains a double quote \\\" then you need to 'escape it' by \\n    // preceding it with a backslash (as in \\\\\") to have that quote character within the respective text string\\n\\n\tvar ReplacementPair  = new string[,] { {\\\"FromString1\\\",\\\"ToString1\\\"},\\n                                           {\\\"FromString2\\\",\\\"ToString2\\\"},\\n                                           {\\\"FromString3\\\",\\\"ToString3\\\"} };\\n\\n\tforeach (var m in Selected.Measures)\\n    \t{\\n           for (int i=0; i < ReplacementPair.GetLength(0);)\\n            {\\n                m.Expression = m.Expression.Replace(ReplacementPair[i,0],ReplacementPair[i,1]);\\n                i++;\\n            }\\n    \t}\\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "TabularEditor-Scripts-main\\Tabular Editor 2\\Power BI Model Refresh Cancel",
      "Enabled": "true",
      "Execute": "// Force stops a refresh in the Power-BI service for the specified model. \\n// Important – When cancelling a refresh, remember the service will perform a re-try 3 times. \\n// You will need to cancel the refresh 3 times. When a refresh is cancelled it may take a couple minutes before \\n// the re-try kicks in and a new process is started. \\n \\n \\n#r \\\"Microsoft.AnalysisServices.Core.dll\\\" \\n \\nvar DMV_Cmd = ExecuteDax(\\\"SELECT [SESSION_ID],[SESSION_LAST_COMMAND] FROM $SYSTEM.DISCOVER_SESSIONS\\\").Tables[0]; \\nbool runTMSL = true; \\nstring databaseID = Model.Database.ID; \\nstring databaseName = Model.Database.Name; \\nstring sID = string.Empty; \\n \\nfor (int r = 0; r < DMV_Cmd.Rows.Count; r++) \\n{ \\n    string sessionID = DMV_Cmd.Rows[r][0].ToString(); \\n    string cmdText = DMV_Cmd.Rows[r][1].ToString(); \\n     \\n    // Capture refresh command for the database \\n    if (cmdText.StartsWith(\\\"<Batch Transaction=\\\") && cmdText.Contains(\\\"<Refresh xmlns\\\") && cmdText.Contains(\\\"<DatabaseID>\\\"+databaseID+\\\"</DatabaseID>\\\")) \\n    { \\n        sID = sessionID; \\n    }       \\n} \\n \\nif (sID == string.Empty) \\n{ \\n    Error(\\\"No processing Session ID found for the '\\\"+databaseName+\\\"' model.\\\"); \\n    return; \\n} \\n \\nif (runTMSL) \\n{ \\n    Model.Database.TOMDatabase.Server.CancelSession(sID); \\n    Info(\\\"Processing for the '\\\"+databaseName+\\\"' model has been cancelled (Session ID: \\\"+sID+\\\").\\\"); \\n} \\nelse \\n{ \\n    sID.Output(); \\n} ",
      "Tooltip": "",
      "ValidContexts": "Model"
    }
  ]
}