{
  "Actions": [
    {
      "Name": "DoneIn60seconds-main\\1. Create calculated date table",
      "Enabled": "true",
      "Execute": "// Adapted from https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/import-model-only/create-date-table.csx\r\n// This script works in Tabular Editor 2\r\n\r\n// It is modified by including other naming convention and other columns, like ISO Week\r\n\r\n// 1. Select the column with the earliest date\r\n// 2. Select the column with the latest date\r\n// 3. Script generates a calculated table with rich date metadata\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime).ToList();\r\n\r\nstring _EarliestDateInput;\r\ntry\r\n{\r\n    _EarliestDateInput = SelectColumn(_dateColumns, null, \"Select the Column with the Earliest Date:\").DaxObjectFullName;\r\n}\r\ncatch\r\n{\r\n    Error(\"Earliest column not selected! Script stopped.\");\r\n    return;\r\n}\r\n\r\nstring _LatestDateInput;\r\ntry\r\n{\r\n    _LatestDateInput = SelectColumn(_dateColumns, null, \"Select the Column with the Latest Date:\").DaxObjectFullName;\r\n}\r\ncatch\r\n{\r\n    Error(\"Latest column not selected! Script stopped.\");\r\n    return;\r\n}\r\n\r\ntry\r\n{\r\n    string _RefDateMeasureLogic = string.Format(\"CALCULATE ( MAX ( {0} ), REMOVEFILTERS ( ) )\", _LatestDateInput);\r\n\r\n    string _DateDaxExpression = string.Format(@\"\r\nVAR _Today = TODAY ()\r\n\r\nVAR _EarliestDate = DATE ( YEAR ( MIN ( {0} ) ), 1, 1 )\r\nVAR _EarliestDate_Safe = MIN ( _EarliestDate, DATE ( YEAR ( _Today ), 1, 1 ) )\r\n\r\nVAR _LatestDate = DATE ( YEAR ( MAX ( {1} ) ), 12, 31 )\r\nVAR _LatestDate_Safe = MAX ( _LatestDate, DATE ( YEAR ( _Today ), 12, 31 ) )\r\n\r\nVAR _Base_Calendar = CALENDAR ( _EarliestDate_Safe, _LatestDate_Safe )\r\n\r\nVAR _IntermediateResult =\r\n    ADDCOLUMNS (\r\n        _Base_Calendar,\r\n        \"\"Year\"\", YEAR ( [Date] ),\r\n        \"\"Quarter no\"\", QUARTER ( [Date] ),\r\n        \"\"Quarter\"\", \"\"Q\"\" & CONVERT ( QUARTER ( [Date] ), STRING ),\r\n        \"\"Year quarter\"\", CONVERT ( YEAR ( [Date] ), STRING ) & \"\" Q\"\" & CONVERT ( QUARTER ( [Date] ), STRING ),\r\n        \"\"Month no\"\", MONTH ( [Date] ),\r\n        \"\"Month name\"\", FORMAT ( [Date], \"\"MMMM\"\" ),\r\n        \"\"Month short name\"\", FORMAT ( [Date], \"\"MMM\"\" ),\r\n        \"\"Year month\"\", CONVERT ( YEAR ( [Date] ), STRING ) & \"\"-\"\" & FORMAT ( MONTH ( [Date] ), \"\"00\"\" ),\r\n        \"\"Year month no\"\", YEAR ( [Date] ) * 100 + MONTH ( [Date] ),\r\n        \"\"Month name Year\"\", FORMAT ( [Date], \"\"MMM YY\"\" ),\r\n        \"\"ISO week\"\", WEEKNUM ( [Date], 21 ),\r\n        \"\"ISO year\"\", YEAR ( [Date] + (26 - WEEKNUM ( [Date], 21 )) ),\r\n        \"\"Day name\"\", FORMAT ( [Date], \"\"DDDD\"\" ),\r\n        \"\"Day no of Week\"\", WEEKDAY ( [Date], 3 ),\r\n        \"\"Day no of Month\"\", DAY ( [Date] ),\r\n        \"\"Date_Key\"\", YEAR ( [Date] ) * 10000 + MONTH ( [Date] ) * 100 + DAY ( [Date] ),\r\n        \"\"Year slicer\"\", IF ( YEAR ( [Date] ) = YEAR ( TODAY() ), \"\"Current Year\"\", CONVERT ( YEAR ( [Date] ), STRING ) ),\r\n        \"\"Year month slicer\"\", IF ( AND ( MONTH ( [Date] ) = MONTH ( TODAY() ), YEAR ( [Date] ) = YEAR ( TODAY() ) ), \"\"Current month\"\", CONVERT ( YEAR ( [Date] ), STRING ) & \"\"-\"\" & FORMAT ( MONTH ( [Date] ), \"\"00\"\" ) ),\r\n        \"\"Date slicer\"\", IF ( [Date] = TODAY(), \"\"Today\"\", IF ( [Date] = TODAY() - 1, \"\"Yesterday\"\", CONVERT ( [Date], STRING ) ) ),\r\n        \"\"is_History\"\", IF ( [Date] <= TODAY(), 1, 0 ),\r\n        \"\"is_Weekend\"\", WEEKDAY ( [Date], 3 ) IN {{5,6}}\r\n    )\r\n\r\nVAR _Result =\r\n    ADDCOLUMNS (\r\n        _IntermediateResult,\r\n        \"\"ISO year week\"\", CONVERT ( [ISO year], STRING ) & \"\"-W\"\" & FORMAT ( [ISO week], \"\"00\"\" ),\r\n        \"\"Week slicer\"\",\r\n            VAR CurrentDate = TODAY()\r\n            VAR ThursdayOfWeek = CurrentDate + (3 - WEEKDAY ( CurrentDate, 2 ))\r\n            VAR ThursdayToday = YEAR ( ThursdayOfWeek )\r\n            RETURN IF (\r\n                AND (\r\n                    ThursdayToday = [ISO year],\r\n                    WEEKNUM ( TODAY(), 21 ) = [ISO week]\r\n                ),\r\n                \"\"Current week\"\",\r\n                CONVERT ( [ISO year], STRING ) & \"\"-W\"\" & FORMAT ( [ISO week], \"\"00\"\" )\r\n            )\r\n    )\r\nRETURN _Result\", _EarliestDateInput, _LatestDateInput);\r\n\r\n    // Create calculated table\r\n    var _date = Model.AddCalculatedTable(\"Calendar\", _DateDaxExpression);\r\n\r\n    // Mark as date table and assign group\r\n    _date.DataCategory = \"Time\";\r\n\r\n    // Remove summarization from int columns\r\n    foreach (var column in _date.Columns.Where(c => c.DataType == DataType.Int64))\r\n        column.SummarizeBy = AggregateFunction.None;\r\n\r\n    // Apply date format to datetime columns\r\n    foreach (var column in _date.Columns.Where(c => c.DataType == DataType.DateTime))\r\n        column.FormatString = \"mm/dd/yyyy\";\r\n\r\n    Info(string.Format(\"Created a new, organized 'Calendar' table.\\nEarliest Date: {0}\\nLatest Date: {1}\", _EarliestDateInput, _LatestDateInput));\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Error(\"An unexpected error occurred while creating the Calendar table: \" + ex.Message);\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\1. Create calculated measure table",
      "Enabled": "true",
      "Execute": "using System;\r\nusing System.Windows.Forms;\r\nusing System.Linq;\r\n\r\npublic class InputDialog\r\n{\r\n    public static string ShowInputDialog(string text, string caption, string defaultValue)\r\n    {\r\n        Form prompt = new Form()\r\n        {\r\n            Width = 600,\r\n            Height = 150,\r\n            FormBorderStyle = FormBorderStyle.FixedDialog,\r\n            Text = caption,\r\n            StartPosition = FormStartPosition.CenterScreen\r\n        };\r\n        Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n        TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n        Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n        confirmation.Click += (sender, e) => { prompt.Close(); };\r\n        prompt.Controls.Add(textLabel);\r\n        prompt.Controls.Add(textBox);\r\n        prompt.Controls.Add(confirmation);\r\n        prompt.AcceptButton = confirmation;\r\n\r\n        return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n    }\r\n}\r\n\r\nApplication.UseWaitCursor = false;\r\n\r\nstring defaultTableName = \"Model Measures\";\r\nstring tableName = InputDialog.ShowInputDialog(\"Enter name for the measure table:\", \"Create Measure Table\", defaultTableName);\r\n\r\nif (string.IsNullOrWhiteSpace(tableName))\r\n{\r\n    Info(\"Table name was not provided. Operation cancelled.\");\r\n    return;\r\n}\r\n\r\n// Check if table already exists\r\nif (Model.Tables.Any(t => t.Name == tableName))\r\n{\r\n    Info(\"A table named '\" + tableName + \"' already exists. No action taken.\");\r\n    return;\r\n}\r\n\r\ntry\r\n{\r\n    string daxTable = \"DATATABLE(\\\"MeasureName\\\", STRING, {{\\\"Default Measure\\\"}})\";\r\n    var newTable = Model.AddCalculatedTable(tableName, daxTable);\r\n\r\n    if (newTable != null)\r\n    {\r\n        newTable.Description = \"Table to collect measures\";\r\n        foreach (var col in newTable.Columns)\r\n        {\r\n            col.IsHidden = true;\r\n        }\r\n\r\n        //  Info(\"Successfully created calculated table '\" + tableName + \"' for storing measures.\");\r\n    }\r\n    else\r\n    {\r\n        Info(\"Failed to create the calculated table '\" + tableName + \"'.\");\r\n    }\r\n}\r\ncatch (Exception ex)\r\n{\r\n    Info(\"Error during calculated table creation:\\n\\n\" + ex.Message);\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\2. Mark as date-table and create measures and relationship",
      "Enabled": "true",
      "Execute": "\r\n // Title: Initial formatting of Date-Table\r\n // \r\n // Author: Eivind Haugen\r\n // \r\n // This script, when executed, will perform necessary and generic operations for a date table. The following steps are applied:\r\n // 1. Select the date column and mark it as a date-table\r\n // 2. Create measures that later can be applied to hide future dates in time calculation, either by:\r\n //        2a: The minimum of the selected date in the applied filter from the calendar or today\r\n //        2b: Last fact date, selected date from a fact table\r\n // 3. Setting up relationship to a fact table, the same date used as the last fact date\r\n //          NB! If more fact-tables, it will have to be done manually\r\n // 4. Apply best practice:\r\n //       4a: Ensure that numeric columns are not summarized\r\n //       4b: Apply a format string for the date-columns MM/DD/YYYY (as this is the condition in best-practice analyzer) \r\n \r\n\r\n\r\n\r\nusing System.Windows.Forms;\r\nScriptHelper.WaitFormVisible = false;\r\n\r\n// Use the selected table from the UI\r\nif (Selected.Table == null)\r\n{\r\n    Error(\"No table selected in the UI. Please select a table before running the script.\");\r\n    return;\r\n}\r\n\r\nstring _CalendarTable = Selected.Table.Name;\r\n    try\r\n    {\r\n        // Select a column to mark as date key\r\n        var _dateTableColumns = Model.AllColumns\r\n            .Where(col => col.Table.Name == _CalendarTable && col.DataType == DataType.DateTime)\r\n            .ToList();\r\n\r\n        if (_dateTableColumns.Count == 0)\r\n        {\r\n            Error(\"No columns with a valid date format found in the selected table.\");\r\n            return;\r\n        }\r\n\r\n        string _dateColumn = SelectColumn(_dateTableColumns, null, \"Select date-key to mark as date table\").DaxObjectFullName;\r\n\r\n        string _selectedColumnName = _dateColumn.Split('[', ']')[1];\r\n        string _CalendarTableName = _dateColumn.Split('\\'')[1];\r\n\r\n        Model.Tables[_CalendarTable].DataCategory = \"Time\";\r\n        Model.Tables[_CalendarTable].Columns[_selectedColumnName].IsKey = true;\r\n\r\n        // Select date column from a fact table\r\n        var otherTables = Model.Tables.Where(t => t.DataCategory != \"Time\");\r\n        var _dateOtherTables = otherTables\r\n            .SelectMany(t => t.Columns)\r\n            .Where(c => c.DataType == DataType.DateTime)\r\n            .ToList();\r\n\r\n            string _factDateCalendar = SelectColumn(_dateOtherTables, null, \"Select date from fact-table to Create Measure for the Last date\").DaxObjectFullName;\r\n        string _FactTable = _factDateCalendar.Split('[')[0].Trim('\\'');\r\n\r\n        // Measure 1: Max Calendar Date\r\n        string measureExpression = string.Format(\"MIN(MAX({0}), TODAY())\", _dateColumn);\r\n        string normalizedExpression = measureExpression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\");\r\n\r\n        bool measureExists = Model.AllMeasures.Any(m =>\r\n            m.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == normalizedExpression\r\n        );\r\n\r\n        if (!measureExists)\r\n        {\r\n            var measure1 = Model.Tables[_CalendarTable].AddMeasure(\"Max Calendar date\");\r\n            measure1.DisplayFolder = \"0. Date Control measures\";\r\n            measure1.FormatString = \"dd-MM-yyyy\";\r\n            measure1.Description = \"The last date selected from a slicer from calendar. Setting today() if last date is after today's date.\";\r\n            measure1.Expression = measureExpression;\r\n        }\r\n\r\n        // Measure 2: Last Fact Table Date\r\n        string transactionMeasureExpression = string.Format(\"CALCULATE(MAX({0}), ALL ('{1}'))\", _factDateCalendar, _FactTable);\r\n        string normalizedTransactionExpression = transactionMeasureExpression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\");\r\n\r\n        bool transactionMeasureExists = Model.AllMeasures.Any(m =>\r\n            m.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == normalizedTransactionExpression\r\n        );\r\n\r\n        if (!transactionMeasureExists)\r\n        {\r\n            var measure2 = Model.Tables[_CalendarTable].AddMeasure(\"Last fact table date\");\r\n            measure2.DisplayFolder = \"0. Date Control measures\";\r\n            measure2.FormatString = \"dd-MM-yyyy\";\r\n            measure2.Description = \"The last fact table date.\";\r\n            measure2.Expression = transactionMeasureExpression;\r\n        }\r\n\r\n        // Apply best practices\r\n        foreach (var column in Model.Tables[_CalendarTable].Columns)\r\n        {\r\n            if (column.DataType == DataType.Int64)\r\n                column.SummarizeBy = AggregateFunction.None;\r\n        }\r\n\r\n        // Create Relationship (only if not exists)\r\n        string _factDateColumnName = _factDateCalendar.Split('[')[1].TrimEnd(']');\r\n        var existingRelationship = Model.Relationships.FirstOrDefault(rel =>\r\n            rel.ToTable.Name == _CalendarTableName &&\r\n            rel.ToColumn.Name == _selectedColumnName\r\n        );\r\n\r\nif (existingRelationship == null)\r\n{\r\n    string message = string.Format(\r\n        \"No existing relationship found between '{0}'[{1}] and '{2}'[{3}].\\n\\nDo you want to create it?\",\r\n        _FactTable, _factDateColumnName, _CalendarTableName, _selectedColumnName\r\n    );\r\n\r\n    var result = MessageBox.Show(\r\n        message,\r\n        \"Create Relationship?\",\r\n        MessageBoxButtons.YesNo,\r\n        MessageBoxIcon.Question\r\n    );\r\n\r\n    if (result == DialogResult.Yes)\r\n    {\r\n        var calendarTable = Model.Tables[_CalendarTableName];\r\n        var factTable = Model.Tables[_FactTable];\r\n        var fromColumn = factTable.Columns[_factDateColumnName];\r\n        var toColumn = calendarTable.Columns[_selectedColumnName];\r\n\r\n        if (fromColumn != null && toColumn != null)\r\n        {\r\n            var rel = Model.AddRelationship();\r\n            rel.FromColumn = fromColumn;\r\n            rel.ToColumn = toColumn;\r\n            rel.FromCardinality = RelationshipEndCardinality.Many;\r\n            rel.ToCardinality = RelationshipEndCardinality.One;\r\n            rel.IsActive = true;\r\n\r\n            Output(string.Format(\r\n                \"Relationship created between '{0}'[{1}] and '{2}'[{3}].\",\r\n                _FactTable, _factDateColumnName, _CalendarTableName, _selectedColumnName\r\n            ));\r\n        }\r\n        else\r\n        {\r\n            Error(\"Could not find valid columns to create the relationship.\");\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Output(\"User chose not to create the relationship.\");\r\n    }\r\n}\r\nelse\r\n{\r\n    Output(\"Relationship already exists between calendar and fact table.\");\r\n}\r\n\r\n    }\r\n    catch\r\n    {\r\n        Error(\"No date-key selected to mark as date table.\");\r\n    }\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\2. Organize Calculated date-table",
      "Enabled": "true",
      "Execute": "// Script to perform maintenance on the date-table in the Contoso dataset.\r\n// Needs a table on the same format with the same columns, or it needs to be modified\r\n\r\n\r\n// Hide the 'Running Macro' spinbox\r\nScriptHelper.WaitFormVisible = false;\r\n\r\nif (Selected.Table == null)\r\n{\r\n    Error(\"No table selected in the UI. Please select a date table before running the script.\");\r\n    return;\r\n}\r\n\r\nstring _CalendarTable = Selected.Table.Name;\r\n\r\ntry\r\n{\r\n    var table = Model.Tables[_CalendarTable];\r\n\r\n    // Sorting\r\n     table.Columns[\"Month name\"].SortByColumn = table.Columns[\"Month no\"];\r\n        table.Columns[\"Month short name\"].SortByColumn = table.Columns[\"Month no\"];\r\n        table.Columns[\"Year month\"].SortByColumn = table.Columns[\"Year month no\"];\r\n        table.Columns[\"Month name Year\"].SortByColumn = table.Columns[\"Year month no\"];\r\n        table.Columns[\"Day name\"].SortByColumn = table.Columns[\"Day no of week\"];\r\n        table.Columns[\"Year slicer\"].SortByColumn = table.Columns[\"Year\"];\r\n        table.Columns[\"Year month slicer\"].SortByColumn = table.Columns[\"Year month no\"];\r\n        table.Columns[\"Week slicer\"].SortByColumn = table.Columns[\"ISO year week\"];\r\n        table.Columns[\"Date slicer\"].SortByColumn = table.Columns[\"Date\"];\r\n    \r\n        // Sisplay Folders\r\n    string slicerFolder = \"1. Slicer\";\r\n    string yearFolder = \"2. Year\";\r\n    string quarterFolder = \"3. Quarter\";\r\n    string monthFolder = \"4. Month\";\r\n    string weekFolder = \"5. Week\";\r\n    string dateFolder = \"6. Date\";\r\n    string dayFolder = \"7. Day\";\r\n    string booleanFolder = \"8. Boolean\";\r\n\r\n    // Slicer\r\n    table.Columns[\"Year slicer\"].DisplayFolder = slicerFolder;\r\n    table.Columns[\"Year month slicer\"].DisplayFolder = slicerFolder;\r\n    table.Columns[\"Week slicer\"].DisplayFolder = slicerFolder;\r\n    table.Columns[\"Date slicer\"].DisplayFolder = slicerFolder;\r\n\r\n    // Year\r\n    table.Columns[\"Year\"].DisplayFolder = yearFolder;\r\n\r\n    // Quarter\r\n    table.Columns[\"Quarter\"].DisplayFolder = quarterFolder;\r\n    table.Columns[\"Quarter no\"].DisplayFolder = quarterFolder;\r\n    table.Columns[\"Year quarter\"].DisplayFolder = quarterFolder;\r\n\r\n    // Month\r\n    table.Columns[\"Month no\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Month name\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Month short name\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Year month\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Year month no\"].DisplayFolder = monthFolder;\r\n    table.Columns[\"Month name Year\"].DisplayFolder = monthFolder;\r\n\r\n    // Week\r\n    table.Columns[\"ISO week\"].DisplayFolder = weekFolder;\r\n    table.Columns[\"ISO year\"].DisplayFolder = weekFolder;\r\n    table.Columns[\"ISO year week\"].DisplayFolder = weekFolder;\r\n\r\n    // Date\r\n    table.Columns[\"Date\"].DisplayFolder = dateFolder;\r\n    table.Columns[\"Date_Key\"].DisplayFolder = dateFolder;\r\n\r\n    // Day\r\n    table.Columns[\"Day name\"].DisplayFolder = dayFolder;\r\n    table.Columns[\"Day no of Week\"].DisplayFolder = dayFolder;\r\n    table.Columns[\"Day no of Month\"].DisplayFolder = dayFolder;\r\n\r\n    // Boolean\r\n    table.Columns[\"is_History\"].DisplayFolder = booleanFolder;\r\n    table.Columns[\"is_Weekend\"].DisplayFolder = booleanFolder;\r\n\r\n    // Format Strings\r\n    table.Columns[\"Date\"].FormatString = \"mm/dd/yyyy\";\r\n    table.Columns[\"Date_Key\"].FormatString = \"0\";\r\n    table.Columns[\"Day no of Month\"].FormatString = \"0\";\r\n    table.Columns[\"Day no of Week\"].FormatString = \"0\";\r\n    table.Columns[\"is_History\"].FormatString = \"0\";\r\n    table.Columns[\"ISO week\"].FormatString = \"0\";\r\n    table.Columns[\"ISO year\"].FormatString = \"0\";\r\n    table.Columns[\"Month no\"].FormatString = \"0\";\r\n    table.Columns[\"Quarter no\"].FormatString = \"0\";\r\n    table.Columns[\"Year\"].FormatString = \"0\";\r\n    table.Columns[\"Year month no\"].FormatString = \"0\";\r\n\r\n    // Hide Unused Columns\r\n    table.Columns[\"Date_Key\"].IsHidden = true;\r\n    table.Columns[\"Date_Key\"].IsAvailableInMDX = false;\r\n\r\n    // Column Descriptions\r\n    table.Columns[\"Date\"].Description = \"YYYY-MM-DD\";\r\n    table.Columns[\"Date_Key\"].Description = \"YYYYMMDD\";\r\n    table.Columns[\"Date slicer\"].Description = \"Today, yesterday or date\";\r\n\r\n    table.Columns[\"Year\"].Description = \"YYYY\";\r\n    table.Columns[\"Year slicer\"].Description = \"Current year, or YYYY\";\r\n\r\n    table.Columns[\"Quarter no\"].Description = \"1, 2, 3 or 4\";\r\n    table.Columns[\"Quarter\"].Description = \"e.g., Q1\";\r\n    table.Columns[\"Year quarter\"].Description = \"2024 Q1\";\r\n\r\n    table.Columns[\"Month no\"].Description = \"MM\";\r\n    table.Columns[\"Month name\"].Description = \"e.g., January\";\r\n    table.Columns[\"Month short name\"].Description = \"e.g., Jan\";\r\n    table.Columns[\"Year month\"].Description = \"YYYY-MM\";\r\n    table.Columns[\"Year month no\"].Description = \"YYYYMM\";\r\n    table.Columns[\"Month name Year\"].Description = \"e.g., Jan 2024\";\r\n    table.Columns[\"Year month slicer\"].Description = \"Current month or YYYY-MM\";\r\n\r\n    table.Columns[\"ISO year\"].Description = \"ISO year (YYYY)\";\r\n    table.Columns[\"ISO week\"].Description = \"ISO week number\";\r\n    table.Columns[\"ISO year week\"].Description = \"e.g., 2024 W01\";\r\n    table.Columns[\"Week slicer\"].Description = \"Current week or ISO year week\";\r\n\r\n    table.Columns[\"Day no of Month\"].Description = \"Day number 1-31\";\r\n    table.Columns[\"Day no of Week\"].Description = \"0=Monday to 6=Sunday\";\r\n    table.Columns[\"Day name\"].Description = \"e.g., Monday\";\r\n\r\n    table.Columns[\"is_Weekend\"].Description = \"1 if weekend, else 0\";\r\n    table.Columns[\"is_History\"].Description = \"1 if today or earlier\";\r\n\r\n    // 8. Table description\r\n    table.Description = \"Date-table\";\r\n}\r\ncatch\r\n{\r\n    Error(\"No selected date-table or see if column definitions are matching => No formatting\");\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\2. Organize Contoso date-table",
      "Enabled": "true",
      "Execute": "// Script to perform maintenance on the date-table in the Contoso dataset.\r\n// Needs a table on the same format with the same columns, or it needs to be modified\r\n\r\n\r\n// Hide the 'Running Macro' spinbox\r\nScriptHelper.WaitFormVisible = false;\r\n\r\nif (Selected.Table == null)\r\n{\r\n    Error(\"No table selected in the UI. Please select a date table before running the script.\");\r\n    return;\r\n}\r\n\r\nstring _CalendarTable = Selected.Table.Name;\r\n\r\ntry\r\n{\r\n    var table = Model.Tables[_CalendarTable];\r\n\r\n    // Sorting\r\n    table.Columns[\"Year Quarter\"].SortByColumn = table.Columns[\"Year Quarter Number\"];\r\n    table.Columns[\"Year Month Short\"].SortByColumn = table.Columns[\"Year Month Number\"];\r\n    table.Columns[\"Year Month\"].SortByColumn = table.Columns[\"Year Month Number\"];\r\n    table.Columns[\"Month\"].SortByColumn = table.Columns[\"Month Number\"];\r\n    table.Columns[\"Month Short\"].SortByColumn = table.Columns[\"Month Number\"];\r\n    table.Columns[\"Day of Week\"].SortByColumn = table.Columns[\"Day of Week Number\"];\r\n    table.Columns[\"Day of Week Short\"].SortByColumn = table.Columns[\"Day of Week Number\"];\r\n\r\n    // Display folders\r\n    table.Columns[\"Year\"].DisplayFolder = \"1. Year\";\r\n\r\n    table.Columns[\"Year Quarter\"].DisplayFolder = \"2. Quarter\";\r\n    table.Columns[\"Year Quarter Number\"].DisplayFolder = \"2. Quarter\";\r\n    table.Columns[\"Quarter\"].DisplayFolder = \"2. Quarter\";\r\n\r\n    table.Columns[\"Year Month\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Year Month Short\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Year Month Number\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Month\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Month Short\"].DisplayFolder = \"3. Month\";\r\n    table.Columns[\"Month Number\"].DisplayFolder = \"3. Month\";\r\n\r\n    table.Columns[\"Date\"].DisplayFolder = \"4. Date\";\r\n\r\n    table.Columns[\"Day of Week\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Day of Week Short\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Day of Week Number\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Working Day\"].DisplayFolder = \"5. Day\";\r\n    table.Columns[\"Working Day Number\"].DisplayFolder = \"5. Day\";\r\n\r\n    // Format strings\r\n    table.Columns[\"Date\"].FormatString = \"mm/dd/yyyy\";\r\n\r\n    table.Columns[\"Year Quarter Number\"].FormatString = \"0\";\r\n    table.Columns[\"Year Month Number\"].FormatString = \"0\";\r\n    table.Columns[\"Month Number\"].FormatString = \"0\";\r\n    table.Columns[\"Day of Week Number\"].FormatString = \"0\";\r\n    table.Columns[\"Working Day Number\"].FormatString = \"0\";\r\n\r\n    // Hide columns used only for sorting\r\n    table.Columns[\"Year Quarter Number\"].IsHidden = true;\r\n    table.Columns[\"Year Month Number\"].IsHidden = true;\r\n\r\n    // Descriptions\r\n    table.Columns[\"Date\"].Description = \"YYYY-MM-DD\";\r\n    table.Columns[\"Year\"].Description = \"YYYY\";\r\n\r\n    table.Columns[\"Year Quarter\"].Description = \"Q1 2024\";\r\n    table.Columns[\"Year Quarter Number\"].Description = \"Used for sorting Year Quarter\";\r\n    table.Columns[\"Quarter\"].Description = \"I.e. Q1\";\r\n\r\n    table.Columns[\"Year Month\"].Description = \"I.e. January 2024\";\r\n    table.Columns[\"Year Month Short\"].Description = \"I.e. Jan 2024\";\r\n    table.Columns[\"Year Month Number\"].Description = \"Used for sorting Year Month\";\r\n    table.Columns[\"Month\"].Description = \"I.e. January\";\r\n    table.Columns[\"Month Short\"].Description = \"I.e. Jan\";\r\n    table.Columns[\"Month Number\"].Description = \"I.e. 1 (=January)\";\r\n\r\n    table.Columns[\"Day of Week\"].Description = \"I.e. Monday\";\r\n    table.Columns[\"Day of Week Short\"].Description = \"I.e. Mon\";\r\n    table.Columns[\"Day of Week Number\"].Description = \"1=Sunday to 7=Saturday\";\r\n    table.Columns[\"Working day\"].Description = \"TRUE/FALSE\";\r\n    table.Columns[\"Working Day Number\"].Description = \"Accumulated work day no from first date in calendar\";\r\n\r\n    // Table description\r\n    table.Description = \"Date-table\";\r\n}\r\ncatch\r\n{\r\n    Error(\"No selected date-table or see if column definitions are matching => No formatting\");\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\3. Add items to Time Intelligence Calculation group",
      "Enabled": "true",
      "Execute": "\r\n// This script includes the select time calculations that are to be included. The idea is from the following script, but here it is included as a Calculation Group instead and with some modifications\r\n//        Data-Goblin inspiration: https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/add-dax-templates/add-time-intelligence.csx\r\n\r\n\r\n// There are some input that are dynamically included in the generation of time intelligence calculations:\r\n//     1. Date column to be used from the date table (needs to be created first)\r\n//     2. Measure that shows the last data from calendar or transaction (needs to be calculated first and have the correct formatString containing \"yy\"). The purpose is to hide future dates in calculations, where applicable\r\n//     3. Based on the selected Time intelligence calculations, it is logic on which input is required. \r\n\r\n// Naming is aiming at following this pattern: https://www.daxpatterns.com/standard-time-related-calculations/\r\n// Referance to source for the expressions are included in the measure expressions\r\n\r\n// If you know of some measures with % format, this can be updated in the logic for the calculation item before running the script\r\n\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n\r\n// Don't show the script execution dialog or cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Rename Calculation Group Table and Column if it's a new one\r\n\r\n// Define inline input dialog function \r\nFunc<string, string, string, string> ShowInputDialog = (text, caption, defaultValue) =>\r\n{\r\n    Form prompt = new Form()\r\n    {\r\n        Width = 600,\r\n        Height = 150,\r\n        FormBorderStyle = FormBorderStyle.FixedDialog,\r\n        Text = caption,\r\n        StartPosition = FormStartPosition.CenterScreen\r\n    };\r\n    Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n    TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n    Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n    confirmation.Click += (sender, e) => { prompt.Close(); };\r\n    prompt.Controls.Add(textLabel);\r\n    prompt.Controls.Add(textBox);\r\n    prompt.Controls.Add(confirmation);\r\n    prompt.AcceptButton = confirmation;\r\n\r\n    return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n};\r\n\r\n// Get the selected calculation group table. Checks the name if it is a new or existing calculation group\r\nvar cgTable = Selected.Tables.First() as CalculationGroupTable;\r\n\r\nif (cgTable != null && cgTable.Name.StartsWith(\"New Calculation Group\"))\r\n{\r\n    string defaultTableName = \"Time Intelligence\";\r\n    string defaultColumnName = \"Time Calculation\";\r\n\r\n    string newTableName = ShowInputDialog(\r\n        \"Enter new name for the calculation group table:\",\r\n        \"Rename Calculation Group Table\",\r\n        defaultTableName\r\n    );\r\n\r\n    string newColumnName = ShowInputDialog(\r\n        \"Enter name for the calculation group column:\",\r\n        \"Set Calculation Group Column Name\",\r\n        defaultColumnName\r\n    );\r\n\r\n    if (!string.IsNullOrWhiteSpace(newTableName))\r\n    {\r\n        cgTable.Name = newTableName;\r\n        cgTable.Description = \"Calculation group for dynamic time intelligence.\";\r\n        cgTable.CalculationGroup.Precedence = 0;\r\n\r\nif (!string.IsNullOrWhiteSpace(newColumnName))\r\n{\r\n    cgTable.Columns[\"Name\"].Name = newColumnName;\r\n}\r\n\r\n        // Info(string.Format(\"Calculation Group renamed to '{0}' with column '{1}'\", newTableName, newColumnName));\r\n    }\r\n    else\r\n    {\r\n        Warning(\"No table name entered. Calculation group name remains unchanged.\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Column selector\r\nFunc<IEnumerable<Column>, string, Column> SelectColumnFromList = (columns, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Column\"; // Keep title short (multiline not supported)\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = columns.Select(c => c.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return columns.FirstOrDefault(c => c.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Measure selector\r\nFunc<IEnumerable<Measure>, string, Measure> SelectMeasureFromList = (measures, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Measure\"; // Keep title short\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = measures.Select(m => m.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return measures.FirstOrDefault(m => m.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Time Intelligence Selection UI\r\n\r\nstring[] calcTypes = new string[] {\r\n    \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\"\r\n};\r\n\r\nForm tiForm = new Form();\r\nListBox tiListBox = new ListBox();\r\nButton tiButton = new Button();\r\nLabel tiLabel = new Label();\r\n\r\ntiForm.Text = \"Select Time Intelligence Types\";\r\ntiForm.Width = 350;\r\ntiForm.Height = 400;\r\n\r\ntiLabel.Text = \"Select one or more calculation types:\";\r\ntiLabel.Location = new Point(20, 10);\r\ntiLabel.Width = 300;\r\n\r\ntiListBox.Items.AddRange(calcTypes);\r\ntiListBox.SelectionMode = SelectionMode.MultiExtended;\r\ntiListBox.Location = new Point(20, 40);\r\ntiListBox.Width = 290;\r\ntiListBox.Height = 250;\r\n\r\ntiButton.Text = \"OK\";\r\ntiButton.Location = new Point(120, 310);\r\ntiButton.Width = 100;\r\ntiButton.Click += (sender, e) => { tiForm.Close(); };\r\n\r\ntiForm.Controls.Add(tiListBox);\r\ntiForm.Controls.Add(tiButton);\r\ntiForm.Controls.Add(tiLabel);\r\ntiForm.ShowDialog();\r\n\r\nList<string> selectedValues = tiListBox.SelectedItems.Cast<string>().ToList();\r\n\r\n\r\n\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime &&\r\n    c.IsKey == true).ToList();\r\n    var selectedDateCol = SelectColumnFromList(\r\n    _dateColumns,\r\n    \"Select the DATE column for time calculations.\\n\\nA Date table marked as a date table is required.\"\r\n);\r\n\r\nif (selectedDateCol == null) return;\r\nstring _CalendarDate = selectedDateCol.DaxObjectFullName;\r\nvar _calendarTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n\r\nstring _LastDateAvailable = null;\r\n\r\nbool requiresFutureDateLogic = selectedValues.Any(x => new[] { \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\" }.Contains(x));\r\nif (requiresFutureDateLogic)\r\n{\r\n    var _dateFormattedMeasures = Model.AllMeasures\r\n        .Where(m => m.FormatString != null && (m.FormatString.Contains(\"yy\") || m.FormatString.Contains(\"yyyy\")))\r\n        .ToList();\r\n\r\n        var selectedMeasure = SelectMeasureFromList(_dateFormattedMeasures, \"Select MEASURE for hiding future dates \\n\\n (Cancel will create logic for last date)\");\r\n    _LastDateAvailable = selectedMeasure != null\r\n        ? selectedMeasure.DaxObjectName\r\n        : string.Format(\"MIN(MAX({0}), TODAY())\", _CalendarDate);\r\n}\r\n\r\nstring _selectedAverage = null;\r\nif (selectedValues.Contains(\"Rolling average\"))\r\n{\r\n    var _selectedTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n    var _selectedDateTable = Model.Tables[_selectedTableName];\r\n    var _columnsInDateTable = _selectedDateTable.Columns.ToList();\r\n\r\n    var avgCol = SelectColumnFromList(_columnsInDateTable, \"Select column for Rolling 12M Average \\n\\n(e.g., daily/monthly)\");\r\n    if (avgCol != null)\r\n    {\r\n        _selectedAverage = avgCol.DaxObjectFullName;\r\n    }\r\n}\r\n\r\n// Optional debug\r\n//string debugMsg = \"Selected: \" + string.Join(\", \", selectedValues);\r\n//debugMsg += \"\\nCalendar Date: \" + _CalendarDate;\r\n//debugMsg += _LastDateAvailable != null ? \"\\nLast Date Logic: \" + _LastDateAvailable : \"\";\r\n//debugMsg += _selectedAverage != null ? \"\\nRolling Average Column: \" + _selectedAverage : \"\";\r\n//MessageBox.Show(debugMsg);\r\n\r\n// Set starting ordinal\r\nint ordinal = cgTable.Name.StartsWith(\"New Calculation Group\") ? 0 :\r\n    (cgTable.CalculationItems.Count > 0 ? cgTable.CalculationItems.Max(ci => ci.Ordinal) + 1 : 0);\r\n        \r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// AddCalculationItemIfNotExists helper\r\n\r\nList<string> skippedItems = new List<string>();\r\n\r\nAction<string, string, int, string, string> AddCalculationItemIfNotExists = \r\n(name, expression, ordinalPos, description, formatString) =>\r\n{\r\nif (cgTable.CalculationItems.Any(ci => ci.Name.Equals(name, System.StringComparison.OrdinalIgnoreCase)))\r\n{\r\n    skippedItems.Add(name);\r\n    return;\r\n}\r\n\r\n\r\n    var item = cgTable.AddCalculationItem(name);\r\n    item.Expression = expression;\r\n    item.Ordinal = ordinalPos;\r\n    item.Description = description;\r\n    // FormatDax(item);\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Looping through all selected calculation item categories\r\nforeach (var item in selectedValues)\r\n{\r\n\r\n    if (item == \"Actual\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Actual\", \"SELECTEDMEASURE()\", ordinal++, \"Actual values\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Actual value until last date available\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual Y-1\", \r\n    string.Format(\r\n        \"CALCULATE(\\n\" +\r\n        \"    SELECTEDMEASURE(),\\n\" +\r\n        \"    SAMEPERIODLASTYEAR({0})\\n\" +\r\n        \")\", \r\n        _CalendarDate\r\n    ), \r\n    ordinal++, \"Actual value last year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date Y-1\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\", \r\n_LastDateAvailable, \r\n_CalendarDate), ordinal++, \"Actual value last year, hiding future dates as of this year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA = Actual over Actual: Deviation for actual value this year and last year, hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA %\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _CurrentDates\r\n        )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA %: Percentage change this year and last year, hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _CalendarDate), ordinal++, \"AOA C = Complete Actual over Actual, not hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C %\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _CalendarDate), ordinal++, \"AOA C %: Complete Actual over Actual % change, not hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        continue;\r\n    }\r\n\r\n        // MTD logic\r\n    if (item == \"MTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"MTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _CurrentMonth - _PreviousMonth\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date: Month-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD %\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaMonth = _CurrentMonth - _PreviousMonth\r\n\r\nRETURN \r\n    DIVIDE(_DeltaMonth, _PreviousMonth)\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date %: % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Month, hiding future dates from last available date (same date last Month)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PQ\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSQUARTER(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Quarter, hiding future dates from last available date (same date last quarter)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD({0})\r\n        )\"\r\n        , _CalendarDate), ordinal++, \"MTD C = Month to date Complete: accumulated, without hiding of future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", \r\n        _CalendarDate), ordinal++, \"MTD LY C = Month to date Complete Last Year: Month last year accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH({0}))\r\n        )\", _CalendarDate), ordinal++, \"MTD PM C = Month to date, Previous month, Complete: Last Month previous month accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n    \r\n // QTD logic\r\n    if (item == \"QTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"QTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n\r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n      \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n\r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD %\", string.Format(@\"\r\n// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Index, % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"QTD C\", string.Format(@\"CALCULATE(\r\n     SELECTEDMEASURE(), \r\n     DATESQTD({0})\r\n     )\", _CalendarDate), ordinal++, \"QTD C = Quarter to date Complete: Quarter to date accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY C\", string.Format(@\"CALCULATE(\r\n    SELECTEDMEASURE(), \r\n    DATESQTD(SAMEPERIODLASTYEAR({0}))\r\n    )\", _CalendarDate), ordinal++, \"QTD LY C = Quarter to date last year Complete: Last Quarter accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n\r\n// YTD logic\r\nif (item == \"YTD\")\r\n{\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}),\r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date, hiding future dates after last available date\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date last year, hiding future dates from last available date (same date last year)\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n     )\r\n     \r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Deviation, this year and last year accumulated\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD %\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Index %, % change this year vs last\", \"\\\"0%\\\"\"\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD({0})\r\n        )\", _CalendarDate),\r\n        ordinal++, \"YTD C = Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", _CalendarDate),\r\n        ordinal++, \"LYTD C = Last Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    continue;\r\n}\r\n\r\n      if (item == \"R12\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Rolling 12M\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\nRETURN IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months, hiding future dates after last available date\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M LY\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\n\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months last year, hiding future dates\", null);\r\n       \r\nAddCalculationItemIfNotExists(\"Rolling 12M Dev\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates)\r\n        \r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _CurrentResult - _PreviousResult)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Deviation\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M idx\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _DeviationResult = _CurrentResult - _PreviousResult\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, DIVIDE(_DeviationResult, _PreviousResult))\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Index %\", \"\\\"0%\\\"\");\r\n        continue;\r\n    }\r\n    \r\n    \r\n    \r\n    if (item == \"Rolling average\")\r\n    {\r\n        if (!string.IsNullOrEmpty(_selectedAverage))\r\n        {\r\n            AddCalculationItemIfNotExists(\"Rolling 12M avg\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\n //Calculating the average based on the selection in VALUES, such as per day or per month\r\n \r\nVAR _LastDayShown = {0}\r\n        \r\nVAR _NumOfMonths = 12\r\n// Hiding future days. If not remove the calculate in _ReferenceDate\r\nVAR  _LastCurrentDate = CALCULATE(\r\n    max({1}), FILTER(\r\n        VALUES( {1} ),\r\n        {1} <= _LastDayShown\r\n    )\r\n)\r\n\r\n VAR _Period =\r\n        DATESINPERIOD ( {1}, _LastCurrentDate, - _NumOfMonths, MONTH )  \r\n    \r\nVAR _Result =\r\n        CALCULATE (\r\n            AVERAGEX (\r\n                VALUES ( {2} ),     \r\n                SELECTEDMEASURE () \r\n            ),\r\n            _Period\r\n        ) \r\n    \r\n     VAR _firstDateInPeriod = MINX ( _Period, {1} )\r\n   \r\n    \r\nRETURN \r\n    IF ( _firstDateInPeriod <= _LastCurrentDate, _Result )\",\r\n    _LastDateAvailable, _CalendarDate, _selectedAverage),\r\n    ordinal++,\r\n    string.Format(\"Rolling 12 months average per {0}, hiding future dates\", _selectedAverage),\r\n    null);\r\n        }\r\n        continue;\r\n    }\r\n    \r\n        if (item == \"Rolling total\")\r\n        {     \r\n    AddCalculationItemIfNotExists(\"Rolling Total\", string.Format(@\"\r\nvar _currdate= {0}\r\n\r\nRETURN\r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        FILTER(\r\n            ALLSELECTED({1}),\r\n            ISONORAFTER({1}, _currdate, DESC)\r\n        )\r\n    )\r\n\r\n     \"\r\n        , _LastDateAvailable, _CalendarDate), ordinal++,\r\n        \"Running Total, from the first date available until selected date\", null);\r\n        continue;\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    // Placeholder: additional Time Intelligence logic goes here\r\n  //  AddCalculationItemIfNotExists(item, \"SELECTEDMEASURE()\", ordinal++, \"Time Intelligence - \" + item, null);\r\n}\r\n\r\nif (skippedItems.Count > 0)\r\n{\r\nstring message = \"The following calculation item(s) were skipped because they already exist:\\n\\n\" + string.Join(\"\\n\", skippedItems);\r\n\r\n    MessageBox.Show(message, \"Items Skipped\", MessageBoxButtons.OK, MessageBoxIcon.Information);\r\n}\r\n\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\3. Create Time Intelligence Calculation group",
      "Enabled": "true",
      "Execute": "\r\n// This script includes the select time calculations that are to be included. The idea is from the following script, but here it is included as a Calculation Group instead and with some modifications\r\n//        Data-Goblin inspiration: https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/add-dax-templates/add-time-intelligence.csx\r\n\r\n\r\n// There are some input that are dynamically included in the generation of time intelligence calculations:\r\n//     1. Date column to be used from the date table (needs to be created first)\r\n//     2. Measure that shows the last data from calendar or transaction (needs to be calculated first and have the correct formatString containing \"yy\"). The purpose is to hide future dates in calculations, where applicable\r\n//     3. Based on the selected Time intelligence calculations, it is logic on which input is required. \r\n\r\n// Naming is aiming at following this pattern: https://www.daxpatterns.com/standard-time-related-calculations/\r\n// Referance to source for the expressions are included in the measure expressions\r\n\r\n// If you know of some measures with % format, this can be updated in the logic for the calculation item before running the script\r\n\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n\r\n// Don't show the script execution dialog or cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Rename Calculation Group Table and Column if it's a new one\r\n\r\n// Define inline input dialog function \r\nFunc<string, string, string, string> ShowInputDialog = (text, caption, defaultValue) =>\r\n{\r\n    Form prompt = new Form()\r\n    {\r\n        Width = 600,\r\n        Height = 150,\r\n        FormBorderStyle = FormBorderStyle.FixedDialog,\r\n        Text = caption,\r\n        StartPosition = FormStartPosition.CenterScreen\r\n    };\r\n    Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n    TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n    Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n    confirmation.Click += (sender, e) => { prompt.Close(); };\r\n    prompt.Controls.Add(textLabel);\r\n    prompt.Controls.Add(textBox);\r\n    prompt.Controls.Add(confirmation);\r\n    prompt.AcceptButton = confirmation;\r\n\r\n    return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n};\r\n\r\n// Get the selected calculation group table. Checks the name if it is a new or existing calculation group\r\nvar cgTable = Selected.Tables.First() as CalculationGroupTable;\r\n\r\nif (cgTable != null && cgTable.Name.StartsWith(\"New Calculation Group\"))\r\n{\r\n    string defaultTableName = \"Time Intelligence\";\r\n    string defaultColumnName = \"Time Calculation\";\r\n\r\n    string newTableName = ShowInputDialog(\r\n        \"Enter new name for the calculation group table:\",\r\n        \"Rename Calculation Group Table\",\r\n        defaultTableName\r\n    );\r\n\r\n    string newColumnName = ShowInputDialog(\r\n        \"Enter name for the calculation group column:\",\r\n        \"Set Calculation Group Column Name\",\r\n        defaultColumnName\r\n    );\r\n\r\n    if (!string.IsNullOrWhiteSpace(newTableName))\r\n    {\r\n        cgTable.Name = newTableName;\r\n        cgTable.Description = \"Calculation group for dynamic time intelligence.\";\r\n        cgTable.CalculationGroup.Precedence = 0;\r\n\r\nif (!string.IsNullOrWhiteSpace(newColumnName))\r\n{\r\n    cgTable.Columns[\"Name\"].Name = newColumnName;\r\n}\r\n\r\n        // Info(string.Format(\"Calculation Group renamed to '{0}' with column '{1}'\", newTableName, newColumnName));\r\n    }\r\n    else\r\n    {\r\n        Warning(\"No table name entered. Calculation group name remains unchanged.\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Column selector\r\nFunc<IEnumerable<Column>, string, Column> SelectColumnFromList = (columns, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Column\"; // Keep title short (multiline not supported)\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = columns.Select(c => c.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return columns.FirstOrDefault(c => c.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Measure selector\r\nFunc<IEnumerable<Measure>, string, Measure> SelectMeasureFromList = (measures, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Measure\"; // Keep title short\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = measures.Select(m => m.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return measures.FirstOrDefault(m => m.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Time Intelligence Selection UI\r\n\r\nstring[] calcTypes = new string[] {\r\n    \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\"\r\n};\r\n\r\nForm tiForm = new Form();\r\nListBox tiListBox = new ListBox();\r\nButton tiButton = new Button();\r\nLabel tiLabel = new Label();\r\n\r\ntiForm.Text = \"Select Time Intelligence Types\";\r\ntiForm.Width = 350;\r\ntiForm.Height = 400;\r\n\r\ntiLabel.Text = \"Select one or more calculation types:\";\r\ntiLabel.Location = new Point(20, 10);\r\ntiLabel.Width = 300;\r\n\r\ntiListBox.Items.AddRange(calcTypes);\r\ntiListBox.SelectionMode = SelectionMode.MultiExtended;\r\ntiListBox.Location = new Point(20, 40);\r\ntiListBox.Width = 290;\r\ntiListBox.Height = 250;\r\n\r\ntiButton.Text = \"OK\";\r\ntiButton.Location = new Point(120, 310);\r\ntiButton.Width = 100;\r\ntiButton.Click += (sender, e) => { tiForm.Close(); };\r\n\r\ntiForm.Controls.Add(tiListBox);\r\ntiForm.Controls.Add(tiButton);\r\ntiForm.Controls.Add(tiLabel);\r\ntiForm.ShowDialog();\r\n\r\nList<string> selectedValues = tiListBox.SelectedItems.Cast<string>().ToList();\r\n\r\n\r\n\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime &&\r\n    c.IsKey == true).ToList();\r\n    var selectedDateCol = SelectColumnFromList(\r\n    _dateColumns,\r\n    \"Select the DATE column for time calculations.\\n\\nA Date table marked as a date table is required.\"\r\n);\r\n\r\nif (selectedDateCol == null) return;\r\nstring _CalendarDate = selectedDateCol.DaxObjectFullName;\r\nvar _calendarTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n\r\nstring _LastDateAvailable = null;\r\n\r\nbool requiresFutureDateLogic = selectedValues.Any(x => new[] { \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\" }.Contains(x));\r\nif (requiresFutureDateLogic)\r\n{\r\n    var _dateFormattedMeasures = Model.AllMeasures\r\n        .Where(m => m.FormatString != null && (m.FormatString.Contains(\"yy\") || m.FormatString.Contains(\"yyyy\")))\r\n        .ToList();\r\n\r\n        var selectedMeasure = SelectMeasureFromList(_dateFormattedMeasures, \"Select MEASURE for hiding future dates \\n\\n (Cancel will create logic for last date)\");\r\n    _LastDateAvailable = selectedMeasure != null\r\n        ? selectedMeasure.DaxObjectName\r\n        : string.Format(\"MIN(MAX({0}), TODAY())\", _CalendarDate);\r\n}\r\n\r\nstring _selectedAverage = null;\r\nif (selectedValues.Contains(\"Rolling average\"))\r\n{\r\n    var _selectedTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n    var _selectedDateTable = Model.Tables[_selectedTableName];\r\n    var _columnsInDateTable = _selectedDateTable.Columns.ToList();\r\n\r\n    var avgCol = SelectColumnFromList(_columnsInDateTable, \"Select column for Rolling 12M Average \\n\\n(e.g., daily/monthly)\");\r\n    if (avgCol != null)\r\n    {\r\n        _selectedAverage = avgCol.DaxObjectFullName;\r\n    }\r\n}\r\n\r\n// Optional debug\r\n//string debugMsg = \"Selected: \" + string.Join(\", \", selectedValues);\r\n//debugMsg += \"\\nCalendar Date: \" + _CalendarDate;\r\n//debugMsg += _LastDateAvailable != null ? \"\\nLast Date Logic: \" + _LastDateAvailable : \"\";\r\n//debugMsg += _selectedAverage != null ? \"\\nRolling Average Column: \" + _selectedAverage : \"\";\r\n//MessageBox.Show(debugMsg);\r\n\r\n// Set starting ordinal\r\nint ordinal = cgTable.Name.StartsWith(\"New Calculation Group\") ? 0 :\r\n    (cgTable.CalculationItems.Count > 0 ? cgTable.CalculationItems.Max(ci => ci.Ordinal) + 1 : 0);\r\n        \r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// AddCalculationItemIfNotExists helper\r\n\r\nList<string> skippedItems = new List<string>();\r\n\r\nAction<string, string, int, string, string> AddCalculationItemIfNotExists = \r\n(name, expression, ordinalPos, description, formatString) =>\r\n{\r\nif (cgTable.CalculationItems.Any(ci => ci.Name.Equals(name, System.StringComparison.OrdinalIgnoreCase)))\r\n{\r\n    skippedItems.Add(name);\r\n    return;\r\n}\r\n\r\n\r\n    var item = cgTable.AddCalculationItem(name);\r\n    item.Expression = expression;\r\n    item.Ordinal = ordinalPos;\r\n    item.Description = description;\r\n    // FormatDax(item);\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Looping through all selected calculation item categories\r\nforeach (var item in selectedValues)\r\n{\r\n\r\n    if (item == \"Actual\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Actual\", \"SELECTEDMEASURE()\", ordinal++, \"Actual values\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Actual value until last date available\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual Y-1\", \r\n    string.Format(\r\n        \"CALCULATE(\\n\" +\r\n        \"    SELECTEDMEASURE(),\\n\" +\r\n        \"    SAMEPERIODLASTYEAR({0})\\n\" +\r\n        \")\", \r\n        _CalendarDate\r\n    ), \r\n    ordinal++, \"Actual value last year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date Y-1\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\", \r\n_LastDateAvailable, \r\n_CalendarDate), ordinal++, \"Actual value last year, hiding future dates as of this year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA = Actual over Actual: Deviation for actual value this year and last year, hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA %\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _CurrentDates\r\n        )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA %: Percentage change this year and last year, hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _CalendarDate), ordinal++, \"AOA C = Complete Actual over Actual, not hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C %\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _CalendarDate), ordinal++, \"AOA C %: Complete Actual over Actual % change, not hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        continue;\r\n    }\r\n\r\n        // MTD logic\r\n    if (item == \"MTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"MTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _CurrentMonth - _PreviousMonth\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date: Month-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD %\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaMonth = _CurrentMonth - _PreviousMonth\r\n\r\nRETURN \r\n    DIVIDE(_DeltaMonth, _PreviousMonth)\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date %: % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Month, hiding future dates from last available date (same date last Month)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PQ\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSQUARTER(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Quarter, hiding future dates from last available date (same date last quarter)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD({0})\r\n        )\"\r\n        , _CalendarDate), ordinal++, \"MTD C = Month to date Complete: accumulated, without hiding of future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", \r\n        _CalendarDate), ordinal++, \"MTD LY C = Month to date Complete Last Year: Month last year accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH({0}))\r\n        )\", _CalendarDate), ordinal++, \"MTD PM C = Month to date, Previous month, Complete: Last Month previous month accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n    \r\n // QTD logic\r\n    if (item == \"QTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"QTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n\r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n      \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n\r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD %\", string.Format(@\"\r\n// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Index, % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"QTD C\", string.Format(@\"CALCULATE(\r\n     SELECTEDMEASURE(), \r\n     DATESQTD({0})\r\n     )\", _CalendarDate), ordinal++, \"QTD C = Quarter to date Complete: Quarter to date accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY C\", string.Format(@\"CALCULATE(\r\n    SELECTEDMEASURE(), \r\n    DATESQTD(SAMEPERIODLASTYEAR({0}))\r\n    )\", _CalendarDate), ordinal++, \"QTD LY C = Quarter to date last year Complete: Last Quarter accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n\r\n// YTD logic\r\nif (item == \"YTD\")\r\n{\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}),\r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date, hiding future dates after last available date\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date last year, hiding future dates from last available date (same date last year)\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n     )\r\n     \r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Deviation, this year and last year accumulated\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD %\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Index %, % change this year vs last\", \"\\\"0%\\\"\"\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD({0})\r\n        )\", _CalendarDate),\r\n        ordinal++, \"YTD C = Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", _CalendarDate),\r\n        ordinal++, \"LYTD C = Last Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    continue;\r\n}\r\n\r\n      if (item == \"R12\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Rolling 12M\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\nRETURN IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months, hiding future dates after last available date\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M LY\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\n\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months last year, hiding future dates\", null);\r\n       \r\nAddCalculationItemIfNotExists(\"Rolling 12M Dev\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates)\r\n        \r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _CurrentResult - _PreviousResult)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Deviation\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M idx\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _DeviationResult = _CurrentResult - _PreviousResult\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, DIVIDE(_DeviationResult, _PreviousResult))\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Index %\", \"\\\"0%\\\"\");\r\n        continue;\r\n    }\r\n    \r\n    \r\n    \r\n    if (item == \"Rolling average\")\r\n    {\r\n        if (!string.IsNullOrEmpty(_selectedAverage))\r\n        {\r\n            AddCalculationItemIfNotExists(\"Rolling 12M avg\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\n //Calculating the average based on the selection in VALUES, such as per day or per month\r\n \r\nVAR _LastDayShown = {0}\r\n        \r\nVAR _NumOfMonths = 12\r\n// Hiding future days. If not remove the calculate in _ReferenceDate\r\nVAR  _LastCurrentDate = CALCULATE(\r\n    max({1}), FILTER(\r\n        VALUES( {1} ),\r\n        {1} <= _LastDayShown\r\n    )\r\n)\r\n\r\n VAR _Period =\r\n        DATESINPERIOD ( {1}, _LastCurrentDate, - _NumOfMonths, MONTH )  \r\n    \r\nVAR _Result =\r\n        CALCULATE (\r\n            AVERAGEX (\r\n                VALUES ( {2} ),     \r\n                SELECTEDMEASURE () \r\n            ),\r\n            _Period\r\n        ) \r\n    \r\n     VAR _firstDateInPeriod = MINX ( _Period, {1} )\r\n   \r\n    \r\nRETURN \r\n    IF ( _firstDateInPeriod <= _LastCurrentDate, _Result )\",\r\n    _LastDateAvailable, _CalendarDate, _selectedAverage),\r\n    ordinal++,\r\n    string.Format(\"Rolling 12 months average per {0}, hiding future dates\", _selectedAverage),\r\n    null);\r\n        }\r\n        continue;\r\n    }\r\n    \r\n        if (item == \"Rolling total\")\r\n        {     \r\n    AddCalculationItemIfNotExists(\"Rolling Total\", string.Format(@\"\r\nvar _currdate= {0}\r\n\r\nRETURN\r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        FILTER(\r\n            ALLSELECTED({1}),\r\n            ISONORAFTER({1}, _currdate, DESC)\r\n        )\r\n    )\r\n\r\n     \"\r\n        , _LastDateAvailable, _CalendarDate), ordinal++,\r\n        \"Running Total, from the first date available until selected date\", null);\r\n        continue;\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    // Placeholder: additional Time Intelligence logic goes here\r\n  //  AddCalculationItemIfNotExists(item, \"SELECTEDMEASURE()\", ordinal++, \"Time Intelligence - \" + item, null);\r\n}\r\n\r\nif (skippedItems.Count > 0)\r\n{\r\nstring message = \"The following calculation item(s) were skipped because they already exist:\\n\\n\" + string.Join(\"\\n\", skippedItems);\r\n\r\n    MessageBox.Show(message, \"Items Skipped\", MessageBoxButtons.OK, MessageBoxIcon.Information);\r\n}\r\n\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\3. Create or Add to Time Intelligence Calculation group",
      "Enabled": "true",
      "Execute": "\r\n// This script includes the select time calculations that are to be included. The idea is from the following script, but here it is included as a Calculation Group instead and with some modifications\r\n//        Data-Goblin inspiration: https://github.com/data-goblin/powerbi-macguyver-toolbox/blob/main/tabular-editor-scripts/csharp-scripts/add-dax-templates/add-time-intelligence.csx\r\n\r\n\r\n// There are some input that are dynamically included in the generation of time intelligence calculations:\r\n//     1. Date column to be used from the date table (needs to be created first)\r\n//     2. Measure that shows the last data from calendar or transaction (needs to be calculated first and have the correct formatString containing \"yy\"). The purpose is to hide future dates in calculations, where applicable\r\n//     3. Based on the selected Time intelligence calculations, it is logic on which input is required. \r\n\r\n// Naming is aiming at following this pattern: https://www.daxpatterns.com/standard-time-related-calculations/\r\n// Referance to source for the expressions are included in the measure expressions\r\n\r\n// If you know of some measures with % format, this can be updated in the logic for the calculation item before running the script\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\n\r\n// Don't show the script execution dialog or cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Rename Calculation Group Table and Column if it's a new one\r\n\r\n// Define inline input dialog function \r\nFunc<string, string, string, string> ShowInputDialog = (text, caption, defaultValue) =>\r\n{\r\n    Form prompt = new Form()\r\n    {\r\n        Width = 600,\r\n        Height = 150,\r\n        FormBorderStyle = FormBorderStyle.FixedDialog,\r\n        Text = caption,\r\n        StartPosition = FormStartPosition.CenterScreen\r\n    };\r\n    Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n    TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n    Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n    confirmation.Click += (sender, e) => { prompt.Close(); };\r\n    prompt.Controls.Add(textLabel);\r\n    prompt.Controls.Add(textBox);\r\n    prompt.Controls.Add(confirmation);\r\n    prompt.AcceptButton = confirmation;\r\n\r\n    return prompt.ShowDialog() == DialogResult.OK ? textBox.Text : \"\";\r\n};\r\n\r\n// Declare table and column variables\r\nstring _timeIntelligenceCalcGroupTable = string.Empty;\r\nstring _timeIntelligenceCalcGroupColumn = string.Empty;\r\n\r\n// Get all Calculation Groups from the model\r\nvar calcGroups = Model.CalculationGroups.ToList();\r\n\r\n// Declare Calculation Group Table\r\nCalculationGroupTable cgTable = null;\r\n\r\nif (calcGroups.Count > 0)\r\n{\r\n    // Ask user if they want to use an existing calculation group\r\n    DialogResult dialogResult = MessageBox.Show(\"Do you want to add to an existing calculation group?\", \"Select calculation group\", MessageBoxButtons.YesNo);\r\n\r\n    if (dialogResult == DialogResult.Yes)\r\n    {\r\n        // Get all non-ordinal columns from all calc groups\r\n        var nonOrdinalColumns = calcGroups\r\n            .SelectMany(cg => cg.Columns.Where(c => c.Name != \"Ordinal\"))\r\n            .ToList();\r\n\r\n        if (nonOrdinalColumns.Count == 0)\r\n        {\r\n            MessageBox.Show(\"No valid Calculation Group columns found.\", \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);\r\n            return;\r\n        }\r\n\r\n        // Select the column\r\n        var selectedCol = SelectColumn(nonOrdinalColumns, null, \"Select Time Intelligence calc group column\");\r\n        if (selectedCol == null) return;\r\n\r\n        _timeIntelligenceCalcGroupTable = selectedCol.Table.Name;\r\n        _timeIntelligenceCalcGroupColumn = selectedCol.Name;\r\n\r\n        // Get the selected Calculation Group Table\r\n        cgTable = Model.Tables[_timeIntelligenceCalcGroupTable] as CalculationGroupTable;\r\n    }\r\n}\r\n\r\nif (cgTable == null) // If user selected \"No\" or no calc groups exist\r\n{\r\n    string defaultTableName = \"Time Intelligence\";\r\n    string defaultColumnName = \"Time Calculation\";\r\n\r\n _timeIntelligenceCalcGroupTable = ShowInputDialog(\"TABLE NAME CALCULATION GROUP:\", \"Calculation Group name\", defaultTableName);\r\n_timeIntelligenceCalcGroupColumn = ShowInputDialog(\"COLUMN NAME CALCULATION GROUP:\", \"Column name\", defaultColumnName);\r\n\r\n\r\n    // Create a new Calculation Group Table\r\n    cgTable = Model.AddCalculationGroup(_timeIntelligenceCalcGroupTable);\r\n\r\n    if (cgTable != null)\r\n    {\r\n        //(cgTable.Columns[\"Name\"] as DataColumn).Name = _timeIntelligenceCalcGroupColumn;\r\n        var nameColumn = cgTable.Columns[\"Name\"] as TabularEditor.TOMWrapper.DataColumn;\r\nif (nameColumn != null)\r\n    nameColumn.Name = _timeIntelligenceCalcGroupColumn;\r\n\r\n        var renamedColumn = cgTable.Columns[_timeIntelligenceCalcGroupColumn] as TabularEditor.TOMWrapper.DataColumn;\r\n\r\nif (renamedColumn != null)\r\n    renamedColumn.Description = \"The selected time intelligence\";\r\n\r\n        cgTable.Description = \"Calculation group for dynamic time intelligence.\";\r\n        cgTable.CalculationGroup.Precedence = 0;\r\n    }\r\n    else\r\n    {\r\n        MessageBox.Show(\"Failed to create Calculation Group Table.\", \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Column selector\r\nFunc<IEnumerable<Column>, string, Column> SelectColumnFromList = (columns, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Column\"; // Keep title short (multiline not supported)\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = columns.Select(c => c.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return columns.FirstOrDefault(c => c.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Helper: Measure selector\r\nFunc<IEnumerable<Measure>, string, Measure> SelectMeasureFromList = (measures, title) =>\r\n{\r\n    var form = new Form();\r\n    var listBox = new ListBox();\r\n    var okButton = new Button();\r\n    var cancelButton = new Button();\r\n    var label = new Label();\r\n\r\n    form.Text = \"Select Measure\"; // Keep title short\r\n    form.Width = 400;\r\n    form.Height = 470;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n\r\n    label.Text = title;  // Use the existing title input as label text\r\n    label.Left = 10;\r\n    label.Top = 10;\r\n    label.Width = 360;\r\n    label.Height = 40;\r\n    label.AutoSize = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 280;\r\n    listBox.Left = 10;\r\n    listBox.Top = 60;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = measures.Select(m => m.DaxObjectFullName).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 360;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 360;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(label);\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var result = form.ShowDialog();\r\n    if (result == DialogResult.OK && listBox.SelectedIndex >= 0)\r\n    {\r\n        string selectedName = listBox.SelectedItem.ToString();\r\n        return measures.FirstOrDefault(m => m.DaxObjectFullName == selectedName);\r\n    }\r\n    return null;\r\n};\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Time Intelligence Selection UI\r\n\r\nstring[] calcTypes = new string[] {\r\n    \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\"\r\n};\r\n\r\nForm tiForm = new Form();\r\nListBox tiListBox = new ListBox();\r\nButton tiButton = new Button();\r\nLabel tiLabel = new Label();\r\n\r\ntiForm.Text = \"Select Time Intelligence Types\";\r\ntiForm.Width = 350;\r\ntiForm.Height = 400;\r\n\r\ntiLabel.Text = \"Select one or more calculation types:\";\r\ntiLabel.Location = new Point(20, 10);\r\ntiLabel.Width = 300;\r\n\r\ntiListBox.Items.AddRange(calcTypes);\r\ntiListBox.SelectionMode = SelectionMode.MultiExtended;\r\ntiListBox.Location = new Point(20, 40);\r\ntiListBox.Width = 290;\r\ntiListBox.Height = 250;\r\n\r\ntiButton.Text = \"OK\";\r\ntiButton.Location = new Point(120, 310);\r\ntiButton.Width = 100;\r\ntiButton.Click += (sender, e) => { tiForm.Close(); };\r\n\r\ntiForm.Controls.Add(tiListBox);\r\ntiForm.Controls.Add(tiButton);\r\ntiForm.Controls.Add(tiLabel);\r\ntiForm.ShowDialog();\r\n\r\nList<string> selectedValues = tiListBox.SelectedItems.Cast<string>().ToList();\r\n\r\n\r\n\r\n\r\nvar _dateColumns = Model.AllColumns.Where(c => c.DataType == DataType.DateTime &&\r\n    c.IsKey == true).ToList();\r\n    var selectedDateCol = SelectColumnFromList(\r\n    _dateColumns,\r\n    \"Select the DATE column for time calculations.\\n\\nA Date table marked as a date table is required.\"\r\n);\r\n\r\nif (selectedDateCol == null) return;\r\nstring _CalendarDate = selectedDateCol.DaxObjectFullName;\r\nvar _calendarTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n\r\nstring _LastDateAvailable = null;\r\n\r\nbool requiresFutureDateLogic = selectedValues.Any(x => new[] { \"Actual\", \"MTD\", \"QTD\", \"YTD\", \"R12\", \"Rolling average\", \"Rolling total\" }.Contains(x));\r\nif (requiresFutureDateLogic)\r\n{\r\n    var _dateFormattedMeasures = Model.AllMeasures\r\n        .Where(m => m.FormatString != null && (m.FormatString.Contains(\"yy\") || m.FormatString.Contains(\"yyyy\")))\r\n        .ToList();\r\n\r\n        var selectedMeasure = SelectMeasureFromList(_dateFormattedMeasures, \"Select MEASURE for hiding future dates \\n\\n (Cancel will create logic for last date)\");\r\n    _LastDateAvailable = selectedMeasure != null\r\n        ? selectedMeasure.DaxObjectName\r\n        : string.Format(\"MIN(MAX({0}), TODAY())\", _CalendarDate);\r\n}\r\n\r\nstring _selectedAverage = null;\r\nif (selectedValues.Contains(\"Rolling average\"))\r\n{\r\n    var _selectedTableName = _CalendarDate.Split('[')[0].Trim('\\'');\r\n    var _selectedDateTable = Model.Tables[_selectedTableName];\r\n    var _columnsInDateTable = _selectedDateTable.Columns.ToList();\r\n\r\n    var avgCol = SelectColumnFromList(_columnsInDateTable, \"Select column for Rolling 12M Average \\n\\n(e.g., daily/monthly)\");\r\n    if (avgCol != null)\r\n    {\r\n        _selectedAverage = avgCol.DaxObjectFullName;\r\n    }\r\n}\r\n\r\n// Optional debug\r\n//string debugMsg = \"Selected: \" + string.Join(\", \", selectedValues);\r\n//debugMsg += \"\\nCalendar Date: \" + _CalendarDate;\r\n//debugMsg += _LastDateAvailable != null ? \"\\nLast Date Logic: \" + _LastDateAvailable : \"\";\r\n//debugMsg += _selectedAverage != null ? \"\\nRolling Average Column: \" + _selectedAverage : \"\";\r\n//MessageBox.Show(debugMsg);\r\n\r\n// Set starting ordinal\r\nint ordinal = cgTable.Name.StartsWith(\"New Calculation Group\") ? 0 :\r\n    (cgTable.CalculationItems.Count > 0 ? cgTable.CalculationItems.Max(ci => ci.Ordinal) + 1 : 0);\r\n        \r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// AddCalculationItemIfNotExists helper\r\n\r\nList<string> skippedItems = new List<string>();\r\n\r\nAction<string, string, int, string, string> AddCalculationItemIfNotExists = \r\n(name, expression, ordinalPos, description, formatString) =>\r\n{\r\nif (cgTable.CalculationItems.Any(ci => ci.Name.Equals(name, System.StringComparison.OrdinalIgnoreCase)))\r\n{\r\n    skippedItems.Add(name);\r\n    return;\r\n}\r\n\r\n\r\n    var item = cgTable.AddCalculationItem(name);\r\n    item.Expression = expression;\r\n    item.Ordinal = ordinalPos;\r\n    item.Description = description;\r\n    // FormatDax(item);\r\n};\r\n\r\n\r\n// ─────────────────────────────────────────────────────────────\r\n// Looping through all selected calculation item categories\r\nforeach (var item in selectedValues)\r\n{\r\n\r\n    if (item == \"Actual\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Actual\", \"SELECTEDMEASURE()\", ordinal++, \"Actual values\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Actual value until last date available\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual Y-1\", \r\n    string.Format(\r\n        \"CALCULATE(\\n\" +\r\n        \"    SELECTEDMEASURE(),\\n\" +\r\n        \"    SAMEPERIODLASTYEAR({0})\\n\" +\r\n        \")\", \r\n        _CalendarDate\r\n    ), \r\n    ordinal++, \"Actual value last year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"Actual to date Y-1\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\", \r\n_LastDateAvailable, \r\n_CalendarDate), ordinal++, \"Actual value last year, hiding future dates as of this year\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        _CurrentDates\r\n    )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA = Actual over Actual: Deviation for actual value this year and last year, hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA %\", string.Format(@\"\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _thisyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _CurrentDates\r\n        )\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_CurrentDates)\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"AOA %: Percentage change this year and last year, hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\n    \r\nRETURN \r\n    _thisyear - _lastyear\", _CalendarDate), ordinal++, \"AOA C = Complete Actual over Actual, not hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"AOA C %\", string.Format(@\"\r\nVAR _thisyear = SELECTEDMEASURE()\r\nVAR _lastyear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR({0})\r\n    )\r\nVAR _deviationYear = _thisyear - _lastyear\r\n\r\nRETURN \r\n    DIVIDE(_deviationYear, _lastyear)\", _CalendarDate), ordinal++, \"AOA C %: Complete Actual over Actual % change, not hiding future dates\", \"\\\"0%\\\"\");\r\n\r\n        continue;\r\n    }\r\n\r\n        // MTD logic\r\n    if (item == \"MTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"MTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _CurrentMonth - _PreviousMonth\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date: Month-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MOMTD %\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(_CurrentDates)\r\n    )\r\nVAR _PreviousMonth = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaMonth = _CurrentMonth - _PreviousMonth\r\n\r\nRETURN \r\n    DIVIDE(_DeltaMonth, _PreviousMonth)\", _LastDateAvailable, _CalendarDate), ordinal++, \"MOMTD = Month over Month to date %: % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Month, hiding future dates from last available date (same date last Month)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PQ\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSQUARTER(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated Month to date previous Quarter, hiding future dates from last available date (same date last quarter)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD({0})\r\n        )\"\r\n        , _CalendarDate), ordinal++, \"MTD C = Month to date Complete: accumulated, without hiding of future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD LY C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", \r\n        _CalendarDate), ordinal++, \"MTD LY C = Month to date Complete Last Year: Month last year accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"MTD PM C\", string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESMTD(PREVIOUSMONTH({0}))\r\n        )\", _CalendarDate), ordinal++, \"MTD PM C = Month to date, Previous month, Complete: Last Month previous month accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n    \r\n // QTD logic\r\n    if (item == \"QTD\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"QTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n    \r\nRETURN \r\n    \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date, hiding future dates after last available date\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n        \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\n\r\nRETURN \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\", _LastDateAvailable, _CalendarDate), ordinal++, \"Accumulated quarter to date last year, hiding future dates from last available date (same date last year)\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD\", string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n      \r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n\r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Deviation, this year and last year accumulated\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QOQTD %\", string.Format(@\"\r\n// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0} \r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESQTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate), ordinal++, \"QOQTD = Quarter over Quarter to date: Quarter-to-Date Index, % change this year compared to last year accumulated\", \"\\\"0%\\\"\");\r\n\r\n        AddCalculationItemIfNotExists(\"QTD C\", string.Format(@\"CALCULATE(\r\n     SELECTEDMEASURE(), \r\n     DATESQTD({0})\r\n     )\", _CalendarDate), ordinal++, \"QTD C = Quarter to date Complete: Quarter to date accumulated, without hiding future dates\", null);\r\n\r\n        AddCalculationItemIfNotExists(\"QTD LY C\", string.Format(@\"CALCULATE(\r\n    SELECTEDMEASURE(), \r\n    DATESQTD(SAMEPERIODLASTYEAR({0}))\r\n    )\", _CalendarDate), ordinal++, \"QTD LY C = Quarter to date last year Complete: Last Quarter accumulated, without hiding future dates\", null);\r\n\r\n        continue;\r\n    }\r\n\r\n// YTD logic\r\nif (item == \"YTD\")\r\n{\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}),\r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date, hiding future dates after last available date\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _Result = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\n    \r\nRETURN \r\n    _Result\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"Accumulated year to date last year, hiding future dates from last available date (same date last year)\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(_CurrentDates)\r\n     )\r\nVAR _PreviousYear = \r\n     CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n     )\r\n     \r\nRETURN \r\n    _CurrentYear - _PreviousYear\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Deviation, this year and last year accumulated\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YOYTD %\",\r\n        string.Format(@\"// https://www.sqlbi.com/articles/hiding-future-dates-for-calculations-in-dax/\r\n\r\nVAR _LastDayAvailable = {0}\r\nVAR _CurrentDates = \r\n    FILTER(VALUES({1}), \r\n    {1} <= _LastDayAvailable\r\n    )\r\nVAR _CurrentYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(_CurrentDates)\r\n    )\r\nVAR _PreviousYear = \r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        DATESYTD(SAMEPERIODLASTYEAR(_CurrentDates))\r\n    )\r\nVAR _DeltaYear = _CurrentYear - _PreviousYear\r\n\r\nRETURN \r\n    DIVIDE(_DeltaYear, _PreviousYear)\", _LastDateAvailable, _CalendarDate),\r\n        ordinal++, \"YOYTD = Year-to-Date Index %, % change this year vs last\", \"\\\"0%\\\"\"\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"YTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD({0})\r\n        )\", _CalendarDate),\r\n        ordinal++, \"YTD C = Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    AddCalculationItemIfNotExists(\r\n        \"LYTD C\",\r\n        string.Format(@\"CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        DATESYTD(SAMEPERIODLASTYEAR({0}))\r\n        )\", _CalendarDate),\r\n        ordinal++, \"LYTD C = Last Year-to-Date Complete, no future-date filtering\", null\r\n    );\r\n\r\n    continue;\r\n}\r\n\r\n      if (item == \"R12\")\r\n    {\r\n        AddCalculationItemIfNotExists(\"Rolling 12M\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\nRETURN IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months, hiding future dates after last available date\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M LY\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\n\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _Result =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _Result)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months last year, hiding future dates\", null);\r\n       \r\nAddCalculationItemIfNotExists(\"Rolling 12M Dev\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n    \r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates)\r\n        \r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, _CurrentResult - _PreviousResult)\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Deviation\", null);\r\n        \r\nAddCalculationItemIfNotExists(\"Rolling 12M idx\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\nVAR _LastDayShown = {0}\r\nVAR _NumOfMonths = 12\r\nVAR _ReferenceDate = \r\n    CALCULATE(\r\n        MAX({1}),\r\n        FILTER(VALUES({1}), \r\n        {1} <= _LastDayShown\r\n        )\r\n    )\r\n    \r\nVAR _PreviousDates =\r\n    DATESINPERIOD({1}, _ReferenceDate, -_NumOfMonths, MONTH)\r\n\r\nVAR _CurrentResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        _PreviousDates\r\n    )\r\nVAR _PreviousResult =\r\n    CALCULATE(\r\n        SELECTEDMEASURE(), \r\n        SAMEPERIODLASTYEAR(_PreviousDates)\r\n    )\r\n    \r\nVAR _DeviationResult = _CurrentResult - _PreviousResult\r\nVAR _firstDateInPeriod = MINX(_PreviousDates, {1})\r\n\r\nRETURN \r\n    IF(_firstDateInPeriod <= _ReferenceDate, DIVIDE(_DeviationResult, _PreviousResult))\", _LastDateAvailable, _CalendarDate), ordinal++, \"Rolling 12 months Index %\", \"\\\"0%\\\"\");\r\n        continue;\r\n    }\r\n    \r\n    \r\n    \r\n    if (item == \"Rolling average\")\r\n    {\r\n        if (!string.IsNullOrEmpty(_selectedAverage))\r\n        {\r\n            AddCalculationItemIfNotExists(\"Rolling 12M avg\", string.Format(@\"// Reference: https://www.sqlbi.com/articles/rolling-12-months-average-in-dax/\r\n\r\n //Calculating the average based on the selection in VALUES, such as per day or per month\r\n \r\nVAR _LastDayShown = {0}\r\n        \r\nVAR _NumOfMonths = 12\r\n// Hiding future days. If not remove the calculate in _ReferenceDate\r\nVAR  _LastCurrentDate = CALCULATE(\r\n    max({1}), FILTER(\r\n        VALUES( {1} ),\r\n        {1} <= _LastDayShown\r\n    )\r\n)\r\n\r\n VAR _Period =\r\n        DATESINPERIOD ( {1}, _LastCurrentDate, - _NumOfMonths, MONTH )  \r\n    \r\nVAR _Result =\r\n        CALCULATE (\r\n            AVERAGEX (\r\n                VALUES ( {2} ),     \r\n                SELECTEDMEASURE () \r\n            ),\r\n            _Period\r\n        ) \r\n    \r\n     VAR _firstDateInPeriod = MINX ( _Period, {1} )\r\n   \r\n    \r\nRETURN \r\n    IF ( _firstDateInPeriod <= _LastCurrentDate, _Result )\",\r\n    _LastDateAvailable, _CalendarDate, _selectedAverage),\r\n    ordinal++,\r\n    string.Format(\"Rolling 12 months average per {0}, hiding future dates\", _selectedAverage),\r\n    null);\r\n        }\r\n        continue;\r\n    }\r\n    \r\n        if (item == \"Rolling total\")\r\n        {     \r\n    AddCalculationItemIfNotExists(\"Rolling Total\", string.Format(@\"\r\nvar _currdate= {0}\r\n\r\nRETURN\r\n    CALCULATE(\r\n        SELECTEDMEASURE(),\r\n        FILTER(\r\n            ALLSELECTED({1}),\r\n            ISONORAFTER({1}, _currdate, DESC)\r\n        )\r\n    )\r\n\r\n     \"\r\n        , _LastDateAvailable, _CalendarDate), ordinal++,\r\n        \"Running Total, from the first date available until selected date\", null);\r\n        continue;\r\n    }\r\n    \r\n   \r\n    // Placeholder: additional Time Intelligence logic goes here\r\n  //  AddCalculationItemIfNotExists(item, \"SELECTEDMEASURE()\", ordinal++, \"Time Intelligence - \" + item, null);\r\n}\r\n\r\nif (skippedItems.Count > 0)\r\n{\r\nstring message = \"The following calculation item(s) were skipped because they already exist:\\n\\n\" + string.Join(\"\\n\", skippedItems);\r\n\r\n    MessageBox.Show(message, \"Items Skipped\", MessageBoxButtons.OK, MessageBoxIcon.Information);\r\n}\r\n\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\4. Autogenerate SUM for selected measures",
      "Enabled": "true",
      "Execute": "// This is a modification of the auto-generate script provided by Tabular Editor.\r\n// It is modified such that the user can select the table where the new measure is to be added\r\n// It adds logic setting AvailableInMDX = False for the base column\r\n\r\n//\r\n // Title: Auto-generate SUM measures from columns\r\n // \r\n // Author: Daniel Otykier, twitter.com/DOtykier\r\n // \r\n // This script, when executed, will loop through the currently selected columns,\r\n // creating one SUM measure for each column and also hiding the column itself.\r\n //\r\n\r\n\r\nusing System.Windows.Forms;\r\nusing System.Linq;\r\n\r\n// Prompt: Add to custom table?\r\nvar result = MessageBox.Show(\r\n    \"Do you want to add the new measure(s) to a custom table?\\n\\nClick 'Yes' to choose a table.\\nClick 'No' to add to each column's original table.\",\r\n    \"Choose Target Table\",\r\n    MessageBoxButtons.YesNoCancel\r\n);\r\n\r\nif (result == DialogResult.Cancel)\r\n{\r\n    return; // User cancelled\r\n}\r\n\r\nTable selectedTable = null;\r\n\r\nif (result == DialogResult.Yes)\r\n{\r\n    // Build a form with a ListBox for table selection\r\n    Form form = new Form();\r\n    ListBox listBox = new ListBox();\r\n    Button okButton = new Button();\r\n    Button cancelButton = new Button();\r\n\r\n    form.Text = \"Select a Table\";\r\n    form.Width = 400;\r\n    form.Height = 300;\r\n    form.FormBorderStyle = FormBorderStyle.FixedDialog;\r\n    form.StartPosition = FormStartPosition.CenterScreen;\r\n    form.MinimizeBox = false;\r\n    form.MaximizeBox = false;\r\n\r\n    listBox.Width = 360;\r\n    listBox.Height = 200;\r\n    listBox.Left = 10;\r\n    listBox.Top = 10;\r\n    listBox.SelectionMode = SelectionMode.One;\r\n    listBox.DataSource = Model.Tables.Select(t => t.Name).ToList();\r\n\r\n    okButton.Text = \"OK\";\r\n    okButton.Left = 220;\r\n    okButton.Top = 220;\r\n    okButton.DialogResult = DialogResult.OK;\r\n\r\n    cancelButton.Text = \"Cancel\";\r\n    cancelButton.Left = 300;\r\n    cancelButton.Top = 220;\r\n    cancelButton.DialogResult = DialogResult.Cancel;\r\n\r\n    form.Controls.Add(listBox);\r\n    form.Controls.Add(okButton);\r\n    form.Controls.Add(cancelButton);\r\n\r\n    form.AcceptButton = okButton;\r\n    form.CancelButton = cancelButton;\r\n\r\n    var dialogResult = form.ShowDialog();\r\n\r\n    if (dialogResult == DialogResult.OK && listBox.SelectedItem != null)\r\n    {\r\n        string tableName = listBox.SelectedItem.ToString();\r\n        if (!string.IsNullOrEmpty(tableName) && Model.Tables.Contains(tableName))\r\n        {\r\n            selectedTable = Model.Tables[tableName];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        Info(\"No table selected. Measures will be added to the column's original table.\");\r\n    }\r\n}\r\n\r\n// Loop through selected columns and add SUM measures\r\nforeach (var c in Selected.Columns)\r\n{\r\n    var finalTable = selectedTable ?? c.Table;\r\n    var daxExpression = \"SUM(\" + c.DaxObjectFullName + \")\";\r\n\r\n    bool measureExists = Model.AllMeasures.Any(m =>\r\n        m.Expression.Replace(\" \", \"\").Replace(\"\\n\", \"\").Replace(\"\\r\", \"\").Replace(\"\\t\", \"\") == daxExpression.Replace(\" \", \"\")\r\n    );\r\n\r\n    if (!measureExists)\r\n    {\r\n        var measure = finalTable.AddMeasure(\r\n            \"Total \" + c.Name,\r\n            daxExpression,\r\n            c.Table.Name\r\n        );\r\n\r\n        measure.FormatString = \"#,0\";\r\n        measure.Description = \"This measure is the sum of column \" + c.DaxObjectFullName;\r\n\r\n        c.IsHidden = true;\r\n        c.IsAvailableInMDX = false;\r\n\r\n        c.SummarizeBy = AggregateFunction.None;\r\n    }\r\n    else\r\n    {\r\n        Output(\"Skipped: Measure already exists for column '\" + c.Name + \"' with expression '\" + daxExpression + \"'\");\r\n    }\r\n}\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\4. Create Time Intelligence measures",
      "Enabled": "true",
      "Execute": "//\r\n // Title: Create TI measures for selected measures with calc group Time Calculations\r\n // \r\n // Author: Eivind Haugen\r\n // \r\n // To execute this script, it will be executed based on a selected measure \r\n //     and next you are promted to selected the calculation item(s):\r\n\r\n // It runs a nested for-loop to create all the time intelligence measures\r\n // \r\n // For each measure with Time Intelligence, it will do the following:\r\n // 1. Creates the DAX expression from the selected Time Intelligence calculation item, and replaces selectedmeasure(), with the measure object (DaxObjectName)\r\n // 2. Adds a display-folder. \r\n // 3. Apply logic for formatting. If calculation contains idx, % or pct, always set to %, if not use the format from the selected measure\r\n // 4. Adds a description as a combination of the description for the measure and time intelligence\r\n // 5. Keeps the format of the Calculation item  expression, but not formatting via DAXformatter (if it's not formatted, it's not DAX)\r\n // \r\n // To ensure the best result, ensure that base-measures have format string and descriptions, and descriptions are included for time intelligence calculations\r\n //     - This is ensured if macros are run as part of this creation\r\n \r\n\r\n\r\n\r\n#r \"System.Drawing\"\r\nusing System.Windows.Forms;\r\nusing System.Drawing;\r\nusing System.Linq;\r\nusing System.Collections.Generic;\r\nusing System.Text.RegularExpressions;\r\n\r\n// Hide script dialog and cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n// STEP 1: Get list of calculation group tables and let user select one\r\nvar calcGroupTables = Model.Tables\r\n    .Where(t => t is CalculationGroupTable)\r\n    .Cast<CalculationGroupTable>()\r\n    .ToList();\r\n\r\nif (calcGroupTables.Count == 0)\r\n{\r\n    MessageBox.Show(\"No calculation groups found in the model.\");\r\n    return;\r\n}\r\n\r\nvar selectedCalcGroupTable = SelectTable(\r\n    calcGroupTables,\r\n    null,\r\n    \"Select a Calculation Group Table\"\r\n) as CalculationGroupTable;\r\n\r\nif (selectedCalcGroupTable == null)\r\n{\r\n    MessageBox.Show(\"No calculation group table selected.\");\r\n    return;\r\n}\r\n\r\n// STEP 2: Let user select multiple calculation items from that group\r\nvar calcItems = selectedCalcGroupTable.CalculationItems.ToList();\r\n\r\nForm calcItemForm = new Form();\r\nListBox calcItemListBox = new ListBox();\r\nButton calcItemOkButton = new Button();\r\nLabel calcItemLabel = new Label();\r\n\r\ncalcItemForm.Text = \"Select Calculation Items\";\r\ncalcItemForm.Width = 350;\r\ncalcItemForm.Height = 500;\r\n\r\ncalcItemListBox.Items.AddRange(calcItems.Select(ci => ci.Name).ToArray());\r\ncalcItemListBox.SelectionMode = SelectionMode.MultiExtended;\r\ncalcItemListBox.Location = new Point(50, 20);\r\ncalcItemListBox.Width = 200;\r\ncalcItemListBox.Height = 400;\r\n\r\ncalcItemOkButton.Text = \"OK\";\r\ncalcItemOkButton.Location = new Point(100, 430);\r\ncalcItemOkButton.Width = 100;\r\ncalcItemOkButton.Click += (sender, e) => { calcItemForm.Close(); };\r\n\r\ncalcItemLabel.Text = \"Select one or more calculation items:\";\r\ncalcItemLabel.Location = new Point(50, 0);\r\ncalcItemLabel.Width = 200;\r\n\r\ncalcItemForm.Controls.Add(calcItemListBox);\r\ncalcItemForm.Controls.Add(calcItemOkButton);\r\ncalcItemForm.Controls.Add(calcItemLabel);\r\n\r\ncalcItemForm.ShowDialog();\r\n\r\nvar selectedCalcItemNames = calcItemListBox.SelectedItems.Cast<string>().ToList();\r\nvar selectedCalcItems = calcItems.Where(ci => selectedCalcItemNames.Contains(ci.Name)).ToList();\r\n\r\nif (selectedCalcItems.Count == 0)\r\n{\r\n    MessageBox.Show(\"No calculation items selected.\");\r\n    return;\r\n}\r\n\r\n// STEP 3: Get already selected measures\r\nvar selectedMeasures = Selected.Measures.ToList();\r\n\r\nif (selectedMeasures.Count == 0)\r\n{\r\n    MessageBox.Show(\"No base measures selected in Tabular Editor.\");\r\n    return;\r\n}\r\n\r\n// STEP 4: Validate metadata before creating new measures\r\n// Initialize lists to track missing metadata\r\nvar missingFormatString = new List<string>();\r\nvar missingMeasureDescription = new List<string>();\r\nvar missingCalcItemDescription = new List<string>();\r\n\r\n// Check selected measures\r\nforeach (var m in selectedMeasures)\r\n{\r\n    if (string.IsNullOrWhiteSpace(m.FormatString))\r\n        missingFormatString.Add(m.Name);\r\n    if (string.IsNullOrWhiteSpace(m.Description))\r\n        missingMeasureDescription.Add(m.Name);\r\n}\r\n\r\n// Check selected calculation items\r\nforeach (var c in selectedCalcItems)\r\n{\r\n    if (string.IsNullOrWhiteSpace(c.Description))\r\n        missingCalcItemDescription.Add(c.Name);\r\n}\r\n\r\n// Build info message if any metadata is missing\r\nif (missingFormatString.Any() || missingMeasureDescription.Any() || missingCalcItemDescription.Any())\r\n{\r\n    string infoMessage = \"Missing metadata detected and not added to new measure:\\n\\n\" +\r\n    \"- Option 1: Press Cancel, fix items, then run script again\\n\" +\r\n    \"- Option 2: Apply format string/ description after creation\\n\";\r\n\r\n    if (missingFormatString.Any())\r\n    {\r\n        infoMessage += \"\\n• Format string missing in measures:\\n\";\r\n        foreach (var name in missingFormatString)\r\n            infoMessage += \"   - \" + name + \"\\n\";\r\n    }\r\n\r\n    if (missingMeasureDescription.Any())\r\n    {\r\n        infoMessage += \"\\n• Description missing in measures:\\n\";\r\n        foreach (var name in missingMeasureDescription)\r\n            infoMessage += \"   - \" + name + \"\\n\";\r\n    }\r\n\r\n    if (missingCalcItemDescription.Any())\r\n    {\r\n        infoMessage += \"\\n• Description missing in calculation items:\\n\";\r\n        foreach (var name in missingCalcItemDescription)\r\n            infoMessage += \"   - \" + name + \"\\n\";\r\n    }\r\n\r\n    var result = MessageBox.Show(infoMessage, \"Missing Metadata\", MessageBoxButtons.OKCancel, MessageBoxIcon.Warning);\r\n    if (result == DialogResult.Cancel)\r\n        return;\r\n}\r\n\r\n\r\n// STEP 5: Generate new measures\r\nstring calcGroupColumnName = selectedCalcGroupTable.Columns[0].DaxObjectName;\r\n\r\nforeach (var m in selectedMeasures)\r\n{\r\n    foreach (var c in selectedCalcItems)\r\n    {\r\n        // Choose format string. Sets % format for all measures with certain text included. If not the format of the measure\r\n        string formatString = \r\n            c.Name.ToLower().Contains(\"idx\") || \r\n            c.Name.Contains(\"%\") || \r\n            c.Name.ToLower().Contains(\"pct\")\r\n            ? \"#,0.0%;-#,0.0%;#,0.0%\"\r\n            : m.FormatString;\r\n\r\n // Use the DAX expression from the calculation item, replacing SELECTEDMEASURE() with the actual measure reference\r\n\r\n \r\nstring daxExpression = Regex.Replace(\r\n    c.Expression,\r\n    @\"(?i)\\bSELECTEDMEASURE\\s*\\(\\s*\\)\",  // Case-insensitive + optional whitespace\r\n    m.DaxObjectName\r\n);\r\n\r\n\r\n        // Display folder logic\r\n        string displayFolderBase = m.DisplayFolder;\r\n        string displayFolder = displayFolderBase + \"\\\\\" + m.Name + \" - Time Intelligence\";\r\n\r\n        // Create the new measure\r\n        var newMeasure = m.Table.AddMeasure(\r\n            m.Name + \" \" + c.Name,\r\n            daxExpression,\r\n            displayFolder\r\n        );\r\n\r\n// Apply format string and description\r\nnewMeasure.FormatString = formatString;\r\n\r\n// Only add description if both components are available\r\nif (!string.IsNullOrWhiteSpace(m.Description) && !string.IsNullOrWhiteSpace(c.Description))\r\n{\r\n    newMeasure.Description = m.Description + \" - using Time Intelligence definition (\" + c.Name + \"): \" + c.Description;\r\n}\r\n    \r\n        // Format DAX for readability (skipping in TE2 due to potential slow performance\r\n        // newMeasure.Expression = FormatDax(newMeasure.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n    }\r\n}\r\n\r\n//MessageBox.Show(\"New measures created successfully.\");\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\4. Create deviation measure",
      "Enabled": "true",
      "Execute": "\r\n//\r\n // Title: Create measure Deviation (e.g. Profit/ to target)\r\n // \r\n // Author: Eivind Haugen\r\n // \r\n // This script, when executed, will let you create a measure with deviation and % difference between measures (only selection two measures is an option\r\n // \r\n // The purpose of the script is to ensure best practice is included when creating measures. \r\n //\r\n // Typical use case is to calculat Profit and Margin %, or difference to a target\r\n //\r\n\r\n\r\nusing System;\r\nusing System.Linq;\r\nusing System.Windows.Forms;\r\n\r\npublic class InputDialog\r\n{\r\n    public static string ShowInputDialog(string text, string caption, string defaultValue)\r\n    {\r\n        Form prompt = new Form()\r\n        {\r\n            Width = 600,\r\n            Height = 150,\r\n            FormBorderStyle = FormBorderStyle.FixedDialog,\r\n            Text = caption,\r\n            StartPosition = FormStartPosition.CenterScreen\r\n        };\r\n        Label textLabel = new Label() { Left = 50, Top = 20, Text = text, AutoSize = true };\r\n        TextBox textBox = new TextBox() { Left = 50, Top = 50, Width = 500, Text = defaultValue };\r\n        Button confirmation = new Button() { Text = \"OK\", Left = 450, Width = 100, Top = 70, DialogResult = DialogResult.OK };\r\n        confirmation.Click += (sender, e) => { prompt.Close(); };\r\n        prompt.Controls.Add(textLabel);\r\n        prompt.Controls.Add(textBox);\r\n        prompt.Controls.Add(confirmation);\r\n        prompt.AcceptButton = confirmation;\r\n\r\n        return prompt.ShowDialog() == DialogResult.OK ? textBox.Text.Trim() : \"\";\r\n    }\r\n}\r\n\r\n// Hide spinner and cursor\r\nScriptHelper.WaitFormVisible = false;\r\nApplication.UseWaitCursor = false;\r\n\r\n// Input dialogs\r\nstring deviationName = InputDialog.ShowInputDialog(\"Provide the name for deviation measure\", \"Measure Name\", \"Profit\");\r\nstring deviationPctName = InputDialog.ShowInputDialog(\"Provide the name for deviation % measure\", \"Measure Name % change\", \"Margin %\");\r\n\r\n// Check if exactly two measures are selected\r\nif (Selected.Measures.Count != 2)\r\n{\r\n    Error(\"You must select exactly two measures!\");\r\n    return;\r\n}\r\n\r\n// Retrieve the selected measures\r\nvar selectedMeasures = Selected.Measures.ToList();\r\nvar measure1 = selectedMeasures[0];\r\nvar measure2 = selectedMeasures[1];\r\n\r\n// Clean variable names\r\nstring var1 = \"_\" + measure1.Name.Replace(\" \", \"_\");\r\nstring var2 = \"_\" + measure2.Name.Replace(\" \", \"_\");\r\nstring varDev = \"_deviation\";\r\n\r\n// Create DAX expressions\r\nstring daxDeviation = measure1.DaxObjectName + \" - \" + measure2.DaxObjectName;\r\n\r\nstring daxDeviationPct =\r\n    \"VAR \" + var1 + \" = \" + measure1.DaxObjectName + \"\\n\" +\r\n    \"VAR \" + var2 + \" = \" + measure2.DaxObjectName + \"\\n\" +\r\n    \"VAR \" + varDev + \" = \" + var1 + \" - \" + var2 + \"\\n\" +\r\n    \"RETURN DIVIDE(\" + varDev + \", \" + var2 + \")\";\r\n\r\nvar targetTable = measure1.Table;\r\n\r\n// Create deviation measure\r\nif (!string.IsNullOrWhiteSpace(deviationName))\r\n{\r\n    var m = targetTable.AddMeasure(deviationName, daxDeviation, measure1.DisplayFolder);\r\n    m.FormatString = measure1.FormatString;\r\n    m.Description = \"This measure is the deviation between \" + measure1.DaxObjectFullName + \" and \" + measure2.DaxObjectFullName;\r\n    m.Expression = FormatDax(m.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n}\r\n\r\n// Create deviation % measure\r\nif (!string.IsNullOrWhiteSpace(deviationPctName))\r\n{\r\n    var mPct = targetTable.AddMeasure(deviationPctName, daxDeviationPct, measure1.DisplayFolder);\r\n    mPct.FormatString = \"#,0.0%;-#,0.0%;#,0.0%\";\r\n    mPct.Description = \"This measure is the % change between \" + measure1.DaxObjectFullName + \" and \" + measure2.DaxObjectFullName;\r\n    mPct.Expression = FormatDax(mPct.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\8. Create model documentation",
      "Enabled": "true",
      "Execute": "// Credit to Fernan for original DAX idea\r\n// Converted to C# Script from DAX script created by David Kofod Hanna\r\n\r\n// Check if the calculated table already exists, if so delete it\r\nvar existingTable = Model.Tables.FirstOrDefault(t => t.Name == \"Model Documentation\");\r\nif (existingTable != null)\r\n{\r\n    existingTable.Delete();\r\n}\r\n\r\n// DAX to create the calculated table\r\nvar docTableDax = @\"\r\nVAR _columns =\r\n    SELECTCOLUMNS(\r\n        FILTER(\r\n            INFO.VIEW.COLUMNS(),\r\n            [Table] <> \"\"Model Documentation\"\" && NOT([IsHidden])\r\n        ),\r\n        \"\"Type\"\", \"\"Column\"\",\r\n        \"\"Name\"\", [Name],\r\n        \"\"Description\"\", [Description],\r\n        \"\"Location\"\", [Table],\r\n        \"\"Expression\"\", [Expression]\r\n    )\r\nVAR _measures =\r\n    SELECTCOLUMNS(\r\n        FILTER(\r\n            INFO.VIEW.MEASURES(),\r\n            [Table] <> \"\"Model Documentation\"\" && NOT([IsHidden])\r\n        ),\r\n        \"\"Type\"\", \"\"Measure\"\",\r\n        \"\"Name\"\", [Name],\r\n        \"\"Description\"\", [Description],\r\n        \"\"Location\"\", [Table],\r\n        \"\"Expression\"\", [Expression]\r\n    )\r\nVAR _tables =\r\n    SELECTCOLUMNS(\r\n        FILTER(\r\n            INFO.VIEW.TABLES(),\r\n            [Name] <> \"\"Model Documentation\"\" && [Name] <> \"\"Calculations\"\" && NOT([IsHidden])\r\n        ),\r\n        \"\"Type\"\", \"\"Table\"\",\r\n        \"\"Name\"\", [Name],\r\n        \"\"Description\"\", [Description],\r\n        \"\"Location\"\", BLANK(),\r\n        \"\"Expression\"\", [Expression]\r\n    )\r\nVAR _relationships =\r\n    SELECTCOLUMNS(\r\n        INFO.VIEW.RELATIONSHIPS(),\r\n        \"\"Type\"\", \"\"Relationship\"\",\r\n        \"\"Name\"\", [Relationship],\r\n        \"\"Description\"\", BLANK(),\r\n        \"\"Location\"\", BLANK(),\r\n        \"\"Expression\"\", [Relationship]\r\n    )\r\nRETURN\r\n    UNION(_columns, _measures, _tables, _relationships)\r\n\";\r\n\r\n// Create the new calculated table\r\nvar documentationTable = Model.AddCalculatedTable(\"Model Documentation\", docTableDax);\r\n\r\n// Create the measures\r\nvar measure1 = documentationTable.AddMeasure(\r\n    \"# of Measures\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Measure\\\")\"\r\n);\r\nmeasure1.FormatString = \"#,0\";\r\nmeasure1.Description = \"COUNTROWS('Model Documentation') where Type = 'Measure'\";\r\n\r\nvar measure2 = documentationTable.AddMeasure(\r\n    \"# of Columns\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Column\\\")\"\r\n);\r\nmeasure2.FormatString = \"#,0\";\r\nmeasure2.Description = \"COUNTROWS('Model Documentation') where Type = 'Column'\";\r\n\r\nvar measure3 = documentationTable.AddMeasure(\r\n    \"# of Tables\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Table\\\")\"\r\n);\r\nmeasure3.FormatString = \"#,0\";\r\nmeasure3.Description = \"COUNTROWS('Model Documentation') where Type = 'Table'\";\r\n\r\nvar measure4 = documentationTable.AddMeasure(\r\n    \"# of Relationship\",\r\n    \"CALCULATE(COUNTROWS('Model Documentation'), 'Model Documentation'[Type] = \\\"Relationship\\\")\"\r\n);\r\nmeasure4.FormatString = \"#,0\";\r\nmeasure4.Description = \"COUNTROWS('Model Documentation') where Type = 'Relationship'\";\r\n\r\n// Optional: Refresh schema (Tabular Editor 3 only)\r\n// Model.Sync();\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\9. Do not summarize numeric columns",
      "Enabled": "true",
      "Execute": "foreach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n        // Set SummarizeBy to None for columns ending in \"Key\" or \"ID\"\r\n        if (column.Name.EndsWith(\"Key\") || column.Name.EndsWith(\"ID\"))\r\n        {\r\n            column.SummarizeBy = AggregateFunction.None;\r\n        }\r\n\r\n        // Set SummarizeBy to None for numeric columns not already set to None, not hidden, and not from hidden tables\r\n        if ((column.DataType == DataType.Int64 ||\r\n             column.DataType == DataType.Decimal ||\r\n             column.DataType == DataType.Double) &&\r\n            column.SummarizeBy != AggregateFunction.None &&\r\n            !column.IsHidden &&\r\n            !column.Table.IsHidden)\r\n        {\r\n            column.SummarizeBy = AggregateFunction.None;\r\n        }\r\n    }\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\9. Format measures - Max 20",
      "Enabled": "true",
      "Execute": "if (Selected.Measures.Count == 0)\r\n{\r\n    Error(\"No measures selected. Please select one or more measures to format.\");\r\n    return;\r\n}\r\n\r\nif (Selected.Measures.Count > 20)\r\n{\r\n    Error(\"Too many measures selected. Reduce usage of DAXformatter\");\r\n    return;\r\n}\r\n\r\nforeach (var m in Selected.Measures)\r\n{\r\n    m.Expression = FormatDax(m.Expression, shortFormat: true, skipSpaceAfterFunctionName: true);\r\n    /* Format only the selected measures using DAX Formatter */\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\9. Format string for date-columns",
      "Enabled": "true",
      "Execute": "foreach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n        // Check if the column name contains \"Date\" (case insensitive)\r\n        bool containsDate = column.Name.IndexOf(\"Date\", StringComparison.OrdinalIgnoreCase) >= 0;\r\n\r\n        // Check if the column is of DateTime data type\r\n        bool isDateTime = column.DataType == TabularEditor.TOMWrapper.DataType.DateTime;\r\n\r\n        // Check if the column format is NOT \"mm/dd/yyyy\"\r\n        bool incorrectFormat = column.FormatString != \"mm/dd/yyyy\";\r\n\r\n        // Apply the format change if all conditions are met\r\n        if (containsDate && isDateTime && incorrectFormat)\r\n        {\r\n            column.FormatString = \"mm/dd/yyyy\";\r\n        }\r\n    }\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\9. Load best practice rules",
      "Enabled": "true",
      "Execute": "\r\n// Loading the best practice rules developed by Michael Kovalsky to the location where TE is installed\r\n\r\n// Download BPARules.json from GitHub to the correct folder based on TE version\r\nvar client = new System.Net.WebClient();\r\n\r\nstring localPath = System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData);\r\nstring url = \"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\";\r\n\r\n// Default to TE2 path\r\nstring destination = System.IO.Path.Combine(localPath, @\"TabularEditor\\BPARules.json\");\r\n\r\n// Adjust for TE3 if needed\r\nstring version = typeof(ScriptHelper).Assembly.GetName().Version.Major.ToString();\r\nif (version == \"3\")\r\n{\r\n    destination = System.IO.Path.Combine(localPath, @\"TabularEditor3\\BPARules.json\");\r\n}\r\n\r\n// Download file\r\nclient.DownloadFile(url, destination);\r\n\r\n// Confirm success\r\n//Info(\"Best Practice Analyzer rules downloaded to:\\n\" + destination);\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\9. Set Available in MDX to false for all",
      "Enabled": "true",
      "Execute": "\r\n// Setting all columns to not available in MDX.\r\n// Se information:  https://data-mozart.com/hidden-little-gem-that-can-save-your-power-bi-life/\r\n\r\n// Ensure that IsAvailableInMDX is set to false if it is not to be used in Excel or as sorting for other columns etc\r\n\r\nforeach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n \r\n        column.IsAvailableInMDX = false;\r\n       \r\n    }\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "DoneIn60seconds-main\\9. Set Available in MDX to false",
      "Enabled": "true",
      "Execute": "\r\n// Ensure that IsAvailableInMDX is set to false if it is not to be used in Excel or as sorting for other columns etc\r\n\r\nforeach (var table in Model.Tables)\r\n{\r\n    foreach (var column in table.Columns)\r\n    {\r\n        // Set IsAvailableInMDX to false for columns ending in \"Key\" or \"ID\"\r\n        if (column.Name.EndsWith(\"Key\") || column.Name.EndsWith(\"ID\"))\r\n        {\r\n            column.IsAvailableInMDX = false;\r\n        }\r\n\r\n        // Set IsAvailableInMDX to false for hidden/unnecessary columns\r\n        if (column.IsAvailableInMDX &&\r\n            (column.IsHidden || column.Table.IsHidden) &&\r\n            !column.UsedInSortBy.Any() &&\r\n            !column.UsedInHierarchies.Any() &&\r\n            !column.UsedInVariations.Any() &&\r\n            column.SortByColumn == null)\r\n        {\r\n            column.IsAvailableInMDX = false;\r\n        }\r\n    }\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    }
  ]
}